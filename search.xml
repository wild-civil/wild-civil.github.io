<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>硬件学习之-OpAmp</title>
      <link href="/post/d73a1929.html"/>
      <url>/post/d73a1929.html</url>
      
        <content type="html"><![CDATA[<p>待补充…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
            <tag> 运放 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AX6600雅典娜 路由器 刷机</title>
      <link href="/post/e7138a76.html"/>
      <url>/post/e7138a76.html</url>
      
        <content type="html"><![CDATA[<p>最近没时间上传图片，图片先存本地NAS了<br>可以先看我的CSDN <a href="https://blog.csdn.net/m0_50695988?spm=1000.2115.3001.5343">我的SCDN</a></p><h1 id="向导"><a href="#向导" class="headerlink" title="向导"></a>向导</h1><p> 最近想玩 openwrt，在小黄鱼淘了一台”ax6600雅典娜”路由器硬改 4+256g，刷了 lean 的 QWRT 固件，可以控制 LED 屏幕</p><p>遂想记录一下</p><p>插电后连接 WiFi 或插网线，默认 <code>192.168.1.1</code>，由浏览器进入路由器后台界面，有基础配置，比如 主机密码 (登录后台的密码)， pppoe 拨号，wifi 名称密码更改等</p><p><img src="wifi连接.png" alt=""></p><p><img src="qwrt向导.png" alt=""></p><p><img src="qwrt引导结束.png" alt=""><br>基本向导结束后，就可以开整啦</p><p>进后台后，我发现存储空间不对，上网搜索后，发现需要自己进行扩容，所以我就先进行了扩容操作</p><blockquote><p>ps：</p><ol><li>如果是英文的话可以在右侧”系统-&gt;软件包”搜索 <code>luci-i18n-base-zh-cn</code> 并安装</li><li>如果台式机插网线无法进后台，大概率是电脑未开启 DHCP (也可以手动配置)</li></ol></blockquote><p>“Win+R-&gt;cmd” 输入 <code>ssh root@192.168.1.1</code><br>若跳出<em>Unable to negotiate with 192.168.1.1 port 22: no matching host key type found. Their offer: ssh-rsa</em><br>说明你电脑的 SSH 客户端太新、太安全，可以临时启用 RSA 算法 <code>ssh -o HostKeyAlgorithms=+ssh-rsa root@192.168.1.1</code><br>(这里我使用 finalshell 工具演示)</p><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>连接成功后输入<code>cfdisk /dev/mmcblk0</code></p><p><img src="cfdisk__dev_mmcblk0.png" alt=""></p><p>用方向键移到最后一行，会显示 free spce。方向键选择 <code>new</code> 敲回车，然后 <code>write</code> 敲回车，输入 <code>yes</code> 确认将分区表写入磁盘</p><p><img src="write_partition.gif" alt=""></p><p>这个时候只是建立了一个新的分区（并没有挂载）所以输入 df -h 并没有看到刚才的分区<br><img src="disk_free_human_readable_1.png" alt=""></p><p>好的，现在，使用 <code>fdisk -l</code> 查看是否建立一个新的分区<br><img src="fdisk_-l.png" alt=""></p><p>使用 <code>fdisk /dev/mmcblk0p27</code> (按照下面的步骤，”mmcblk0p27”需要换成自己的，具体情况具体操作)</p><p><img src="fdisk__dev_mmcblk0p27.png" alt=""></p><p>现在分区扩大了，但文件系统还没用正确识别</p><p>输入格式化命令 <code>mkfs.ext4 /dev/mmcblk0p27</code><br><img src="format_partition.png" alt=""></p><p>把 mmcblk0p27分区从 <code>/dev</code> 移动到 <code>/mnt</code> 挂载目录下；命令为：<code>mount /dev/mmcblk0p27 /mnt/mmcblk0p27</code> (若不存在可以新建一个: mkdir -p /mnt/mmcblk0p27 )</p><p>这时载输入 <code>df -h</code> 就可以看到分区啦<br><img src="disk_free_human_readable_2.png" alt=""></p><p><strong>至此，扩容完成！</strong></p><p>这下就可以进入路由器后台界面”系统-&gt;挂载点”新添加一个挂载点</p><p><img src="add_a_mount_point.png" alt=""></p><p>这里挂载点我选择了/home，你也可以按照自己想要的来</p><p><img src="mount_point_set.gif" alt=""></p><p>参考文献：<br>[1]  <a href="https://blog.csdn.net/2301_79100880/article/details/145150432">关于ax6600的刷机注意点，以及openwrt扩展overlay，以及安装docker</a><br>[2]  <a href="https://blog.csdn.net/qq_37408144/article/details/146292481">【小白教程】openwrt/qwrt 搭建 web 环境 onmp(nginx+php+myspl)</a><br>[3]  <a href="https://250.ac.cn/2025/01/12/JDCloud-AX6600-openwrt/">JDCloud AX6600（雅典娜） 刷机记录</a></p><hr><hr><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>安装 docker</p><p>先更新一下：<code>opkg update</code><br>然后开始安装：<code>opkg install dockerd docker luci-app-dockerman</code></p><p><img src="install_docker.png" alt=""></p><p>完成之后需要等一会，刷新后 docker 就出现在右侧了</p><p>结束安装完成（注意这里安装完是英文界面，需要安装中文包才能显示中文）</p><p><img src="docker_en.png" alt=""></p><p>在右侧 “系统-&gt;软件包”搜索 <code>luci-i18n-dockerman-zh-cn</code>，然后进行安装</p><p><img src="docker_zh-cn.png" alt=""></p><p>为了防止 docker 东西太多，我这里将 docker 根目录设置为 <code>/mnt/mmcblk0p27/docker/</code>，当然你也可以保持默认 <code>/opt/docker</code>，然后将 <code>/dev/mmcblk0p27</code> 挂载在 <code>/opt</code><br><img src="docker_path.png" alt=""></p><p>然后就可以开心的使用 docker 啦</p><blockquote><p>命令行操作：在终端中运行以下命令以获取最新的 HomeAssistant 镜像：<br> <code>docker pull homeassistant/home-assistant:latest</code></p><p>图形化操作：在”docker-&gt;镜像”中，拉取镜像 <code>homeassistant/home-assistant:latest</code></p></blockquote><p><img src="docker_mirror_ui.png" alt=""></p><p>如果出现以下情况，说明需要研习一下如何正确科学的上网<br><img src="docker_pull_fail.png" alt=""></p><p>学会科学上网后，再次拉取</p><p><img src="docker_pull_triumph.png" alt=""></p><p>完美</p><p>使用 Docker 启动 HomeAssistant，如果用</p><p>图形化操作简单明了，但是有点费劲，下面我就用命令操作了：</p><hr><ol><li><p>创建配置目录<br>为 HomeAssistant 创建一个挂载目录，用于存储配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/homeassistant/config</span><br><span class="line">chmod -R 777 /data/homeassistant/config</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name homeassistant \</span><br><span class="line">--restart=always \</span><br><span class="line">--privileged \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-v /data/homeassistant/config:/config \</span><br><span class="line">--network=host \</span><br><span class="line">homeassistant/home-assistant:latest</span><br></pre></td></tr></table></figure></li></ol><p><code>-v /data/homeassistant/config:/config</code>：将主机的配置目录 <code>/data/homeassistant</code>挂载到容器中。<br><code>--network=host</code>：使用主机网络模式，便于设备发现。</p><ol><li>检查容器状态</li></ol><p>确保容器正常运行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><br><img src="docker_ps_ha_only.png" alt=""><br>查看日志以确认服务是否启动成功：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs homeassistant</span><br></pre></td></tr></table></figure></p><ol><li>访问 HomeAssistant</li></ol><p>在浏览器中访问以下地址完成初始配置：</p><p>http://&lt;你的IP&gt;:8123/<br>设置用户名、密码、时区等基本信息即可开始使用。</p><p><img src="HA_set.png" alt=""></p><hr><p>参考文献：<br>[1]  <a href="https://www.cnblogs.com/isit/p/17043428.html">Docker+HomeAssistant+HACS+设备接入教程</a><br>[2]  <a href="https://cloud.tencent.com/developer/article/2548349">给12块的随身 WiFi 基于 Docker 部署 HomeAssistant（完结篇）</a></p><hr><hr><p>docker run -d<br>-v /opt/tttime:/mnt/data/ttnode<br>-v /var/run/docker.sock:/var/run/docker.sock<br>-v /proc:/host/proc:ro<br>—name ttnode<br>—hostname ttnode<br>—device /dev/mem<br>—cap-add SYS_RAWIO<br>—privileged<br>—net=host<br>—restart=always<br>-e container_name=ttnode<br>registry.cn-hangzhou.aliyuncs.com/tiptime/ttnode:latest</p><hr><p>cfdisk /dev/mmcblk0</p><p>mkfs. ext4 /dev/mmcblk0p27</p><p>lsblk</p><hr><hr><h1 id="安装-iStore"><a href="#安装-iStore" class="headerlink" title="安装 iStore"></a>安装 iStore</h1><p>先在<a href="https://istore.linkease.com/repo/all/store/">Index of /repo/all/store/</a> 下载所需文件</p><p><img src="iStore_files_download.png" alt=""><br>下载好后进入路由器后台，在右侧的”系统-&gt;文件传输”中将四个文件依次上传</p><p><img src="iStore_upload.png" alt=""></p><p>然后按照顺序依次安装<br>例如我的顺序错</p><ol><li>luci-lib-taskd_1.0.23_all. ipk</li><li>luci-lib-xterm_4.18.0_all. ipk</li><li>luci-app-store_0.1.29-5_all. ipk</li><li>taskd_1.0.3-2_all. ipk<br><img src="iStore_install.png" alt=""></li></ol><p>完成之后，刷新一下页面即可在右侧看到 <code>iStore</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如果iStore遇见问题 /usr/libexec/taskd: exec: line 11: script: not found</span><br><span class="line">可以先卸载再安装一遍</span><br><span class="line"></span><br><span class="line"># 1. 先卸载最上层的应用（依赖其他包）</span><br><span class="line">opkg remove luci-app-store</span><br><span class="line"></span><br><span class="line"># 2. 卸载库文件</span><br><span class="line">opkg remove luci-lib-xterm</span><br><span class="line">opkg remove luci-lib-taskd</span><br><span class="line"></span><br><span class="line"># 3. 最后卸载核心后台程序</span><br><span class="line">opkg remove taskd</span><br><span class="line"></span><br><span class="line"># 4. 检查是否卸载干净（应该看不到这些包了）</span><br><span class="line">opkg list-installed | grep -E &#x27;(taskd|istore|xterm)&#x27;</span><br></pre></td></tr></table></figure><p>参考文献：<br>[1]  <a href="https://www.etzzy.com/8430.html">京东云雅典娜（ax6600）QWRT安装istore</a></p><hr><hr><h1 id="安装-OpenClash"><a href="#安装-OpenClash" class="headerlink" title="安装 OpenClash"></a>安装 OpenClash</h1><p>①安装了 OpenClash，实现了局域网下看世界<br>②安装了 luci-app-design-config 对 Design 主题进行设置，实现了明暗主题切换，导航栏 vpn 的图标由小飞机切换为小猫咪</p><p>ax6600 雅典娜 小猫咪安装</p><p>首先去 github 下载 <a href="https://github.com/vernesong/OpenClash/releases">OpenClash</a> 的对应文件，例如我这里下载 <code>luci-app-openclash_0.46.137_all.ipk</code></p><p><img src="openclash_0.46.137_all.ipk.png" alt=""></p><p>在右侧的”系统-&gt;文件传输”中上传文件，并安装</p><p><img src="openclash_upload_install.png" alt=""></p><p>然后在右侧的”服务-&gt;OpenClash”中进行配置</p><p><img src="openclash_set.png" alt=""></p><hr><p>具体如何配置不再赘述，可以参考下方链接</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://openclash.org/</span><br><span class="line">title: &quot;2025最新OpenWrt插件OpenClash使用教程配置从入门到精通&quot;</span><br><span class="line">description: &quot;2025最新OpenClash使用教程，OpenClash配置教程，最新OpenClash下载，服务器链接教程，OpenClash客户端使用技巧及配置技巧，OpenClash从入门到精通。&quot;</span><br><span class="line">host: openclash.org</span><br><span class="line">favicon: https://openclash.org/wp-content/uploads/2023/03/cropped-1677991847-favicon-32x32.png</span><br><span class="line">image: https://openclash.org/wp-content/uploads/2023/04/1680628090-OpenClash.jpg</span><br></pre></td></tr></table></figure></h2><p>接下来就是见证奇迹的时刻🌟</p><p><img src="docker_wheather_clash.png" alt=""></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>luci-theme-design (基于 luci-theme-neobird 二次开发) 是一个针对移动端和 PC 端的沉浸式 WebApp 体验和优化的 OpenWrt LuCI 主题。</p><p>下载 <a href="https://github.com/0x676e67/luci-app-design-config/releases">Design 主题配置文件</a>，将其安装在 openwrt 即可，具体流程如下</p><p><img src="luci-theme-design.png" alt=""><br>下载 <code>luci-app-design-config_1.3-20230306_all.ipk</code>，并将其上传，安装<br><img src="theme_design_upload_install.png" alt=""></p><p>安装好之后进行刷新，就会发现下方”导航栏”的第二个变成了猫猫图标<br><img src="design_set.png" alt=""></p><p>可在右侧”系统-&gt;Design 主题设置”进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若无法安装，可以先卸载再重安装</span><br><span class="line">1. 列出已安装的软件包： </span><br><span class="line">   opkg list_installed</span><br><span class="line">2. 找到OpenClash的具体名称： </span><br><span class="line">   opkg list_installed | grep openclash</span><br><span class="line">3. 卸载 OpenClash： </span><br><span class="line">   opkg remove luci-app-openclash</span><br></pre></td></tr></table></figure><hr><hr><p>不小心把 nginx 关了…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://www.echo.cool/docs/middleware/nginx/nginx-basics/nginx-basic-commands/</span><br><span class="line">title: &quot;Nginx 基本命令 | 代码酷&quot;</span><br><span class="line">description: &quot;学习Nginx的基本命令，掌握如何启动、停止、重启和检查Nginx服务的状态。&quot;</span><br><span class="line">host: www.echo.cool</span><br><span class="line">favicon: https://www.echo.cool/img/favicon.ico</span><br><span class="line">image: https://www.echo.cool/img/logo.png</span><br></pre></td></tr></table></figure><hr><p><img src="Pasted%20image%2020250819220807.png" alt=""></p><p><img src="Pasted%20image%2020250819201315.png" alt=""></p><p><a href="https://zhuanlan.zhihu.com/p/713193460">Fetching Data#jwff</a></p><p><a href="https://zhuanlan.zhihu.com/p/713193460">https://zhuanlan.zhihu.com/p/713193460</a></p><p><img src="Pasted%20image%2020250822165156.png" alt=""></p><p>发行包软件源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/gz openwrt_base http://mirrors.pku.edu.cn/immortalwrt/releases/21.02.1/packages/aarch64_cortex-a53/base/</span><br><span class="line">src/gz openwrt_luci http://mirrors.pku.edu.cn/immortalwrt/releases/packages-18.06-k5.4/aarch64_cortex-a53/luci</span><br><span class="line">src/gz openwrt_packages http://mirrors.pku.edu.cn/immortalwrt/releases/21.02.1/packages/aarch64_cortex-a53/packages</span><br><span class="line">src/gz openwrt_routing http://mirrors.pku.edu.cn/immortalwrt/releases/21.02.1/packages/aarch64_cortex-a53/routing</span><br><span class="line">src/gz openwrt_telephony http://mirrors.pku.edu.cn/immortalwrt/releases/21.02.1/packages/aarch64_cortex-a53/telephony</span><br></pre></td></tr></table></figure><p><img src="Pasted%20image%2020250822171504.png" alt=""></p><p>ping istore. linkease. com</p>]]></content>
      
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宿舍改造</title>
      <link href="/post/50636d10.html"/>
      <url>/post/50636d10.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最开始没记录制作过程，懒得再写一遍，就拿来参赛的模板套了一下：</p></blockquote><h1 id="一、选题说明"><a href="#一、选题说明" class="headerlink" title="一、选题说明"></a>一、选题说明</h1><p>在数字化浪潮的推动下，传统宿舍已难以满足现代学生对智能化、安全性与便捷性的需求。DormGuard项目以“智慧宿舍”为核心载体，依托ESP32芯片，打造一套集环境感知、语音控制、身份识别、远程联动于一体的全栈式智能生活系统，致力于将“被动空间”转化为“主动服务空间”。</p><h1 id="二、方案描述"><a href="#二、方案描述" class="headerlink" title="二、方案描述"></a>二、方案描述</h1><h2 id="1-架构设计：双核智慧·多维感知"><a href="#1-架构设计：双核智慧·多维感知" class="headerlink" title="1. 架构设计：双核智慧·多维感知"></a>1. 架构设计：双核智慧·多维感知</h2><h3 id="1-1-中央控制核心："><a href="#1-1-中央控制核心：" class="headerlink" title="1.1 中央控制核心："></a>1.1 中央控制核心：</h3><p>• 系统采用双主控架构：门禁单元使用ESP32模组，懒人开关主控升级为NeoSwitch Node（基于ESP32-C3）。<br>• 电源模块实现三级电压转换（12V→5V→3.3V），并集成电池反接保护与电压检测反馈机制（低电压提醒≤3.6V）。</p><h3 id="1-2-核心感知模块："><a href="#1-2-核心感知模块：" class="headerlink" title="1.2 核心感知模块："></a>1.2 核心感知模块：</h3><p>• BioRadar-X（LD2410B 毫米波雷达）：支持动态人体感知，接入HomeAssistant平台，触发个性化场景联动。<br>• SmartTouch Pad（薄膜键盘+OLED显示）：集成密码输入与状态反馈，界面直观，适应夜间使用。<br>• NFC Gatekeeper（RC522 模块）：支持多种NFC设备（校园卡、手机、智能戒指）身份识别，提升开锁便捷性与安全性。<br>• ClimaSense DHT-X（DHT22）：精准捕捉宿舍温湿度，辅助空调智能调控。<br>• 语控模块 HLK-V20（VoiceCore Lite）：离线语音助手，支持定时控制、语义识别与多语言命令解析。</p><h3 id="1-3-执行模块："><a href="#1-3-执行模块：" class="headerlink" title="1.3 执行模块："></a>1.3 执行模块：</h3><p>• SecureMotor（12V减速电机）：执行电动开门任务，响应迅速，运行稳定。<br>• LuminoServo（SG90小舵机）：用于宿舍照明控制。<br>• AirLink红外发射器：兼容红外空调设备指令，完成传统家电智能化升级。</p><h2 id="2-软件系统：边缘智能·云端协同"><a href="#2-软件系统：边缘智能·云端协同" class="headerlink" title="2. 软件系统：边缘智能·云端协同"></a>2. 软件系统：边缘智能·云端协同</h2><p>• 核心控制平台基于树莓派4B + HomeAssistant，构建本地物联网中心，管理所有设备状态与策略逻辑。<br>• 公网访问通过云服务器内网穿透服务实现远程控制与状态同步，支持移动端Web与APP交互。<br>• 主控单元之间使用MQTT低延迟通信协议，延迟小于100ms，保证快速响应指令。</p><h1 id="三、创新亮点与优势"><a href="#三、创新亮点与优势" class="headerlink" title="三、创新亮点与优势"></a>三、创新亮点与优势</h1><h2 id="1-硬件侧亮点"><a href="#1-硬件侧亮点" class="headerlink" title="1.硬件侧亮点"></a>1.硬件侧亮点</h2><p>  • 多模块集成且结构清晰，便于部署与维护。<br>  • 电源模块设计引入工业级防护思路，系统更稳定。<br>  • 实现“门锁+环境+交互”一体化设计，功能密度高。</p><h2 id="2-软件侧亮点"><a href="#2-软件侧亮点" class="headerlink" title="2. 软件侧亮点"></a>2. 软件侧亮点</h2><p>  • 局域网MQTT支持本地场景响应，即使断网也能稳定运行。<br>  • 云端托管方案便于跨地域管理，用户可随时监测与控制宿舍状态。<br>  • 预留可扩展接口，支持未来接入摄像头、烟雾报警器等安全设备。</p><h2 id="3-用户体验亮点"><a href="#3-用户体验亮点" class="headerlink" title="3. 用户体验亮点"></a>3. 用户体验亮点</h2><p>  • 多种开锁方式（语音、NFC、密码）适配不同用户偏好。<br>  • 宿舍状态自动调节（如空调自动启停）节能环保。<br>  • 语音助手支持离线指令，保障隐私与响应速度。</p><h1 id="四、成果展示"><a href="#四、成果展示" class="headerlink" title="四、成果展示"></a>四、成果展示</h1><h2 id="1-可视化建模"><a href="#1-可视化建模" class="headerlink" title="1. 可视化建模"></a>1. 可视化建模</h2><p>• 使用SolidWorks完成3D建模，清晰展现门禁模块、懒人开关、传感器排布与布线方式。（具体见<sup><a href="#fn_附录1" id="reffn_附录1">附录1</a></sup>）</p><h2 id="2-电路仿真分析"><a href="#2-电路仿真分析" class="headerlink" title="2. 电路仿真分析"></a>2. 电路仿真分析</h2><p>• 基于Multisim完成电源反接场景仿真：正常接、单电池反接、双电池正负混接等，确保硬件容错能力。（具体见<sup><a href="#fn_附录2" id="reffn_附录2">附录2</a></sup>）</p><h2 id="3-实体演示"><a href="#3-实体演示" class="headerlink" title="3. 实体演示"></a>3. 实体演示</h2><p>• 项目已制作实体原型，包含完整交互体验，配套演示视频可直观展现开门响应、环境联动、语音控制全过程。（具体见<sup><a href="#fn_视频文件" id="reffn_视频文件">视频文件</a></sup>）</p><blockquote id="fn_附录1"><sup>附录1</sup>. <img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/%E9%97%A8%E7%A6%81%E4%B8%BB%E6%8E%A7.png" alt="门上主控"> <img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/%E6%87%92%E4%BA%BA%E5%BC%80%E7%81%AF.png" alt="懒人开关"> <img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98.png" alt="矩阵键盘"><a href="#reffn_附录1" title="Jump back to footnote [附录1] in the text."> &#8617;</a></blockquote><blockquote id="fn_附录2"><sup>附录2</sup>. <img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/multisim/%E6%AD%A3%E5%B8%B8%E6%8E%A5.png" alt="正常接"><img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/multisim/%E5%8D%95%E7%94%B5%E6%B1%A0%E5%8F%8D%E6%8E%A5.png" alt="单电池反接"><img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/multisim/%E5%B9%B6%E8%81%94%E7%94%B5%E6%B1%A0%E9%98%B2%E5%8F%8D%E6%8E%A5.png" alt="双电池正负混接"><img src="https://youpai.hanvon.top/homeassistant/A520/peripheral/multisim/%E4%B8%80%E6%AD%A3%E4%B8%80%E5%8F%8D%E6%8E%A5.png" alt="单电池反接"><a href="#reffn_附录2" title="Jump back to footnote [附录2] in the text."> &#8617;</a></blockquote><blockquote id="fn_视频文件"><sup>视频文件</sup>. <iframe src="https://youpai.hanvon.top/homeassistant/A520/peripheral/%E5%AE%9E%E7%89%A9%E6%BC%94%E7%A4%BA.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="800" height="500" style="box-sizing: border-box; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: rgb(59 130 246 / 0.5); --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; margin: 0px 0px 20px; color: rgb(76, 73, 72); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Helvetica Neue&quot;, Lato, Roboto, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><a href="#reffn_视频文件" title="Jump back to footnote [视频文件] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>炸机日记</title>
      <link href="/post/c5e86bf1.html"/>
      <url>/post/c5e86bf1.html</url>
      
        <content type="html"><![CDATA[<p>2025年2月24日 17点30分 我们五个开开心心飞飞机，结果整了半天，一片桨叶都没转起来，更别提采集数据了<br><img src="https://youpai.hanvon.top/blog/Mine/Daily/Master/day-to-day/some%20else/just_think.jpg" alt="spider man"></p><p>这个大家伙是在某宝店铺<code>YH远航科技模型</code>买的 于是乎来来回回折腾了好多天<br>又是调参，又是买飞控充电器的连接器，又是买遥控器电池充电器…</p><p><a href="https://www.dji.com/cn/downloads/products/naza-m-v2#tuning_params">下载调参软件</a><br><img src="https://youpai.hanvon.top/blog/Mine/Daily/Master/day-to-day/some%20else/Naza-M_V2.png" alt=""></p><p><img src="https://youpai.hanvon.top/blog/Mine/Daily/Master/day-to-day/some%20else/Naza-M_V2_ui.png" alt=""></p><p>①命令杆(油门 姿态)校准微调<br>②控制模式切换的校准<br>③基础校准后，进行指南针操作</p><p>终于！我们在3月6日，也就是我们五个一起测脚的那个下午，大家伙飞起来了！如下图:</p><p><img src="https://youpai.hanvon.top/blog/Mine/Daily/Master/day-to-day/some%20else/flying.png" alt=""></p><p>Happy Ending</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>组合导航学习</title>
      <link href="/post/7ead290e.html"/>
      <url>/post/7ead290e.html</url>
      
        <content type="html"><![CDATA[<p>先随便记点</p><h2 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h2><p>捷联惯性导航系统 (Strapdown Inertial Navigation System, SINS)<br>全球导航卫星系统 (Global Navigation Satellite  Systems, GNSS)<br>航姿系统(Attitude Heading Reference System, AHRS)<br>全球定位系统  (Global Positioning System, GPS)<br>地形匹配导航 (Terrain  Aided Navigation, TAN)<br>多普勒测速仪 (Doppler Velocity Log, DVL)<br>磁罗盘 (Magnetic Compass Pilot, MCP)<br>超短基线 (Ultra-Short Base Line, USBL)<br>长基线 (Long Base Line, LBL)<br>深度计(Depthometer, DM)</p><h2 id="载体"><a href="#载体" class="headerlink" title="载体"></a>载体</h2><p>自主水下航行器 (Autonomous Underwater Vehicle, AUV)</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>航位推算 (Dead  Reckoning, DR)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>艾顽石的阿拉蕾</title>
      <link href="/post/e0c82c88.html"/>
      <url>/post/e0c82c88.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4b91d39451dc7dcbd055402aa22d6fbfee0257b9d85f2f3b7ea3bf0a04011b52">463ed768074be97eb770fb9115c78d36ea216ae80a5e81e90519cac327d3d2b19165a55ed71da983059ab430b2b682ab1d3e99a1d4280a3ac5515e38894bb435dadd7bdf9c0d55900be27451d26215b3dd6de2888f0a442eab3ddde1930389d39e0b4a46155a3da236f1bfc30c27c1d561e7d9f8af52264171c6a6e80741b920a1058a03da4c344a80826571042ad7388df61406b8efbecea761b9a58f0b78a822563753fa8bbb8e2d4fd680d295fbae308c95c66ba24eddb676d2dc6d5a71f01e6358f10324ef78d642f99e2ed66e5b46df7244bbe4fd719505dd06fe3ad55448a83cf33e329686195ecbbea259f94743cdd5d5852aade8ed74676f24f7d82951469c22c6744eb896f053e272552ecee67897493ba9d5ba59ef898587924d7c7cc804e3b5e832a4006132f0a03b2eae49d7a0064c847687468628a347afb4a7ff0c07515fd36065a88cee8ebc6e6f7697b2721bdf31861b3f71df2436f00cc3b70c4be5f23455d1e3544064dba1990602d96bbf46aa85e2e1e80c9d2f93a19ec39746a88364cd1188b6c24c1497c061cfbde3f21e0b7911938a3febec8021dc77a42e8c3a85ea0ca1dc4bb32298ded0e7ed0885b592598c4dd523c91c552e7ccda71628a7507c254613afcca342098d80fa2c33acf4b4a6ca0414957937c1244339e8c367c169f2075cd780e6ddb1126d3a6936c1881062d40f259b082af58fff65239f581e42d2e165458b182da2ec5ad5634ab5bf65006519b98f7b138eeaa88122c060dc0a0e2d2b92226edadba073a724b99fd2210e3a773a04091562b10e03d51fa4f75ced6b7a8a111b99ec46d86f3ac8c260174835d02572107200bede9ca1f3f7d7d85cd82ab2f1905affe564f69b903feae8cf3709ea10cbf3d0e761a3ee1fcc4b0c8b8a463c2d1405504a86e4727104098cf19c49c46f20384b41</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">如果你知道我们是哪一天在一起的</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EKF Vs. FGO</title>
      <link href="/post/5b8c8a6e.html"/>
      <url>/post/5b8c8a6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="EKF-与-因子图-核心概念一一对应表"><a href="#EKF-与-因子图-核心概念一一对应表" class="headerlink" title="EKF 与 因子图 核心概念一一对应表"></a>EKF 与 因子图 核心概念一一对应表</h1><div class="table-container"><table><thead><tr><th><strong>EKF 概念</strong></th><th><strong>因子图中的对应概念</strong></th><th><strong>详细解释</strong></th></tr></thead><tbody><tr><td><strong>状态变量 $\mathbf{x}_k$</strong></td><td>图中的<strong>节点</strong>（变量节点 $x_k$）</td><td>节点表示系统在时刻 $k$ 的状态。两者一一对应。</td></tr><tr><td><strong>预测模型 $f(x_{k-1}, u_k)$</strong></td><td><strong>运动因子（Motion Factor）</strong></td><td>用于连接 $x_{k-1} \rightarrow x_k$ 的边，残差为 $r_f = x_k - f(x_{k-1}, u_k)$</td></tr><tr><td><strong>观测模型 $h(x_k)$</strong></td><td><strong>观测因子（Measurement Factor）</strong></td><td>残差为 $r_h = z_k - h(x_k)$，表示观测与预测的差距</td></tr><tr><td><strong>过程噪声协方差 $\mathbf{Q}_k$</strong></td><td><strong>运动因子的协方差 $\Sigma_f$</strong></td><td>用来加权运动因子的误差大小（“惩罚”大误差）</td></tr><tr><td><strong>观测噪声协方差 $\mathbf{R}_k$</strong></td><td><strong>观测因子的协方差 $\Sigma_h$</strong></td><td>用来加权观测因子的误差大小</td></tr><tr><td><strong>协方差传播</strong></td><td><strong>信息融合内隐在因子之间的残差结构中</strong></td><td>因子图不显式传播协方差，而是通过联合优化自动融合多步误差信息</td></tr><tr><td><strong>卡尔曼增益 $K_k$</strong></td><td><strong>隐含在优化中协方差加权的最小二乘解结构中</strong></td><td>因子图没有明确的“增益”，但它通过残差加权自动得出最优融合值</td></tr><tr><td><strong>状态更新公式</strong></td><td><strong>全局最小化残差平方和：MAP 估计</strong></td><td>状态是优化变量，不是逐步更新；一次性联合优化获得所有状态变量的最优值</td></tr><tr><td><strong>初始状态分布（先验）</strong></td><td><strong>先验因子（Prior Factor）</strong></td><td>对初始状态添加高斯分布先验，例如 $x_0 \sim \mathcal{N}(\mu_0, P_0)$</td></tr><tr><td><strong>残差（如 $z_k - h(x_k)$）</strong></td><td><strong>每个因子的误差函数（Residual function）</strong></td><td>用于构建代价函数，衡量模型预测与实际之间的误差</td></tr><tr><td><strong>误差协方差加权项 $\Sigma^{-1}$</strong></td><td><strong>误差惩罚（loss penalty），残差的权重项</strong></td><td>在优化目标函数中体现为：$\Vert r \Vert^2_{\Sigma^{-1}} = r^\top \Sigma^{-1} r$</td></tr><tr><td><strong>状态估计不确定性 $\mathbf{P}_k$</strong></td><td><strong>优化后可由海森矩阵近似协方差（$P \approx (H^\top \Sigma^{-1} H)^{-1}$）</strong></td><td>因子图本身不显示协方差传播，但可由线性化后提取</td></tr><tr><td><strong>递归更新过程</strong></td><td><strong>增量优化（iSAM）或批量优化（Batch MAP）</strong></td><td>因子图可以递归优化，也可以批量优化，更灵活</td></tr></tbody></table></div><hr><h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h1><p>那么，状态估计模型如何从 EKF 转为因子图呢？举个栗子：<br>假设我们有以下系统：</p><ul><li>状态：位置+速度 $x_k = [p_k, v_k]^\top$</li><li>控制输入：加速度 $a_k$</li><li>测量：位置观测 $z_k = p_k + \text{noise}$</li></ul><h2 id="▶-EKF-中的模型："><a href="#▶-EKF-中的模型：" class="headerlink" title="▶ EKF 中的模型："></a>▶ EKF 中的模型：</h2><ul><li>状态转移：$\hat{x}_k = f(x_{k-1}, a_k) = \begin{bmatrix} p_{k-1} + v_{k-1} \Delta t + 0.5 a_k \Delta t^2 \ v_{k-1} + a_k \Delta t \end{bmatrix}$</li><li>状态协方差预测：$P_k^- = F P_{k-1} F^\top + Q$</li><li>观测模型：$z_k = H x_k + \eta_k$，其中 $H = [1, 0]$</li></ul><hr><h2 id="▶-因子图表示（统一为最小化目标）："><a href="#▶-因子图表示（统一为最小化目标）：" class="headerlink" title="▶ 因子图表示（统一为最小化目标）："></a>▶ 因子图表示（统一为最小化目标）：</h2><h3 id="状态变量："><a href="#状态变量：" class="headerlink" title="状态变量："></a>状态变量：</h3><ul><li>节点变量：$x_0, x_1, x_2, \dots$</li></ul><h3 id="1-初始先验因子（Prior-Factor）："><a href="#1-初始先验因子（Prior-Factor）：" class="headerlink" title="1. 初始先验因子（Prior Factor）："></a>1. 初始先验因子（Prior Factor）：</h3><p>$\text{残差： } r_0 = x_0 - \mu_0,\quad \Sigma_0 = P_0$</p><p>惩罚项为：$r_0^\top \Sigma_0^{-1} r_0$</p><h3 id="2-运动因子（IMU-因子）："><a href="#2-运动因子（IMU-因子）：" class="headerlink" title="2. 运动因子（IMU 因子）："></a>2. 运动因子（IMU 因子）：</h3><p>$r_{k}^{\text{motion}} = x_k - f(x_{k-1}, a_{k-1})$<br>$\text{惩罚项： } r_{\text{motion}}^\top Q^{-1} r_{\text{motion}}$</p><h3 id="3-观测因子："><a href="#3-观测因子：" class="headerlink" title="3. 观测因子："></a>3. 观测因子：</h3><p>$kr_k^{\text{obs}} = z_k - h(x_k) = z_k - H x_k$</p><p>惩罚项为：</p><p>R−1 $robsr_{\text{obs}}^\top R^{-1} r_{\text{obs}}$</p><hr><h3 id="▶-最终目标函数（因子图）："><a href="#▶-最终目标函数（因子图）：" class="headerlink" title="▶ 最终目标函数（因子图）："></a>▶ 最终目标函数（因子图）：</h3><p>整体优化目标为最小化所有残差平方和：</p><p>$\min_{x_0, x_1, \dots, x_N} \left[ \underbrace{(x_0 - \mu_0)^\top P_0^{-1} (x_0 - \mu_0)}_{\text{先验因子}} + \sum_{k=1}^{N} \underbrace{(x_k - f(x_{k-1}, a_{k-1}))^\top Q^{-1} (x_k - f(x_{k-1}, a_{k-1}))}_{\text{运动因子}} + \sum_{k=1}^{N} \underbrace{(z_k - H x_k)^\top R^{-1} (z_k - H x_k)}_{\text{观测因子}} \right]$</p><hr><h1 id="✅-总结思维图：EKF-vs-因子图-✅"><a href="#✅-总结思维图：EKF-vs-因子图-✅" class="headerlink" title="✅ 总结思维图：EKF vs 因子图 ✅"></a>✅ 总结思维图：EKF vs 因子图 ✅</h1><div class="table-container"><table><thead><tr><th>EKF</th><th>因子图</th></tr></thead><tbody><tr><td>状态变量 x_k</td><td>变量节点 x_k</td></tr><tr><td>预测函数 f(x,u)</td><td>运动因子（残差函数）</td></tr><tr><td>观测函数 h(x)</td><td>观测因子（残差函数）</td></tr><tr><td>协方差矩阵 P_k</td><td>Hessian 的近似逆</td></tr><tr><td>过程噪声 Q</td><td>运动因子的协方差</td></tr><tr><td>观测噪声 R</td><td>观测因子的协方差</td></tr><tr><td>协方差传播</td><td>多因子耦合优化，自然传播</td></tr><tr><td>卡尔曼增益 K</td><td>解优化问题后的隐含加权融合</td></tr><tr><td>状态更新</td><td>一次性求解最小残差路径（MAP估计）</td></tr></tbody></table></div><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><hr><h1 id="EKF-与因子图的各要素映射（数值方法-概率建模角度）"><a href="#EKF-与因子图的各要素映射（数值方法-概率建模角度）" class="headerlink" title="EKF 与因子图的各要素映射（数值方法 + 概率建模角度）"></a>EKF 与因子图的各要素映射（数值方法 + 概率建模角度）</h1><hr><h2 id="1-状态变量（State-Variable）"><a href="#1-状态变量（State-Variable）" class="headerlink" title="1. 状态变量（State Variable）"></a>1. <strong>状态变量（State Variable）</strong></h2><div class="table-container"><table><thead><tr><th>EKF</th><th>因子图</th><th>说明</th></tr></thead><tbody><tr><td>状态向量 $\mathbf{x}_k$</td><td>隐变量节点 $x_k$</td><td>表示系统在时刻 $k$ 的状态，例如位置、速度、姿态等。EKF 是时间步递推估计，因子图则将所有时刻的状态显式建图，一次联合优化。</td></tr></tbody></table></div><hr><h2 id="2-初始先验（Initial-Prior）"><a href="#2-初始先验（Initial-Prior）" class="headerlink" title="2. 初始先验（Initial Prior）"></a>2. <strong>初始先验（Initial Prior）</strong></h2><div class="table-container"><table><thead><tr><th>EKF</th><th>因子图</th><th>说明</th></tr></thead><tbody><tr><td>初始估计：$\mathbf{x}_0 \sim \mathcal{N}(\mu_0, \Sigma_0)$</td><td>先验因子：$\phi_0(x_0) \propto \exp\left( -\frac{1}{2}(x_0 - \mu_0)^T \Sigma_0^{-1} (x_0 - \mu_0) \right)$</td><td>EKF 使用均值+协方差初始化，因子图通过先验因子显式表达初始置信度。两者在概率意义下等价。</td></tr></tbody></table></div><hr><h2 id="3-预测模型（Motion-Model）"><a href="#3-预测模型（Motion-Model）" class="headerlink" title="3. 预测模型（Motion Model）"></a>3. <strong>预测模型（Motion Model）</strong></h2><div class="table-container"><table><thead><tr><th>EKF</th><th>因子图</th><th>说明</th></tr></thead><tbody><tr><td>状态转移：$\mathbf{x}_k = f(\mathbf{x}_{k-1}, \mathbf{u}_k) + \mathbf{w}_k$，$\mathbf{w}_k \sim \mathcal{N}(0, Q_k)$</td><td>运动因子：$\phi_k(x_{k-1}, x_k) \propto \exp\left( -\frac{1}{2} \vert x_k - f(x_{k-1}, u_k) \vert^2_{Q_k^{-1}} \right)$</td><td>EKF 的系统模型通过 $f$ 递推，误差协方差为 $Q_k$；因子图中残差即预测误差，协方差控制惩罚强度。</td></tr></tbody></table></div><hr><h2 id="4-观测模型（Measurement-Model）"><a href="#4-观测模型（Measurement-Model）" class="headerlink" title="4. 观测模型（Measurement Model）"></a>4. <strong>观测模型（Measurement Model）</strong></h2><div class="table-container"><table><thead><tr><th>EKF</th><th>因子图</th><th>说明</th></tr></thead><tbody><tr><td>观测方程：$\mathbf{z}_k = h(\mathbf{x}_k) + \mathbf{v}_k$，$\mathbf{v}_k \sim \mathcal{N}(0, R_k)$</td><td>观测因子：$\phi_k^{(z)}(x_k) \propto \exp\left( -\frac{1}{2} \vert z_k - h(x_k) \vert^2_{R_k^{-1}} \right)$</td><td>EKF 每一步用观测修正状态，因子图中用观测因子连接 $x_k$，惩罚观测误差。</td></tr></tbody></table></div><hr><h2 id="5-协方差传播与增益（Covariance-Propagation-amp-Kalman-Gain）"><a href="#5-协方差传播与增益（Covariance-Propagation-amp-Kalman-Gain）" class="headerlink" title="5. 协方差传播与增益（Covariance Propagation &amp; Kalman Gain）"></a>5. <strong>协方差传播与增益（Covariance Propagation &amp; Kalman Gain）</strong></h2><div class="table-container"><table><thead><tr><th style="text-align:left">\</th><th>EKF 思路</th><th>因子图思路</th></tr></thead><tbody><tr><td style="text-align:left">协方差传播</td><td>显式传播 $\mathbf{P}$，用于后续加权</td><td>隐式表达为残差加权项 $\Sigma^{-1}$，内嵌于优化结构</td></tr><tr><td style="text-align:left">状态更新</td><td>当前时刻预测值加增益修正</td><td>所有时刻状态同时优化，统一处理全部信息</td></tr><tr><td style="text-align:left">信息融合</td><td>卡尔曼增益调节观测 vs 预测的比重</td><td>残差协方差控制“置信程度”，优化中自适应融合</td></tr></tbody></table></div><p>在 EKF 中，这部分的核心任务是<strong>在预测阶段传播不确定性</strong>，并在观测到来时<strong>利用协方差矩阵自适应地加权观测和预测信息</strong>。</p><p>🔹EKF 中的做法如下：</p><ol><li><p><strong>协方差预测（时间更新）</strong><br> 当状态从 $\mathbf{x}_{k-1}$ 预测到 $\mathbf{x}_k$ 时，状态协方差 $\mathbf{P}$ 随之传播：</p><p>$\mathbf{P}_{k|k-1} = F_k \mathbf{P}_{k-1|k-1} F_k^\top + Q_k$</p><p>其中 $F_k$ 是状态转移函数 $f$ 关于 $x$ 的雅可比矩阵，$Q_k$ 是过程噪声协方差。</p></li><li><p><strong>计算卡尔曼增益（信息融合权重）</strong><br> 利用预测协方差与观测噪声，计算最优融合权重：</p><p>$\mathbf{K}_k = \mathbf{P}_{k|k-1} H_k^\top (H_k \mathbf{P}_{k|k-1} H_k^\top + R_k)^{-1}$</p><p>其中 $H_k$ 是观测函数 $h$ 关于 $x$ 的雅可比，$R_k$ 是观测噪声协方差。</p></li></ol><p>🔹因子图中的对应思想：</p><p>因子图不显式传播协方差矩阵，但它通过<strong>构建带协方差权重的残差因子</strong>，将预测与观测误差统一编码在优化问题中。</p><p>具体来说，因子图构建了如下优化目标：</p><p>$\min_{x_{0:k}} \sum \left| \underbrace{r_i(x)}_{\text{残差}} \right|^2_{\Sigma_i^{-1}} = \sum r_i^\top \Sigma_i^{-1} r_i$</p><p>其中：</p><ul><li>$\Sigma_i^{-1}$ 表示对应误差项的<strong>加权矩阵（即协方差的逆）</strong>；</li><li>对于预测项，其残差 $r^{\text{pred}} = x_k - f(x_{k-1}, u_k)$，权重为 $Q_k^{-1}$；</li><li>对于观测项，其残差 $r^{\text{obs}} = z_k - h(x_k)$，权重为 $R_k^{-1}$。</li></ul><p><strong>这就相当于在“增益加权”的层面上</strong>，将 EKF 的卡尔曼增益逻辑，转化为残差惩罚中的加权策略。在非线性优化中，这种残差的协方差加权正是影响变量更新方向和幅度的关键，相当于自动调节“相信先验”还是“相信观测”。</p><hr><h2 id="6-状态更新（State-Update）"><a href="#6-状态更新（State-Update）" class="headerlink" title="6. 状态更新（State Update）"></a>6. <strong>状态更新（State Update）</strong></h2><p>🔶EKF 中的状态更新是通过<strong>一次卡尔曼增益加权修正</strong>完成的：</p><p>$\mathbf{x}_{k|k} = \mathbf{x}_{k|k-1} + \mathbf{K}_k \left( \mathbf{z}_k - h(\mathbf{x}_{k|k-1}) \right)$</p><p>这个公式的本质是：<strong>预测值 + 增益 × 残差</strong>，即根据观测与预测之间的差距，对预测状态进行加权修正。</p><hr><p>🔶因子图没有显式的“预测 + 更新”过程，而是：</p><ul><li>将所有状态变量 $x_0, x_1, …, x_k$ 一起建模；</li><li>所有的运动模型、观测模型都转化为误差残差项；</li><li>最后通过<strong>非线性最小二乘优化（如高斯牛顿或 LM 算法）</strong>，求解一组最优状态变量，使所有残差总和最小。</li></ul><p>即：$\hat{x}_{0:k} = \arg\min \sum_i | r_i(x) |^2_{\Sigma_i^{-1}}$</p><p>这相当于一次性求解一个全局最优状态估计，而不是逐步迭代更新。</p><hr><h2 id="7-批量-vs-滑动窗口（时序结构）"><a href="#7-批量-vs-滑动窗口（时序结构）" class="headerlink" title="7. 批量 vs 滑动窗口（时序结构）"></a>7. <strong>批量 vs 滑动窗口（时序结构）</strong></h2><div class="table-container"><table><thead><tr><th>EKF</th><th>因子图</th><th>说明</th></tr></thead><tbody><tr><td>递推更新（只保留当前状态）</td><td>批量建图，优化全序列状态</td><td>EKF 无法处理回环等历史依赖场景；因子图可以全局建图（如 SLAM），也可局部滑窗（iSAM）。</td></tr><tr><td>仅当前 $\mathbf{x}_k$ 更新</td><td>所有 $x_0, x_1, …, x_k$ 可更新</td><td>因子图支持调整整个轨迹的估计，保持全局一致性，EKF 则仅当前最优。</td></tr></tbody></table></div><hr><h2 id="8-概率建模视角"><a href="#8-概率建模视角" class="headerlink" title="8. 概率建模视角"></a>8. <strong>概率建模视角</strong></h2><h3 id="EKF-目标："><a href="#EKF-目标：" class="headerlink" title="EKF 目标："></a>EKF 目标：</h3><p>$\text{递推估计 } p(x_k | z_{1:k}, u_{1:k}) \approx \mathcal{N}(\hat{x}_k, P_k)$</p><p>即对当前状态的后验进行高斯近似。</p><hr><h3 id="因子图目标（最大后验估计）："><a href="#因子图目标（最大后验估计）：" class="headerlink" title="因子图目标（最大后验估计）："></a>因子图目标（最大后验估计）：</h3><p>$\hat{x}_{0:k} = \arg\max_{x_{0:k}} p(x_{0:k} | z_{1:k}, u_{1:k}) = \arg\max_{x_{0:k}} \prod_i \phi_i(x_{\mathcal{S}_i})$</p><p>其中每个 $\phi_i$ 是一个因子（残差项），对应不同的信息来源（先验、运动模型、观测模型）。</p><p>优化形式为：</p><p>$\min_{x_{0:k}} \sum_i \underbrace{| r_i |^2_{\Sigma_i^{-1}}}_{\text{惩罚项（误差加权）}}$</p><hr><h2 id="✅-总结对照表"><a href="#✅-总结对照表" class="headerlink" title="✅ 总结对照表"></a>✅ 总结对照表</h2><div class="table-container"><table><thead><tr><th><strong>概念</strong></th><th><strong>EKF 表达</strong></th><th><strong>因子图表达</strong></th></tr></thead><tbody><tr><td>状态变量</td><td>$\mathbf{x}_k$</td><td>隐变量 $x_k$</td></tr><tr><td>初始先验</td><td>$\mathcal{N}(\mu_0, \Sigma_0)$</td><td>先验因子 $\phi(x_0)$</td></tr><tr><td>状态转移模型</td><td>$x_k = f(x_{k-1}, u_k) + w_k$</td><td>运动因子 $\phi(x_{k-1}, x_k)$</td></tr><tr><td>观测模型</td><td>$z_k = h(x_k) + v_k$</td><td>观测因子 $\phi(x_k, z_k)$</td></tr><tr><td>过程噪声</td><td>$Q_k$</td><td>惩罚项 $\vert x_k - f(x_{k-1}) \vert^2_{Q_k^{-1}}$</td></tr><tr><td>观测噪声</td><td>$R_k$</td><td>惩罚项 $\vert z_k - h(x_k) \vert^2_{R_k^{-1}}$</td></tr><tr><td>协方差传播</td><td>$P_k = F P_{k-1} F^\top + Q$</td><td>通过图结构自然融合（Hessian矩阵近似协方差）</td></tr><tr><td>状态更新</td><td>预测 + 增益修正</td><td>全局优化状态节点</td></tr><tr><td>卡尔曼增益</td><td>$K_k$</td><td>优化中残差加权项（协方差逆）</td></tr><tr><td>残差惩罚项</td><td>$\mathbf{K}_k (\mathbf{z}_k - h(\hat{x}_k))$</td><td>$r^\top \Sigma^{-1} r$</td></tr><tr><td>滑动窗口结构</td><td>单状态存储、不能回溯</td><td>支持全图优化、滑窗优化、回环重定位</td></tr></tbody></table></div><hr><h1 id="举个粒子"><a href="#举个粒子" class="headerlink" title="举个粒子"></a>举个粒子</h1><h2 id="粒子①"><a href="#粒子①" class="headerlink" title="粒子①"></a>粒子①</h2><p>下面通过一个<strong>简洁明了的 1 维轨迹估计问题</strong>，手把手的演示如何从 EKF 的形式出发，构造出因子图结构，写出残差函数和优化目标函数，以及其物理意义。</p><hr><h1 id="小案例：一维轨迹估计-高斯观测-因子图建模"><a href="#小案例：一维轨迹估计-高斯观测-因子图建模" class="headerlink" title="小案例：一维轨迹估计 + 高斯观测 + 因子图建模"></a>小案例：一维轨迹估计 + 高斯观测 + 因子图建模</h1><h3 id="🎯-问题描述："><a href="#🎯-问题描述：" class="headerlink" title="🎯 问题描述："></a>🎯 问题描述：</h3><p>一辆车在直线轨道上运动，位置用标量 $x_k$ 表示。假设它以 <strong>恒定速度 $v$</strong> 向前运动，但受到过程噪声干扰。</p><p>我们有三个时间点的观测：</p><ul><li>状态变量：$x_0, x_1, x_2$</li><li>控制输入：恒定速度 $v = 1$</li><li>时间间隔: $\Delta t = 1$</li><li>测量值：$z_0 = 0.2, z_1 = 1.1, z_2 = 2.0$</li></ul><p>所有过程噪声 $\mathcal{N}(0, \sigma^2_Q)$，测量噪声 $\mathcal{N}(0, \sigma^2_R)$，其中：</p><ul><li>$\sigma_Q = 0.1$（过程不确定度小）</li><li>$\sigma_R = 0.5$（测量更不准）</li></ul><hr><h2 id="🔶-1-状态变量与图节点"><a href="#🔶-1-状态变量与图节点" class="headerlink" title="🔶 1. 状态变量与图节点"></a>🔶 1. 状态变量与图节点</h2><p>我们要估计的状态为：</p><p>$x_0,\ x_1,\ x_2$</p><p>图中，每个变量是一个节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x0 —— x1 —— x2</span><br><span class="line"> \     |     |</span><br><span class="line">  \    |     |</span><br><span class="line">   z0  z1    z2  （观测因子）</span><br></pre></td></tr></table></figure><hr><h2 id="🔶-2-构造因子图的因子项（残差项）"><a href="#🔶-2-构造因子图的因子项（残差项）" class="headerlink" title="🔶 2. 构造因子图的因子项（残差项）"></a>🔶 2. 构造因子图的因子项（残差项）</h2><h3 id="（1）先验因子：-x-0"><a href="#（1）先验因子：-x-0" class="headerlink" title="（1）先验因子：$x_0$"></a>（1）先验因子：$x_0$</h3><p>假设我们对起点有先验: $x_0 \sim \mathcal{N}(0, \sigma_0^2)$，设 $\sigma_0 = 0.2$</p><p>残差函数为：$r_0(x_0) = x_0 - 0,\quad \text{代价：} \frac{1}{\sigma_0^2} (x_0)^2$</p><hr><h3 id="（2）运动模型因子：-x-k-1-rightarrow-x-k"><a href="#（2）运动模型因子：-x-k-1-rightarrow-x-k" class="headerlink" title="（2）运动模型因子：$x_{k-1} \rightarrow x_k$"></a>（2）运动模型因子：$x_{k-1} \rightarrow x_k$</h3><p>因为速度恒定，状态转移模型为：$x_k = x_{k-1} + v \cdot \Delta t + w_k,\quad w_k \sim \mathcal{N}(0, \sigma_Q^2)$</p><p>残差函数为：$r_k^{\text{motion}} = x_k - (x_{k-1} + v)$</p><p>代价项为：$\frac{1}{\sigma_Q^2} \left( x_k - x_{k-1} - v \right)^2$</p><p>对于 $x_1$：$r_1^{\text{motion}} = x_1 - x_0 - 1$</p><p>对于 $x_2$：$r_2^{\text{motion}} = x_2 - x_1 - 1$</p><hr><h3 id="（3）观测因子：-z-k"><a href="#（3）观测因子：-z-k" class="headerlink" title="（3）观测因子：$z_k$"></a>（3）观测因子：$z_k$</h3><p>观测模型为：$z_k = x_k + v_k,\quad v_k \sim \mathcal{N}(0, \sigma_R^2)$</p><p>残差为：$r_k^{\text{obs}} = z_k - x_k,\quad \text{代价：} \frac{1}{\sigma_R^2} (z_k - x_k)^2$</p><p>即：</p><ul><li>$r_0^{\text{obs}} = 0.2 - x_0$</li><li>$r_1^{\text{obs}} = 1.1 - x_1$</li><li>$r_2^{\text{obs}} = 2.0 - x_2$</li></ul><hr><h2 id="🔶-3-构建总优化目标函数"><a href="#🔶-3-构建总优化目标函数" class="headerlink" title="🔶 3. 构建总优化目标函数"></a>🔶 3. 构建总优化目标函数</h2><p>总目标函数为残差平方和加权：</p><p>$J(x_0, x_1, x_2) =  \underbrace{\frac{1}{\sigma_0^2} (x_0)^2}_{\text{先验}} + \underbrace{\frac{1}{\sigma_Q^2} (x_1 - x_0 - 1)^2}_{\text{运动}} + \underbrace{\frac{1}{\sigma_Q^2} (x_2 - x_1 - 1)^2}_{\text{运动}} + \underbrace{\frac{1}{\sigma_R^2} (0.2 - x_0)^2}_{\text{观测}} + \underbrace{\frac{1}{\sigma_R^2} (1.1 - x_1)^2}_{\text{观测}} + \underbrace{\frac{1}{\sigma_R^2} (2.0 - x_2)^2}_{\text{观测}}$</p><hr><h2 id="🔶-4-求解（数值最小化）"><a href="#🔶-4-求解（数值最小化）" class="headerlink" title="🔶 4. 求解（数值最小化）"></a>🔶 4. 求解（数值最小化）</h2><p>这就是标准的非线性最小二乘问题，可以用高斯牛顿法或 LM 方法求解。优化变量为：</p><p>$\mathbf{x} = [x_0,\ x_1,\ x_2]^T$</p><p>也可以用 Python 中的 <code>scipy.optimize.least_squares</code> 或 MATLAB 的 <code>lsqnonlin</code> 直接优化。</p><hr><div class="table-container"><table><thead><tr><th>步骤</th><th>类型</th><th>残差函数 $r$</th><th>权重 $\Sigma^{-1}$</th></tr></thead><tbody><tr><td>1</td><td>先验因子</td><td>$x_0$</td><td>$1/\sigma_0^2$</td></tr><tr><td>2</td><td>运动因子</td><td>$x_k - x_{k-1} - v$</td><td>$1/\sigma_Q^2$</td></tr><tr><td>3</td><td>观测因子</td><td>$z_k - x_k$</td><td>$1/\sigma_R^2$</td></tr></tbody></table></div><p>最终通过联合优化这些残差，就能得到全局一致的状态估计yeah</p><h2 id="MATLAB-实现：EKF-与因子图对比"><a href="#MATLAB-实现：EKF-与因子图对比" class="headerlink" title="MATLAB 实现：EKF 与因子图对比"></a>MATLAB 实现：EKF 与因子图对比</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factor_graph_vs_ekf_1D</span><span class="params">()</span></span></span><br><span class="line">    clc; clear;close all;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 参数设置</span></span><br><span class="line">    v = <span class="number">1.0</span>; dt = <span class="number">1.0</span>;          <span class="comment">% 速度和时间间隔</span></span><br><span class="line">    sigma_0 = <span class="number">0.2</span>;              <span class="comment">% 初始状态不确定性(标准差)</span></span><br><span class="line">    sigma_Q = <span class="number">0.1</span>;              <span class="comment">% 过程噪声 std （运动模型的不确定性）</span></span><br><span class="line">    sigma_R = <span class="number">0.5</span>;              <span class="comment">% 观测噪声 std （量测误差）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 根据真值造量测（加噪）</span></span><br><span class="line">    <span class="built_in">true</span>_x = [<span class="number">0</span>; <span class="number">1</span>; <span class="number">2</span>];         <span class="comment">% 理想真实轨迹 （匀速1m/s前进）</span></span><br><span class="line">    z = <span class="built_in">true</span>_x + sigma_R * <span class="built_in">randn</span>(<span class="number">3</span>,<span class="number">1</span>);  <span class="comment">% 量测   模拟量测误差：每个观测点加入高斯噪声 </span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">%======== 因子图优化解 ========%</span></span><br><span class="line">    x0 = [<span class="number">0</span>; <span class="number">0.5</span>; <span class="number">1.8</span>];         <span class="comment">% 先验 （不一定准确）</span></span><br><span class="line">    opts = optimoptions(<span class="string">&#x27;lsqnonlin&#x27;</span>, <span class="string">&#x27;Display&#x27;</span>,<span class="string">&#x27;off&#x27;</span>); <span class="comment">% 设置优化器参数</span></span><br><span class="line">    <span class="comment">% lsqnonlin 是 MATLAB 的非线性最小二乘优化器，会最小化所有残差的平方和：</span></span><br><span class="line">    <span class="comment">% 残差由 residual_fg 函数返回</span></span><br><span class="line">    x_fg = lsqnonlin(@(x) residual_fg(x, z, v, dt, sigma_0, sigma_Q, sigma_R), x0, [], [], opts); </span><br><span class="line"></span><br><span class="line">    <span class="comment">%======== EKF 解 ========%</span></span><br><span class="line">    x_ekf = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);         <span class="comment">% 状态估计</span></span><br><span class="line">    P = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);             <span class="comment">% 协方差</span></span><br><span class="line">    x_ekf(<span class="number">1</span>) = <span class="number">0</span>;               <span class="comment">% 初始值</span></span><br><span class="line">    P(<span class="number">1</span>) = sigma_0^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">2</span>:<span class="number">3</span></span><br><span class="line">        <span class="comment">% Prediction</span></span><br><span class="line">        x_pred = x_ekf(k<span class="number">-1</span>) + v * dt;       <span class="comment">% 用运动模型预测位置</span></span><br><span class="line">        P_pred = P(k<span class="number">-1</span>) + sigma_Q^<span class="number">2</span>;   <span class="comment">% 协方差传播（加过程噪声）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% Measurement update</span></span><br><span class="line">        K = P_pred / (P_pred + sigma_R^<span class="number">2</span>);      <span class="comment">% 卡尔曼增益</span></span><br><span class="line">        x_ekf(k) = x_pred + K * (z(k) - x_pred);   <span class="comment">% 状态更新</span></span><br><span class="line">        P(k) = (<span class="number">1</span> - K) * P_pred;                            <span class="comment">% 协方差更新</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%======== 可视化 ========%</span></span><br><span class="line">    <span class="built_in">figure</span>; <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="built_in">plot</span>(<span class="number">0</span>:<span class="number">2</span>, <span class="built_in">true</span>_x, <span class="string">&#x27;k--o&#x27;</span>, <span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;True Trajectory&#x27;</span>);</span><br><span class="line">    <span class="built_in">plot</span>(<span class="number">0</span>:<span class="number">2</span>, z, <span class="string">&#x27;rx&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>, <span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;Measurements&#x27;</span>);</span><br><span class="line">    <span class="built_in">plot</span>(<span class="number">0</span>:<span class="number">2</span>, x_fg, <span class="string">&#x27;b-o&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;Factor Graph&#x27;</span>);</span><br><span class="line">    <span class="built_in">plot</span>(<span class="number">0</span>:<span class="number">2</span>, x_ekf, <span class="string">&#x27;g--s&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;DisplayName&#x27;</span>,<span class="string">&#x27;EKF&#x27;</span>);</span><br><span class="line">    <span class="built_in">legend</span>;</span><br><span class="line">    grid on;</span><br><span class="line">    xlabel(<span class="string">&#x27;Time step k&#x27;</span>); ylabel(<span class="string">&#x27;Position&#x27;</span>);</span><br><span class="line">    title(<span class="string">&#x27;1D Trajectory Estimation: EKF vs Factor Graph&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%======== RMSE 计算 ========%</span></span><br><span class="line">    rmse_ekf = <span class="built_in">sqrt</span>(<span class="built_in">mean</span>((x_ekf - <span class="built_in">true</span>_x).^<span class="number">2</span>));</span><br><span class="line">    rmse_fgo = <span class="built_in">sqrt</span>(<span class="built_in">mean</span>((x_fg - <span class="built_in">true</span>_x).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">%======== RMSE 对比图 ========%</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    bar([rmse_ekf, rmse_fgo]);</span><br><span class="line">    set(gca, <span class="string">&#x27;XTickLabel&#x27;</span>, &#123;<span class="string">&#x27;EKF&#x27;</span>, <span class="string">&#x27;Factor Graph&#x27;</span>&#125;);</span><br><span class="line">    ylabel(<span class="string">&#x27;RMSE&#x27;</span>);</span><br><span class="line">    title(<span class="string">&#x27;RMSE Comparison: EKF vs Factor Graph&#x27;</span>);</span><br><span class="line">    grid on;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 残差构造（因子图）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">r</span> = <span class="title">residual_fg</span><span class="params">(x, z, v, dt, sigma_0, sigma_Q, sigma_R)</span></span></span><br><span class="line">    <span class="comment">% x = [x0; x1; x2]</span></span><br><span class="line">    r_prior = (x(<span class="number">1</span>) - <span class="number">0</span>) / sigma_0;                        <span class="comment">% 初始先验项（越偏离0惩罚越大）  r_0 = \frac&#123;x_0 - \mu_0&#125;&#123;\sigma_0&#125;</span></span><br><span class="line">    r_motion1 = (x(<span class="number">2</span>) - x(<span class="number">1</span>) - v*dt) / sigma_Q;   <span class="comment">% r_1 = \frac&#123;x_1 - x_0 - v \cdot dt&#125;&#123;\sigma_Q&#125;</span></span><br><span class="line">    r_motion2 = (x(<span class="number">3</span>) - x(<span class="number">2</span>) - v*dt) / sigma_Q;   <span class="comment">% r_2 = \frac&#123;x_2 - x_1 - v \cdot dt&#125;&#123;\sigma_Q&#125;</span></span><br><span class="line">    r_obs = (z - x) / sigma_R;                              <span class="comment">% 所有观测的误差（每一时刻观测 z_k 与估计 x_k 的差）r_z = \frac&#123;z_k - x_k&#125;&#123;\sigma_R&#125;</span></span><br><span class="line">    r = [r_prior; r_motion1; r_motion2; r_obs];   <span class="comment">% 拼接成一维残差向量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="粒子②"><a href="#粒子②" class="headerlink" title="粒子②"></a>粒子②</h2><p>更进一步：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">T = <span class="number">100</span>;              <span class="comment">% 时间步数</span></span><br><span class="line">dt = <span class="number">1.0</span>;            <span class="comment">% 时间间隔</span></span><br><span class="line">v = <span class="number">1.0</span>;             <span class="comment">% 真实速度（恒定）</span></span><br><span class="line"></span><br><span class="line">Q = <span class="number">0.5</span>^<span class="number">2</span>;           <span class="comment">% 过程噪声方差 (较大噪声)</span></span><br><span class="line">R = <span class="number">1.8</span>^<span class="number">2</span>;           <span class="comment">% 观测噪声方差 (较大噪声)</span></span><br><span class="line"></span><br><span class="line">rng(<span class="number">42</span>);             <span class="comment">% 固定随机种子，方便复现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 真值轨迹生成 (匀速运动 + 过程噪声)</span></span><br><span class="line"><span class="comment">% 状态方程: x_k = x_&#123;k-1&#125; + v*dt + w_k  （运动模型）</span></span><br><span class="line"><span class="comment">% w_k ~ N(0, Q) - 过程噪声 （零均值高斯噪声）</span></span><br><span class="line"><span class="comment">% sqrt(Q)*randn 生成标准差为 sqrt(Q) 的高斯噪声</span></span><br><span class="line">x_<span class="built_in">true</span> = <span class="built_in">zeros</span>(T,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:T</span><br><span class="line">    x_<span class="built_in">true</span>(k) = x_<span class="built_in">true</span>(k<span class="number">-1</span>) + v*dt + <span class="built_in">sqrt</span>(Q)*<span class="built_in">randn</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 观测生成 (仅偶数时刻有观测，50%缺失)</span></span><br><span class="line">z = NaN(T,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:T</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(k,<span class="number">2</span>)==<span class="number">0</span></span><br><span class="line">        z(k) = x_<span class="built_in">true</span>(k) + <span class="built_in">sqrt</span>(R)*<span class="built_in">randn</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% ==================== EKF 实现 ====================</span></span><br><span class="line">x_ekf = <span class="built_in">zeros</span>(T,<span class="number">1</span>);      <span class="comment">% 状态估计</span></span><br><span class="line">P = <span class="number">1000</span>;                   <span class="comment">% 初始协方差 (较大不确定性)</span></span><br><span class="line">x_ekf(<span class="number">1</span>) = <span class="number">0</span>;               <span class="comment">% 初始状态设为0 (无初始观测) （设为0，与实际有偏差）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:T</span><br><span class="line">    <span class="comment">% ---预测---</span></span><br><span class="line">    <span class="comment">% 状态预测: x_pred = f(x_&#123;k-1&#125;) = x_&#123;k-1&#125; + v*dt</span></span><br><span class="line">    x_pred = x_ekf(k<span class="number">-1</span>) + v*dt; </span><br><span class="line">    <span class="comment">% 协方差预测: P_pred = F·P·F&#x27; + Q  % 过程噪声增加不确定性</span></span><br><span class="line">    <span class="comment">% 这里F=1（一维线性系统），所以简化为 P_pred = P + Q</span></span><br><span class="line">    P_pred = P + Q; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --更新--- </span></span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isnan</span>(z(k)) <span class="comment">% 有观测时执行更新</span></span><br><span class="line">        <span class="comment">% 计算Kalman增益: K = P_pred·H&#x27;·(H·P_pred·H&#x27; + R)^&#123;-1&#125;</span></span><br><span class="line">        <span class="comment">% 这里H=1（观测矩阵），简化为 K = P_pred/(P_pred + R)</span></span><br><span class="line">        K = P_pred / (P_pred + R);  </span><br><span class="line">        <span class="comment">% 状态更新: x = x_pred + K·(z - H·x_pred)</span></span><br><span class="line">        x_ekf(k) = x_pred + K * (z(k) - x_pred);</span><br><span class="line">        <span class="comment">% 协方差更新: P = (I - K·H)·P_pred</span></span><br><span class="line">        P = (<span class="number">1</span> - K) * P_pred;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">% 无观测时仅预测</span></span><br><span class="line">        x_ekf(k) = x_pred;</span><br><span class="line">        P = P_pred;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% ==================== FGO 实现 ====================</span></span><br><span class="line"><span class="comment">% 初始化信息矩阵(Λ)和信息向量(η)</span></span><br><span class="line">Lambda = <span class="built_in">zeros</span>(T, T);  <span class="comment">% 信息矩阵 (Hessian)</span></span><br><span class="line">eta = <span class="built_in">zeros</span>(T, <span class="number">1</span>);     <span class="comment">% 信息向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加弱先验因子 (避免矩阵奇异)</span></span><br><span class="line">Lambda(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">1</span>/<span class="number">10000</span>; <span class="comment">% 弱先验信息 (方差=10000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加动态因子 (相邻状态间的约束)</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:T</span><br><span class="line">    <span class="comment">% 动态因子表示状态转移约束: x_k = x_&#123;k-1&#125; + v*dt + w_k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 信息矩阵更新 (四元素更新)</span></span><br><span class="line">    <span class="comment">% 对应约束: (x_k - x_&#123;k-1&#125; - v*dt)^2 / Q</span></span><br><span class="line">    Lambda(k<span class="number">-1</span>, k<span class="number">-1</span>) = Lambda(k<span class="number">-1</span>, k<span class="number">-1</span>) + <span class="number">1</span>/Q;</span><br><span class="line">    Lambda(k<span class="number">-1</span>, k)   = Lambda(k<span class="number">-1</span>, k)   - <span class="number">1</span>/Q;</span><br><span class="line">    Lambda(k, k<span class="number">-1</span>)   = Lambda(k, k<span class="number">-1</span>)   - <span class="number">1</span>/Q;</span><br><span class="line">    Lambda(k, k)     = Lambda(k, k)     + <span class="number">1</span>/Q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 信息向量更新</span></span><br><span class="line">    <span class="comment">% 对应约束中的常数项: -2*(v*dt)*(x_k - x_&#123;k-1&#125;)/(2Q)</span></span><br><span class="line">    eta(k<span class="number">-1</span>) = eta(k<span class="number">-1</span>) - (v*dt)/Q;</span><br><span class="line">    eta(k)   = eta(k)   + (v*dt)/Q;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加观测因子</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:T</span><br><span class="line">    <span class="keyword">if</span> ~<span class="built_in">isnan</span>(z(k)) <span class="comment">% 仅在有观测时添加</span></span><br><span class="line">        <span class="comment">% 观测因子: (x_k - z_k)^2 / R</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 信息矩阵更新</span></span><br><span class="line">        Lambda(k, k) = Lambda(k, k) + <span class="number">1</span>/R;</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 信息向量更新</span></span><br><span class="line">        eta(k) = eta(k) + z(k)/R;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ------ 求解线性系统 ------</span></span><br><span class="line"><span class="comment">% 最大后验估计: x̂ = argmin Σ||r_i||^2 = Λ^&#123;-1&#125;η</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用Cholesky分解高效求解</span></span><br><span class="line">R_chol = chol(Lambda); <span class="comment">% Cholesky分解: Λ = R&#x27;*R</span></span><br><span class="line">x_fgo = R_chol \ (R_chol&#x27; \ eta); <span class="comment">% 求解线性系统: R&#x27;*R*x = η</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% ==================== 性能评估 ====================</span></span><br><span class="line"><span class="comment">% 计算RMSE</span></span><br><span class="line">ekf_error = x_<span class="built_in">true</span> - x_ekf;</span><br><span class="line">fgo_error = x_<span class="built_in">true</span> - x_fgo;</span><br><span class="line"></span><br><span class="line">rmse_ekf = <span class="built_in">sqrt</span>(<span class="built_in">mean</span>(ekf_error.^<span class="number">2</span>));</span><br><span class="line">rmse_fgo = <span class="built_in">sqrt</span>(<span class="built_in">mean</span>(fgo_error.^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算平均误差</span></span><br><span class="line">mean_ekf = <span class="built_in">mean</span>(<span class="built_in">abs</span>(ekf_error));</span><br><span class="line">mean_fgo = <span class="built_in">mean</span>(<span class="built_in">abs</span>(fgo_error));</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;============ 性能对比 ============\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;EKF 均方根误差(RMSE): %.4f\n&#x27;</span>, rmse_ekf);</span><br><span class="line">fprintf(<span class="string">&#x27;FGO 均方根误差(RMSE): %.4f\n&#x27;</span>, rmse_fgo);</span><br><span class="line">fprintf(<span class="string">&#x27;EKF 平均绝对误差: %.4f\n&#x27;</span>, mean_ekf);</span><br><span class="line">fprintf(<span class="string">&#x27;FGO 平均绝对误差: %.4f\n&#x27;</span>, mean_fgo);</span><br><span class="line">fprintf(<span class="string">&#x27;FGO精度提升: %.2f%%\n&#x27;</span>, (rmse_ekf - rmse_fgo)/rmse_ekf*<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% ==================== 绘图对比 ====================</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>, [<span class="number">100</span>, <span class="number">100</span>, <span class="number">1200</span>, <span class="number">600</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 轨迹对比</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:T, x_<span class="built_in">true</span>, <span class="string">&#x27;-k&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:T, x_ekf, <span class="string">&#x27;--b&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:T, x_fgo, <span class="string">&#x27;-.r&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="built_in">scatter</span>(<span class="built_in">find</span>(~<span class="built_in">isnan</span>(z)), z(~<span class="built_in">isnan</span>(z)), <span class="number">70</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;filled&#x27;</span>, <span class="string">&#x27;MarkerEdgeColor&#x27;</span>, <span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;轨迹估计对比&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;真实轨迹&#x27;</span>, <span class="string">&#x27;EKF估计&#x27;</span>, <span class="string">&#x27;FGO估计&#x27;</span>, <span class="string">&#x27;观测点&#x27;</span>, <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;northwest&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间步&#x27;</span>); ylabel(<span class="string">&#x27;位置&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">set(gca, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 误差对比</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:T, <span class="built_in">abs</span>(ekf_error), <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:T, <span class="built_in">abs</span>(fgo_error), <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1.5</span>);</span><br><span class="line">title(<span class="string">&#x27;估计误差绝对值&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;EKF误差&#x27;</span>, <span class="string">&#x27;FGO误差&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间步&#x27;</span>); ylabel(<span class="string">&#x27;位置误差&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">set(gca, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 标注性能指标</span></span><br><span class="line">annotation(<span class="string">&#x27;textbox&#x27;</span>, [<span class="number">0.15</span>, <span class="number">0.25</span>, <span class="number">0.2</span>, <span class="number">0.1</span>], <span class="string">&#x27;String&#x27;</span>, ...</span><br><span class="line">    sprintf(<span class="string">&#x27;EKF RMSE: %.4f\nFGO RMSE: %.4f&#x27;</span>, rmse_ekf, rmse_fgo), ...</span><br><span class="line">    <span class="string">&#x27;FitBoxToText&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;BackgroundColor&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><a href="https://kausiujik.github.io/2022/09/29/Bayes_Lec4.2/">一般损失函数下的贝叶斯解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> XKF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMU预积分</title>
      <link href="/post/12bc0cb8.html"/>
      <url>/post/12bc0cb8.html</url>
      
        <content type="html"><![CDATA[<p>Related Reading:</p><ul><li><a href="https://nkymzsy.github.io/2022/04/21/02_gtsam%E5%85%B3%E4%BA%8Eimu%E9%A2%84%E7%A7%AF%E5%88%86%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/">gtsam关于imu预积分实现探究</a></li><li><a href="https://blog.csdn.net/baidu_37561491/article/details/124051657">GTSAM中imu预积分及其因子图优化过程</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/navigation/PreintegrationParams.h&gt;</span>  <span class="comment">// 引入GTSAM中用于预积分参数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/navigation/ImuFactor.h&gt;</span>  <span class="comment">// 引入IMU因子的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span>  <span class="comment">// 引入Levenberg-Marquardt优化器，用于非线性优化</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/Values.h&gt;</span>  <span class="comment">// 引入GTSAM中的Values类，用于存储优化结果</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/slam/PriorFactor.h&gt;</span>  <span class="comment">// 引入GTSAM中的先验因子，用于定义先验约束</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose3.h&gt;</span>  <span class="comment">// 引入GTSAM中的Pose3类，表示3D位姿</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/inference/Symbol.h&gt;</span>  <span class="comment">// 引入GTSAM中的符号类，便于标识变量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/navigation/NavState.h&gt;</span>  <span class="comment">// 引入GTSAM中的NavState类，表示导航状态（位姿+速度）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/slam/BetweenFactor.h&gt;</span>  <span class="comment">// 引入GTSAM中的BetweenFactor类，表示两个变量之间的约束</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">// 引入标准输入输出库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// 引入文件操作库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  <span class="comment">// 引入字符串流库，用于处理CSV数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  <span class="comment">// 引入向量容器库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  <span class="comment">// 引入数学库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>  <span class="comment">// 引入格式化输入输出库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;  <span class="comment">// 使用GTSAM命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载来自CSV文件的AVP数据</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;avp_data.csv&quot;</span>)</span></span>;  <span class="comment">// 打开CSV文件</span></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;  <span class="comment">// 如果文件无法打开</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to open the file!&quot;</span> &lt;&lt; endl;  <span class="comment">// 输出错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回错误代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义用于存储数据的变量</span></span><br><span class="line">    vector&lt;Vector3&gt; euler_angles;  <span class="comment">// 存储欧拉角（滚转角、俯仰角、偏航角）</span></span><br><span class="line">    vector&lt;Vector3&gt; velocities;    <span class="comment">// 存储速度数据（X, Y, Z）</span></span><br><span class="line">    vector&lt;Vector3&gt; positions;     <span class="comment">// 存储位置数据（X, Y, Z）</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; time_intervals; <span class="comment">// 存储时间间隔（假设这里时间间隔为常数0.1秒）</span></span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="comment">// 跳过CSV文件的表头（如果存在）</span></span><br><span class="line">    <span class="built_in">getline</span>(file, line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CSV文件中读取数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;  <span class="comment">// 使用字符串流解析每一行</span></span><br><span class="line">        string value;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; row_data;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, value, <span class="string">&#x27;,&#x27;</span>)) &#123;  <span class="comment">// 按照逗号分隔读取每个值</span></span><br><span class="line">            row_data.<span class="built_in">push_back</span>(<span class="built_in">stod</span>(value));  <span class="comment">// 转换为数字并存储</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设CSV列的顺序为：roll, pitch, yaw, velocity_x, velocity_y, velocity_z, pos_x, pos_y, pos_z, time_interval</span></span><br><span class="line">        euler_angles.<span class="built_in">emplace_back</span>(row_data[<span class="number">0</span>], row_data[<span class="number">1</span>], row_data[<span class="number">2</span>]);  <span class="comment">// 存储欧拉角</span></span><br><span class="line">        velocities.<span class="built_in">emplace_back</span>(row_data[<span class="number">3</span>], row_data[<span class="number">4</span>], row_data[<span class="number">5</span>]);    <span class="comment">// 存储速度</span></span><br><span class="line">        positions.<span class="built_in">emplace_back</span>(row_data[<span class="number">6</span>], row_data[<span class="number">7</span>], row_data[<span class="number">8</span>]);     <span class="comment">// 存储位置</span></span><br><span class="line">        time_intervals.<span class="built_in">emplace_back</span>(row_data[<span class="number">9</span>]); <span class="comment">// 存储时间间隔</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.<span class="built_in">close</span>();  <span class="comment">// 关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重力加速度和IMU参数</span></span><br><span class="line">    <span class="function">Vector3 <span class="title">gravity</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-9.81</span>)</span></span>;  <span class="comment">// 定义重力加速度向量，z轴为-9.81 m/s²</span></span><br><span class="line">    <span class="keyword">auto</span> params = PreintegrationParams::<span class="built_in">MakeSharedU</span>(<span class="number">-9.81</span>);  <span class="comment">// 创建IMU预积分参数，使用重力加速度</span></span><br><span class="line">    params-&gt;accelerometerCovariance = I_3x3 * <span class="number">0.01</span>;  <span class="comment">// 设置加速度计噪声协方差（0.01）</span></span><br><span class="line">    params-&gt;gyroscopeCovariance = I_3x3 * <span class="number">0.01</span>;      <span class="comment">// 设置陀螺仪噪声协方差（0.01）</span></span><br><span class="line">    params-&gt;integrationCovariance = I_3x3 * <span class="number">0.01</span>;    <span class="comment">// 设置积分噪声协方差（0.01）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMU偏置</span></span><br><span class="line">    gtsam::imuBias::ConstantBias prior_bias;  <span class="comment">// 假设IMU初始偏置为零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始状态</span></span><br><span class="line">    <span class="function">Pose3 <span class="title">prior_pose</span><span class="params">(Rot3::RzRyRx(euler_angles[<span class="number">0</span>]), Point3(positions[<span class="number">0</span>].x(), positions[<span class="number">0</span>].y(), positions[<span class="number">0</span>].z()))</span></span>;  <span class="comment">// 初始位姿</span></span><br><span class="line">    Vector3 prior_velocity = velocities[<span class="number">0</span>];  <span class="comment">// 初始速度</span></span><br><span class="line">    <span class="function">NavState <span class="title">prior_state</span><span class="params">(prior_pose, prior_velocity)</span></span>;  <span class="comment">// 初始化导航状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 噪声模型</span></span><br><span class="line">    <span class="keyword">auto</span> pose_noise_model = noiseModel::Diagonal::<span class="built_in">Sigmas</span>((<span class="built_in">Vector</span>(<span class="number">6</span>) &lt;&lt; <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>).<span class="built_in">finished</span>());  <span class="comment">// 位姿噪声模型</span></span><br><span class="line">    <span class="keyword">auto</span> velocity_noise_model = noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">3</span>, <span class="number">0.1</span>);  <span class="comment">// 速度噪声模型</span></span><br><span class="line">    <span class="keyword">auto</span> bias_noise_model = noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">6</span>, <span class="number">0.1</span>);  <span class="comment">// 偏置噪声模型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建因子图和初始估计容器</span></span><br><span class="line">    NonlinearFactorGraph graph;  <span class="comment">// 创建非线性因子图</span></span><br><span class="line">    Values initialEstimate;  <span class="comment">// 创建初始估计容器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加先验因子（先验约束）</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose3&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, <span class="number">0</span>), prior_pose, pose_noise_model));  <span class="comment">// 添加位姿先验</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Vector3&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, <span class="number">0</span>), prior_velocity, velocity_noise_model));  <span class="comment">// 添加速度先验</span></span><br><span class="line">    graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;imuBias::ConstantBias&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>), prior_bias, bias_noise_model));  <span class="comment">// 添加偏置先验</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加初始状态估计</span></span><br><span class="line">    initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, <span class="number">0</span>), prior_pose);  <span class="comment">// 添加初始位姿</span></span><br><span class="line">    initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, <span class="number">0</span>), prior_velocity);  <span class="comment">// 添加初始速度</span></span><br><span class="line">    initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>), prior_bias);  <span class="comment">// 添加初始偏置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IMU预积分对象</span></span><br><span class="line">    <span class="function">PreintegratedImuMeasurements <span class="title">preintegrated</span><span class="params">(params, prior_bias)</span></span>;  <span class="comment">// 创建IMU预积分对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出CSV文件，保存结果</span></span><br><span class="line">    <span class="function">ofstream <span class="title">output_file</span><span class="params">(<span class="string">&quot;pre_avp_data_2.csv&quot;</span>)</span></span>;</span><br><span class="line">    output_file &lt;&lt; <span class="string">&quot;roll,pitch,yaw,velocity_x,velocity_y,velocity_z,x,y,z,time_interval\n&quot;</span>;  <span class="comment">// 写入CSV表头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历IMU数据并进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; euler_angles.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">double</span> dt = time_intervals[i];  <span class="comment">// 获取当前时间间隔</span></span><br><span class="line">        Vector3 measured_acc = velocities[i];   <span class="comment">// 使用速度作为加速度计数据的代理</span></span><br><span class="line">        Vector3 measured_omega = euler_angles[i];  <span class="comment">// 使用欧拉角作为陀螺仪数据的代理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对IMU数据进行积分</span></span><br><span class="line">        preintegrated.<span class="built_in">integrateMeasurement</span>(measured_acc, measured_omega, dt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每隔一段时间或者在关键帧处添加IMU因子</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每10个步骤添加一个因子</span></span><br><span class="line">            <span class="function">Pose3 <span class="title">current_pose</span><span class="params">(Rot3::RzRyRx(euler_angles[i]), Point3(positions[i].x(), positions[i].y(), positions[i].z()))</span></span>;  <span class="comment">// 当前位姿</span></span><br><span class="line">            Vector3 current_velocity = velocities[i];  <span class="comment">// 当前速度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加IMU因子</span></span><br><span class="line">            <span class="function">ImuFactor <span class="title">imu_factor</span><span class="params">(Symbol(<span class="string">&#x27;x&#x27;</span>, i - <span class="number">10</span>), Symbol(<span class="string">&#x27;v&#x27;</span>, i - <span class="number">10</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                Symbol(<span class="string">&#x27;x&#x27;</span>, i), Symbol(<span class="string">&#x27;v&#x27;</span>, i),</span></span></span><br><span class="line"><span class="params"><span class="function">                Symbol(<span class="string">&#x27;b&#x27;</span>, i - <span class="number">10</span>), preintegrated)</span></span>;</span><br><span class="line">            graph.<span class="built_in">add</span>(imu_factor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加偏置演化作为之间的因子</span></span><br><span class="line">            <span class="keyword">auto</span> bias_between_noise = noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">6</span>, <span class="number">0.01</span>);</span><br><span class="line">            graph.<span class="built_in">add</span>(<span class="built_in">BetweenFactor</span>&lt;imuBias::ConstantBias&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, i - <span class="number">10</span>), <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, i), imuBias::<span class="built_in">ConstantBias</span>(), bias_between_noise));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新初始估计</span></span><br><span class="line">            <span class="keyword">if</span> (initialEstimate.<span class="built_in">exists</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, i))) &#123;</span><br><span class="line">                initialEstimate.<span class="built_in">update</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, i), current_pose);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, i), current_pose);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (initialEstimate</span><br><span class="line"></span><br><span class="line">.<span class="built_in">exists</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, i))) &#123;</span><br><span class="line">                initialEstimate.<span class="built_in">update</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, i), current_velocity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, i), current_velocity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (initialEstimate.<span class="built_in">exists</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, i))) &#123;</span><br><span class="line">                initialEstimate.<span class="built_in">update</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, i), prior_bias);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, i), prior_bias);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Levenberg-Marquardt进行批量优化</span></span><br><span class="line">    LevenbergMarquardtParams lm_params;  <span class="comment">// 创建Levenberg-Marquardt优化器的参数</span></span><br><span class="line">    lm_params.<span class="built_in">setVerbosity</span>(<span class="string">&quot;ERROR&quot;</span>);  <span class="comment">// 设置输出级别为“错误”以减少输出信息</span></span><br><span class="line">    lm_params.<span class="built_in">setMaxIterations</span>(<span class="number">100</span>);   <span class="comment">// 设置最大迭代次数为100</span></span><br><span class="line">    lm_params.<span class="built_in">setRelativeErrorTol</span>(<span class="number">1e-5</span>); <span class="comment">// 设置相对误差容忍度为1e-5</span></span><br><span class="line">    <span class="function">LevenbergMarquardtOptimizer <span class="title">optimizer</span><span class="params">(graph, initialEstimate, lm_params)</span></span>;  <span class="comment">// 创建优化器</span></span><br><span class="line">    Values result = optimizer.<span class="built_in">optimize</span>();  <span class="comment">// 执行优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终优化的状态并保存到CSV文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">log_file</span><span class="params">(<span class="string">&quot;trajectory_log.txt&quot;</span>)</span></span>;  <span class="comment">// 创建日志文件保存轨迹数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; euler_angles.<span class="built_in">size</span>(); i += <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Pose3 pose = result.<span class="built_in">at</span>&lt;Pose3&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, i));  <span class="comment">// 获取优化后的位姿</span></span><br><span class="line">            Vector3 velocity = result.<span class="built_in">at</span>&lt;Vector3&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, i));  <span class="comment">// 获取优化后的速度</span></span><br><span class="line">            Vector3 rpy = pose.<span class="built_in">rotation</span>().<span class="built_in">rpy</span>();  <span class="comment">// 获取优化后的欧拉角（滚转、俯仰、偏航）</span></span><br><span class="line">            <span class="type">double</span> time_interval = time_intervals[i];  <span class="comment">// 获取时间间隔</span></span><br><span class="line">            log_file &lt;&lt; <span class="string">&quot;Pose at step &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pose &lt;&lt; endl;  <span class="comment">// 写入日志文件</span></span><br><span class="line">            log_file &lt;&lt; <span class="string">&quot;Velocity at step &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; velocity.<span class="built_in">transpose</span>() &lt;&lt; endl;  <span class="comment">// 写入日志文件</span></span><br><span class="line">            output_file &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">15</span>) &lt;&lt; rpy.<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rpy.<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rpy.<span class="built_in">z</span>() &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">                &lt;&lt; velocity.<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; velocity.<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; velocity.<span class="built_in">z</span>() &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">                &lt;&lt; pose.<span class="built_in">x</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pose.<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; pose.<span class="built_in">z</span>() &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">                &lt;&lt; time_interval &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 保存轨迹数据到CSV文件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> exception&amp; e) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Exception while accessing data at step &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 如果访问数据时发生异常，输出错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    output_file.<span class="built_in">close</span>();</span><br><span class="line">    log_file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序正常结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>数据读取</strong>：从CSV文件中加载AVP数据，具体包括欧拉角、速度、位置和时间间隔。</li><li><strong>预积分与IMU因子</strong>：使用IMU数据进行预积分并创建IMU因子，这在因子图优化中非常重要，尤其是在处理时间序列数据时。</li><li><strong>因子图优化</strong>：利用Levenberg-Marquardt优化器执行非线性优化，优化位姿、速度和IMU偏置。</li><li><strong>结果保存</strong>：最终的优化结果被输出到日志文件和CSV文件，包含了优化后的轨迹信息。</li></ol><hr><p>这段代码的主要功能是使用<strong>IMU（惯性测量单元）数据</strong>，结合<strong>图优化</strong>技术（尤其是 <strong>GTSAM</strong> 库），来进行 <strong>机器人或设备的状态估计</strong>，包括位姿（位置和朝向）、速度以及IMU的偏置估计。代码的核心任务是利用IMU的数据进行 <strong>预积分（Preintegration）</strong>，构建一个因子图（Factor Graph），并通过 <strong>图优化</strong> 来估计系统的状态。</p><p>我们可以逐步分析这段代码的工作流程，以便理解它的具体功能。</p><hr><h2 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a><strong>背景知识：</strong></h2><p>在 <strong>机器人学</strong> 或 <strong>传感器融合</strong> 中，IMU 是一种常见的传感器，能够测量加速度和角速度。常见的应用包括 <strong>定位</strong>、<strong>姿态估计</strong>、<strong>惯性导航系统（INS）</strong> 等。</p><p>IMU 提供的是<strong>积分数据</strong>，意味着我们通常得到的是<strong>增量变化</strong>，而不是绝对位置、速度或姿态。因此，IMU 的数据需要通过 <strong>预积分（Preintegration）</strong> 和 <strong>优化算法</strong> 来推算出更准确的全局状态。</p><p><strong>GTSAM</strong> 是一个处理 <strong>图优化</strong> 的库，常用于 SLAM（Simultaneous Localization and Mapping）和其他优化问题。通过构建一个 <strong>因子图（Factor Graph）</strong>，它能够将各种约束（例如，来自传感器的测量数据）合并到一起，并通过优化算法（如 <strong>Levenberg-Marquardt</strong>）求解出最优的状态估计。</p><hr><h2 id="代码功能概述："><a href="#代码功能概述：" class="headerlink" title="代码功能概述："></a><strong>代码功能概述：</strong></h2><ol><li><strong>读取IMU和位置数据</strong>：从CSV文件中读取IMU的角速度、加速度、位置、速度以及时间戳等信息。</li><li><strong>设置IMU预积分参数</strong>：使用IMU数据进行<strong>预积分</strong>，即通过加速度和角速度的增量计算设备的位姿和速度的变化。</li><li><strong>建立因子图</strong>：将IMU的预积分数据、设备的初始状态（位姿、速度、偏置）和噪声模型等添加到因子图中，构建一个非线性优化问题。</li><li><strong>执行图优化</strong>：使用 <strong>Levenberg-Marquardt优化器</strong> 对因子图进行优化，得到设备的最优状态（位姿、速度和偏置）。</li><li><strong>输出结果</strong>：将优化后的位姿、速度和其他信息保存到文件中，供后续分析使用。</li></ol><hr><h3 id="具体步骤分析："><a href="#具体步骤分析：" class="headerlink" title="具体步骤分析："></a><strong>具体步骤分析：</strong></h3><h3 id="1-数据读取（读取CSV文件中的IMU数据）"><a href="#1-数据读取（读取CSV文件中的IMU数据）" class="headerlink" title="1. 数据读取（读取CSV文件中的IMU数据）"></a>1. <strong>数据读取（读取CSV文件中的IMU数据）</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;avp_data.csv&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Unable to open the file!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，代码尝试从 <code>&quot;avp_data.csv&quot;</code> 文件中读取数据。如果文件打开失败，程序会输出错误信息并终止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Vector3&gt; euler_angles;</span><br><span class="line">vector&lt;Vector3&gt; velocities;</span><br><span class="line">vector&lt;Vector3&gt; positions;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; time_intervals;</span><br></pre></td></tr></table></figure><p>定义几个 <code>vector</code> 用来存储从CSV文件中读取的数据：</p><ul><li><strong>euler_angles</strong>：每一行数据中的欧拉角（roll, pitch, yaw），表示物体的姿态。</li><li><strong>velocities</strong>：每一行数据中的速度（x, y, z）。</li><li><strong>positions</strong>：每一行数据中的位置（x, y, z）。</li><li><strong>time_intervals</strong>：时间间隔，假设为常量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">    string value;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; row_data;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, value, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">        row_data.<span class="built_in">push_back</span>(<span class="built_in">stod</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assuming columns are ordered as: roll, pitch, yaw, velocity_x, velocity_y, velocity_z, pos_x, pos_y, pos_z, time_interval</span></span><br><span class="line">    euler_angles.<span class="built_in">emplace_back</span>(row_data[<span class="number">0</span>], row_data[<span class="number">1</span>], row_data[<span class="number">2</span>]);</span><br><span class="line">    velocities.<span class="built_in">emplace_back</span>(row_data[<span class="number">3</span>], row_data[<span class="number">4</span>], row_data[<span class="number">5</span>]);</span><br><span class="line">    positions.<span class="built_in">emplace_back</span>(row_data[<span class="number">6</span>], row_data[<span class="number">7</span>], row_data[<span class="number">8</span>]);</span><br><span class="line">    time_intervals.<span class="built_in">emplace_back</span>(row_data[<span class="number">9</span>]);</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>这里逐行读取CSV文件中的数据，并将每行数据转换成对应的 <strong>欧拉角</strong>、<strong>速度</strong>、<strong>位置</strong> 和 <strong>时间间隔</strong>，存入前面定义的 <code>vector</code> 中。CSV文件的每一行数据的顺序假设是：<strong>欧拉角</strong>（roll, pitch, yaw）、<strong>速度</strong>（velocity_x, velocity_y, velocity_z）、<strong>位置</strong>（pos_x, pos_y, pos_z）和 <strong>时间间隔</strong>。</p><h3 id="2-IMU预积分参数设置"><a href="#2-IMU预积分参数设置" class="headerlink" title="2. IMU预积分参数设置"></a>2. <strong>IMU预积分参数设置</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3 <span class="title">gravity</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-9.81</span>)</span></span>;  <span class="comment">// 设置重力加速度</span></span><br><span class="line"><span class="keyword">auto</span> params = PreintegrationParams::<span class="built_in">MakeSharedU</span>(<span class="number">-9.81</span>);  <span class="comment">// 使用重力加速度创建IMU预积分参数</span></span><br><span class="line">params-&gt;accelerometerCovariance = I_3x3 * <span class="number">0.01</span>;  <span class="comment">// 设置加速度计噪声协方差</span></span><br><span class="line">params-&gt;gyroscopeCovariance = I_3x3 * <span class="number">0.01</span>;      <span class="comment">// 设置陀螺仪噪声协方差</span></span><br><span class="line">params-&gt;integrationCovariance = I_3x3 * <span class="number">0.01</span>;    <span class="comment">// 设置积分噪声协方差</span></span><br></pre></td></tr></table></figure><p>在这部分代码中，我们创建了一个 <strong>IMU预积分参数对象</strong> <code>params</code>。这个对象将用于对IMU数据进行预积分，计算设备的状态（位姿和速度）的增量。</p><ul><li><code>gravity</code> 设置了重力加速度，指向 <strong>z轴负方向</strong>。</li><li><code>params</code> 对象初始化时使用了重力加速度，这对于IMU数据的处理至关重要。</li><li>通过调整 <strong>加速度计</strong>、<strong>陀螺仪</strong> 和 <strong>积分</strong> 的协方差矩阵，我们能够控制优化的精度和噪声。</li></ul><h3 id="3-初始估计和噪声模型设置"><a href="#3-初始估计和噪声模型设置" class="headerlink" title="3. 初始估计和噪声模型设置"></a>3. <strong>初始估计和噪声模型设置</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pose3 <span class="title">prior_pose</span><span class="params">(Rot3::RzRyRx(euler_angles[<span class="number">0</span>]), Point3(positions[<span class="number">0</span>].x(), positions[<span class="number">0</span>].y(), positions[<span class="number">0</span>].z()))</span></span>;</span><br><span class="line">Vector3 prior_velocity = velocities[<span class="number">0</span>];</span><br><span class="line"><span class="function">NavState <span class="title">prior_state</span><span class="params">(prior_pose, prior_velocity)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>prior_pose</strong>：使用从CSV文件读取的第一个欧拉角和位置数据来设置设备的初始位姿。</li><li><strong>prior_velocity</strong>：使用从CSV文件读取的第一个速度数据来设置设备的初始速度。</li><li><strong>prior_state</strong>：封装位姿和速度信息，表示设备的初始状态。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pose_noise_model = noiseModel::Diagonal::<span class="built_in">Sigmas</span>((<span class="built_in">Vector</span>(<span class="number">6</span>) &lt;&lt; <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>).<span class="built_in">finished</span>());  <span class="comment">// 位姿噪声模型</span></span><br><span class="line"><span class="keyword">auto</span> velocity_noise_model = noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">3</span>, <span class="number">0.1</span>);  <span class="comment">// 速度噪声模型</span></span><br><span class="line"><span class="keyword">auto</span> bias_noise_model = noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">6</span>, <span class="number">0.1</span>);  <span class="comment">// 偏置噪声模型</span></span><br></pre></td></tr></table></figure><ul><li><strong>pose_noise_model</strong>：为位姿（位置和朝向）设置噪声模型。</li><li><strong>velocity_noise_model</strong>：为速度设置噪声模型。</li><li><strong>bias_noise_model</strong>：为IMU的偏置设置噪声模型。</li></ul><h3 id="4-因子图（Factor-Graph）创建与初始化估计"><a href="#4-因子图（Factor-Graph）创建与初始化估计" class="headerlink" title="4. 因子图（Factor Graph）创建与初始化估计"></a>4. <strong>因子图（Factor Graph）创建与初始化估计</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NonlinearFactorGraph graph;  <span class="comment">// 创建因子图</span></span><br><span class="line">Values initialEstimate;  <span class="comment">// 创建初始估计容器</span></span><br></pre></td></tr></table></figure><ul><li><strong>graph</strong>：用于存储因子图中的所有因子（约束）。</li><li><strong>initialEstimate</strong>：存储所有优化变量的初始值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Pose3&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, <span class="number">0</span>), prior_pose, pose_noise_model));</span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;Vector3&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, <span class="number">0</span>), prior_velocity, velocity_noise_model));</span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PriorFactor</span>&lt;imuBias::ConstantBias&gt;(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>), prior_bias, bias_noise_model));</span><br></pre></td></tr></table></figure><p>这里，我们为 <strong>位姿</strong>、<strong>速度</strong> 和 <strong>IMU偏置</strong> 添加了先验因子（表示我们对初始状态的知识和不确定性）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;x&#x27;</span>, <span class="number">0</span>), prior_pose);  </span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;v&#x27;</span>, <span class="number">0</span>), prior_velocity);  </span><br><span class="line">initialEstimate.<span class="built_in">insert</span>(<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>), prior_bias);  </span><br></pre></td></tr></table></figure><p>这些代码为初始估计容器插入了初始的位姿、速度和偏置估计值。</p><h3 id="5-IMU数据预积分与因子添加"><a href="#5-IMU数据预积分与因子添加" class="headerlink" title="5. IMU数据预积分与因子添加"></a>5. <strong>IMU数据预积分与因子添加</strong></h3><p>在每次读取IMU数据时，使用预积分技术计算设备状态的增量，并将其添加到因子图中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreintegratedImuMeasurements <span class="title">preintegrated</span><span class="params">(params, prior_bias)</span></span>;  <span class="comment">// 创建IMU预积分对象</span></span><br></pre></td></tr></table></figure><p><code>preintegrated</code> 是一个 <strong>IMU预积分对象</strong>，用于根据每个时间步的加</p><p>速度和角速度来计算状态的增量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; euler_angles.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">double</span> dt = time_intervals[i];  <span class="comment">// 获取时间间隔</span></span><br><span class="line">    Vector3 measured_acc = velocities[i];   <span class="comment">// 假设速度作为加速度的代理</span></span><br><span class="line">    Vector3 measured_omega = euler_angles[i];  <span class="comment">// 假设欧拉角作为角速度的代理</span></span><br><span class="line">    preintegrated.<span class="built_in">integrateMeasurement</span>(measured_acc, measured_omega, dt);  <span class="comment">// 进行IMU预积分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每处理一个数据点，程序就将加速度和角速度（这里简化为速度和欧拉角）通过 <code>preintegrated</code> 进行预积分，从而更新当前的设备状态。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>这段代码实现了基于 <strong>IMU数据</strong> 和 <strong>图优化</strong> 的 <strong>状态估计</strong>。具体来说，它从CSV文件中读取设备的IMU数据（加速度、角速度、位置、速度等），并通过 <strong>预积分</strong> 和 <strong>图优化</strong> 技术来计算设备的最优状态（位置、速度和偏置）。优化过程使用 <strong>Levenberg-Marquardt算法</strong> 来最小化因子图中的误差，从而得到更精确的估计结果。</p><p>最终，优化后的结果被保存到文件中，供后续分析使用。</p><p>Reference:<br><a href="https://blog.csdn.net/qq_32761549/article/details/126268197">因子图优化及GTSAM中IMU预积分接口</a><br><a href="https://blog.csdn.net/LDST_CSDN/article/details/130674234">VINS-Mono+Fusion源码解析系列（八）：IMU预积分的代码实现</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>因子图应用于导航</title>
      <link href="/post/48469db3.html"/>
      <url>/post/48469db3.html</url>
      
        <content type="html"><![CDATA[<p>Reference:</p><ul><li><a href="https://longaspire.github.io/blog/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BB%8B%E7%BB%8D/#1-%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%AE%9A%E4%B9%89">因子图介绍</a></li><li><a href="https://www.zhangzhenhu.com/probability_model/9.%E5%92%8C%E7%A7%AF%E7%AE%97%E6%B3%95_lecture_8.html#fg-tree">和积算法</a></li><li><a href="https://blog.csdn.net/weixin_37781153/article/details/113739232">GTSAM库 学习二（创建一个简单因子图）</a></li><li><a href="https://mqshen.gitbooks.io/prml/content/Chapter8/inference/max_sum_algorithm.html">最大和积</a></li></ul><p>导航定位的本质：状态估计问题<br>常见求解方法</p><ul><li>递归式估计：Kalman滤波</li><li>批量式估计：图优化算法</li></ul><p>图优化实现形式：最优估计 -&gt; 最大后验估计 -&gt; 残差误差最小化</p><p>什么是图？图是由一系列顶点和若干连结顶点集合内两个顶点的边组成的数据结构。数学意义上的图，指的是由一系列点与边构成的集合，这里我们只考虑有限集。通常我们用G=(V,E)表示一个图结构，其中V表示点集，E表示边集。</p><p>首先讲优化。从直观上来说，就是沿着梯度下降的方向去找到使误差(代价函数)最小化的优化变量。非线性优化，自然就是误差函数和需要优化的变量之间不是简单的线性关系，而是非线性的。求解它常用的库有ceres。<br>再讲图优化。图优化的本质还是优化，只不过是用图的方式去表达。把优化变量当做顶点，约束当做边，也是用梯度下降的方法去使误差最小化。那图优化有什么好处呢？因为slam的特性，图是稀疏的，因此可以用图理论去进行边缘化，消元，加速计算。常用的库有g2o。再讲因子图优化。和前者不同的是，它的重点在因子图。它的优化落脚点不再是最小二乘理论了，而是最大后验概率理论了。其实常用库有gtsam位姿图优化和BA优化都是slam中的具体问题，可以用上述理论来解决。它们的不同点在于，ba优化中，路标点和位姿都是不确定的，都是优化变量。而位姿图优化，假设路标点是确定的，优化变量只有位姿，路标点成了约束<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><p>在概率图中，求某个变量的边缘分布是常见的问题。这问题有很多求解方法，其中之一就是把贝叶斯网络或马尔科夫随机场转换成因子图，然后用sum-product算法求解。换言之，基于因子图可以用sum-product算法（也称为信念传播算法）高效的求各个变量的边缘分布<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</p><p>将一个具有多变量的全局函数因子分解，得到几个局部函数的乘积，以此为基础得到的一个双向图叫做因子图（Factor Graph）。</p><p>对于函数$g(X1,…,Xn)$，有以下式子成立：</p><blockquote><p>$g(X_1, \ldots, X_n) = \prod_{j=1}^{m}f_{j}(S_j)$.  其中，$S_j \subseteq { X_1, \ldots, X_n }$</p></blockquote><ul><li><p>$X = { X_1, \ldots, X_n }$ 变量结点（variable vertices）</p></li><li><p>$F = {f_1, \ldots, f_m }$ 表示因子结点（factor vertices）</p></li><li><p>$E$ 为边的集合，如果某一个变量结点 $X_k$ 被因子结点 $f_j$ 的集合 $S_j$ 包含，那么就可以在 $X_k$ 和 $f_j$ 之间加入一条无向边。</p></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>现在有一个全局函数$g(x_1, \cdots, x_5)$，其因式分解方程为:</p><script type="math/tex; mode=display">g(x_1, x_2, x_3, x_4, x_5) = f_A(x_1)f_B(x_2)f_C(x_1, x_2, x_3)f_D(x_3, x_4)f_E(x_3, x_5)</script><p>​    其中，各函数表述变量间的关系，可以是条件概率或者其他关系（例如在马尔科夫随机场中的势函数）。</p><p>则其对应的因子图如下图所示。</p><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/fg_1.png" style="zoom:75%;" alt="因子图示例"/></p><p>也可以等价于：</p><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/fg_2.png" alt="因子图示例"></p><p>在因子图中，所有的顶点不是变量结点就是因子结点，边表示它们之间的函数关系。</p><h2 id="3-有向图、无向图和条件随机场"><a href="#3-有向图、无向图和条件随机场" class="headerlink" title="3. 有向图、无向图和条件随机场"></a>3. 有向图、无向图和条件随机场</h2><p>接下来，我们再来了解一下概率图模型中的有向图、无向图，及其其对应的各类模型结构。</p><ul><li>有向图模型，又称作贝叶斯网络（Directed Graphical Models, DGM, Bayesian Network）</li></ul><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/begin/dgm.png" alt="贝叶斯网络的有向图模型"></p><ul><li>但在某些情况下，强制加入结点的边方向是不合适。无向图模型（Undirected Graphical Model, UGM），又称作马尔科夫随机场或者马尔科夫网络（Markov Random Field, MRF or Markov Network）</li></ul><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/begin/ugm.png" alt="马尔科夫随机场的无向图模型"></p><ul><li>设$X=(X_1,…,X_n)$和$_Y=(Y_1,…,Y_m)$都是联合随机变量，若随机变量$Y$构成一个无向图$G=(V,E)$表示的马尔科夫随机场，则条件概率分布$P(Y∣X)$称之为条件随机场（Conditional Random Field, CRF）。</li></ul><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/begin/crf.png" alt="线性链条件随机场的无向图模型"></p><h2 id="4-因子图的转换"><a href="#4-因子图的转换" class="headerlink" title="4. 因子图的转换"></a>4. 因子图的转换</h2><h4 id="4-1-贝叶斯网络示例"><a href="#4-1-贝叶斯网络示例" class="headerlink" title="4.1 贝叶斯网络示例"></a>4.1 贝叶斯网络示例</h4><p>给出上面图中的贝叶斯网络，根据各个变量间的关系，我们可以得到</p><blockquote><p> $p(u,w,x,y,z) = p(u)p(w)p(x \mid u,w)p(y \mid x)p(z \mid x)$</p></blockquote><p>表示为因子图，以下两种形式皆可：</p><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/begin/factor_graph_ugm.png" alt="线性链条件随机场的无向图模型"></p><p>由上述例子总结出由贝叶斯网络构造因子图的方法：</p><ul><li>贝叶斯网络中的一个因子（可以理解为函数）对应因子图中的一个结点</li><li>贝叶斯网络中的每一个变量在因子图上对应边或者半边</li><li>结点$g$和边$x$相连当且仅当变量$x$出现在因子$g$中。</li></ul><h4 id="4-2-马尔科夫链示例"><a href="#4-2-马尔科夫链示例" class="headerlink" title="4.2 马尔科夫链示例"></a>4.2 马尔科夫链示例</h4><p>以下是一个马尔科夫链转换的示例：</p><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/begin/markov-chain.png" alt="线性链条件随机场的无向图模型"></p><p>其对应的全局函数可以表示为：</p><h4 id="4-3-隐马尔可夫模型示例"><a href="#4-3-隐马尔可夫模型示例" class="headerlink" title="4.3 隐马尔可夫模型示例"></a>4.3 隐马尔可夫模型示例</h4><p><img src="https://youpai.hanvon.top/blog/article/Learing/FG/begin/hmm.png" alt=""></p><p>其对应的全局函数可以表示为：</p><blockquote><p>$p(X_0, \ldots, X_n, Y_1, \ldots, Y_n) = p(X_0)\prod_{k=1}^{n}p(X_k \mid X_{k-1})p(Y_{k} \mid X_{k-1})$</p></blockquote><h2 id="5-Sum-product算法"><a href="#5-Sum-product算法" class="headerlink" title="5. Sum-product算法"></a>5. Sum-product算法</h2><p>有了因子图，我们可以利用Sum-product算法，根据联合概率分布求出边缘概率分布（先验分布）。</p><h4 id="5-1-边缘概率的求解"><a href="#5-1-边缘概率的求解" class="headerlink" title="5.1 边缘概率的求解"></a>5.1 边缘概率的求解</h4><ul><li>联合概率表示两个事件共同发生的概率，如A和B共同发生的概率为$P(A \cap B)$</li><li>边缘概率是某个事件发生的概率<ul><li>边缘概率是通过边缘化（marginalization）得到的：在联合概率中，把最终结果中不需要的那些事件合并成其事件的全概率而消失（对离散随机变量用求和得全概率，对连续随机变量用积分得全概率）</li></ul></li></ul><p>某个随机变量$x_k$的边缘概率可由$x_1,…,x_n$的联合概率求得：</p><blockquote><p>fk¯(xk)=△∑x1,…,xn except xkf(x1,…,xn)</p><p>$\overline{f_k}(x_k) \overset{\triangle}{=} \sum\limits_{x_1, \ldots, x_n~\text{except}~x_k}f(x_1, \ldots, x_n)$</p></blockquote><p>假定现在我们需要计算如下式子的结果：</p><blockquote><p>$\overline{f_3}(x_3) \overset{\triangle}{=} \sum\limits_{x_1, \ldots, x_7~\text{except}~x_3}f(x_1, \ldots, x_7)$</p></blockquote><p>Ceres是图优化的求解器</p><p>因子图优化可以认为和图优化没区别，本质都是大规模稀疏最小二乘法。</p><p>ceres只是诸多求解器的一种</p><hr><p>卡尔曼滤波是单步最优因子图，图优化，把最优估计问题转化为贝叶斯网络的求解问题。突破了平滑和滤波的界限，是最优估计领域的深度学习技术。投身于这个技术吧 这是改变行业和世界的技术。现在是2018年，这个技术的状态，相当于2012年的深度学习，2011年的区块链</p><p>作者：图状态空间<br>链接：<a href="https://www.zhihu.com/question/48878602/answer/416034400">https://www.zhihu.com/question/48878602/answer/416034400</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><p>作者：图状态空间<br>链接：<a href="https://www.zhihu.com/question/54729486/answer/538203642">https://www.zhihu.com/question/54729486/answer/538203642</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>因子图是什么？gta和瑞士人的论文已经介绍的比较清楚了，就是一种矩阵和概率模型的组织方式。这方面的东西如果想深入研究，可以看gtsam和isam相关的文献。中文版的书籍因子图，翻译的是kaess和dellaert的论文，质量非常高，做到了信达雅。sum-product算法是从一组相关的概率密度分布中，把一个单点的概率分布 求出来的原理。当然，这个只是原理，具体要实现还是要靠因子图和稀疏矩阵的方法。HMM是一种模型，隐式马尔科夫模型。其原理是当前状态只与上一个时刻的状态相关。当然这种模型的应用非常多。卡尔曼滤波是一种算法，是传感器建模领域和自动控制领域的王者算法，穿越了摩尔定律的整个周期。因子图是一种更通用的计算语言，可以千变万化，可小至卡尔曼滤波，中至滑动窗口滤波，大到无线维度的isam。我们以最简单的卡尔曼滤波为例，说明因子图的情况。x0时刻的分布，记为factor 0x0到x1时刻的状态转移情况，可以用factor 1来表示。如果用c++实现，factor0 和factor1，都被push_back到用向量vector表示的因子图中。这个时候，如果是窗口滤波，可以继续pushback，直到窗的size，如果是isam则不停的push_back。而因子图的优势是，无论是数据压入多少维度，解法是一样的。他强任他强，数据多长我都是一招排山倒海。。</p><hr><hr><p>非线性优化，图优化，因子图优化是三种优化理论，类似于学习到的教程：<br>非线性优化，强推ceres库，对用户极其友好，文档和注释都很不错；<br>图优化，强推g2o，没文档，几乎没注释，如果能搞透对图优化理解肯定会深刻了；<br>因子图优化，强推gtsam，可以看看预积分那套理论并且实践下，对理解会有很大帮助。</p><p>位姿图优化和BA优化是具体的问题了，也就是说需要用上面学习到的教程来解决这些具体问题：<br>位姿图优化，只优化位姿，路标点只作为优化过程中的约束；<br>BA优化，联合优化位姿和路标点。</p><p>作者：祯卿<br>链接：<a href="https://www.zhihu.com/question/389810365/answer/1309412482">https://www.zhihu.com/question/389810365/answer/1309412482</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><hr><p>$p\left(x_{1}, \ldots, x_{N}\right)=\frac{1}{Z} \prod_{j=1}^{m} f_{j}\left(x_{f_{j}}\right)$</p><blockquote id="fn_1"><sup>1</sup>. <a href="https://longaspire.github.io/blog/因子图介绍/#fn:2">因子图介绍</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://www.zhihu.com/question/389810365/answer/1305885746">图优化</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="/post/b654ab75.html"/>
      <url>/post/b654ab75.html</url>
      
        <content type="html"><![CDATA[<p>References:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/649997859">深入浅出理解卡尔曼滤波【实例、公式、代码和图】</a></li><li><a href="https://www.fenice.website/archives/1167">卡尔曼滤波器(Kalman Filter)深入推导与理解</a></li><li><a href="https://blog.csdn.net/seek97/article/details/120012667">Kalman滤波通俗理解+实际应用</a></li><li><a href="https://www.kalmanfilter.net/CN/kalman1d_cn.html">Kalman Filter ebook</a></li><li><a href="https://www.bilibili.com/video/BV1ez4y1X7eR?spm_id_from=333.788.videopod.sections&amp;vd_source=63de1b1e9e25f267eb0d507ac3a22607">DR_CAN 卡尔曼滤波器</a></li></ul><blockquote><p>卡尔曼滤波，本质上是一种<strong>最优</strong>的<strong>递归</strong>的数字处理算法。卡尔曼滤波器的应用非常广泛，这是因为在实际的系统当中，存在许多的不确定性，主要包含以下三个方面：<br>    ① 不存在完美的数学模型<br>    ② 系统的扰动不可控，也很难建模<br>    ③ 测量传感器存在误差</p></blockquote><h1 id="KF"><a href="#KF" class="headerlink" title="KF"></a>KF</h1><h2 id="卡尔曼滤波原理介绍"><a href="#卡尔曼滤波原理介绍" class="headerlink" title="卡尔曼滤波原理介绍"></a>卡尔曼滤波原理介绍</h2><p>假设我们要研究的对象是一个房间的温度。根据经验判断,这个房间的温度大概在25℃左右,可能受空气流通、阳光等因素影响,房间内温度会小幅度地波动。我们以分钟为单位,定时测量房间温度,这里的1分钟,可以理解为采样时间。假设测量温度时,外界的天气是多云,阳光照射时有时无,同时房间不是100%密封的,可能有微小的与外界空气的交换,即引入过程噪声$W(k)$,其方差为$Q$,大小假定为$Q=0.01$(假如不考虑过程噪声的影响,即真实温度是恒定的,那么这时候$Q=0$)。相应地, $A=1$, $F=1$, $Q=0.01$, 状态X(k)是在第k分钟时的房间温度,是一维的。那么该系统的状态方程可以写为: $X(k)=X(k-1)+W(k)$</p><p>现在用温度计开始测量房间的温度,假设温度计的测量误差为±0.5℃,从出厂说明书上我们得知该温度计的方差为0.25。也就是说,温度计第k次测量的数据不是100%准确的,它是有测量噪声V(k)的,并且其方差$R=0.25$,因此测量方程为$Z(k)=X(k)+V(k)$。<br>该系统的状态和观测方程为</p><blockquote><p>$X(k)=AX(k-1)+W(k-1)$<br>$Z(k)=HX(k)+V(k)$</p></blockquote><p>式中,$X(k)$是一维变量温度; $A=1$; $F=1$; $H=1$; $W(k)$和$V(k)$的方差为$Q$和$R$。</p><p>模型建好以后,就可以利用 Kalman滤波了。假如要估算第k时刻的实际温度值,首先要根据第$k-1$时刻的温度值来预测k时刻的温度。<br>    (1)假定第k-1时刻的温度值测量值为23.9℃,房间真实温度为24.0℃,该<br>测量值的偏差是0.1℃,即协方差$P(k-1)=0.1^2$。<br>    (2)在第k时刻,房间的真实温度是24.1℃,温度计在该时刻测量的值为<br>24.5℃,偏差为0.4℃。我们用于估算第k时刻的温度有两个温度值,分别是k-1时刻23.9℃和k时刻的24.5℃,如何融合这两组数据,得到最逼近真实值的估计?<br>首先,利用k1时刻温度值预测第k时刻的温度,其预计偏差为$P(k|k-1)=P(k-1)+Q=0.02$,计算 Kalman增益<br>$K=P(k|k-1)/(P(k|k-1)+R)=00741$,那么这时候利用$k$时刻的观测值,得到温度的估计值为$X(k)=23.9+0.0741×(24.1-23.9)=23.915℃$。可见,与23.9℃和24.5℃相比较, Kalman估计值23.915℃更接近真实值24.1℃。此时更新k时刻的偏差$P(k)=(1-K*H)P(k|k-1)=0.0186$。最后由$X(k)=23.915℃$和$P(k)=0.0186$,可以继续对下一时刻观测数据$Z(k+1)$进行更新和处理。<br>    (3)这样, Kalman滤波器就不断地把方差递归，从而估算出最优的温度值。$X(0)$和$P(0)$分别为滤波器初始值。</p><h2 id="MATLAB仿真程序"><a href="#MATLAB仿真程序" class="headerlink" title="MATLAB仿真程序"></a>MATLAB仿真程序</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 程序说明：Kalman滤波用于一维温度测量的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Kalman_main</span></span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">N=<span class="number">120</span>;<span class="comment">%采样点个数，时间单位为分钟</span></span><br><span class="line">CON=<span class="number">25</span>;<span class="comment">%室内温度理论值，房间温度在25摄氏度左右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%对状态和测量初始化</span></span><br><span class="line">Xexpect=CON*<span class="built_in">ones</span>(<span class="number">1</span>,N);<span class="comment">%期望温度是25摄氏度，但会收到噪声影响</span></span><br><span class="line">X=<span class="built_in">zeros</span>(<span class="number">1</span>,N);  <span class="comment">%房间各时刻真实温度值</span></span><br><span class="line">Xkf=<span class="built_in">zeros</span>(<span class="number">1</span>,N); <span class="comment">%估计值</span></span><br><span class="line">Z=<span class="built_in">zeros</span>(<span class="number">1</span>,N);  <span class="comment">%温度计测量值</span></span><br><span class="line">P=<span class="built_in">zeros</span>(<span class="number">1</span>,N); </span><br><span class="line"></span><br><span class="line"><span class="comment">%初始化</span></span><br><span class="line">X(<span class="number">1</span>)=<span class="number">25.1</span>;</span><br><span class="line">P(<span class="number">1</span>)=<span class="number">0.01</span>;<span class="comment">%初始化协方差</span></span><br><span class="line">Z(<span class="number">1</span>)=<span class="number">24.9</span>;</span><br><span class="line">Xkf(<span class="number">1</span>)=Z(<span class="number">1</span>);<span class="comment">%初始化测量值24.9，可作为滤波器的初始估计状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%噪声</span></span><br><span class="line">Q=<span class="number">0.01</span>;<span class="comment">%W(k)的方差</span></span><br><span class="line">R=<span class="number">0.25</span>;<span class="comment">%V(k)的方差</span></span><br><span class="line">W=<span class="built_in">sqrt</span>(Q)*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line">V=<span class="built_in">sqrt</span>(R)*<span class="built_in">randn</span>(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line"><span class="comment">%系统矩阵</span></span><br><span class="line">F=<span class="number">1</span>;</span><br><span class="line">G=<span class="number">1</span>;</span><br><span class="line">H=<span class="number">1</span>;</span><br><span class="line">I=<span class="built_in">eye</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%模拟房间温度和测量过程，并滤波</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">2</span>:N</span><br><span class="line">    <span class="comment">%第一步：随时间推移，房间真实温度波动变化</span></span><br><span class="line">    X(k)=F*X(k<span class="number">-1</span>)+G*W(k<span class="number">-1</span>);  <span class="comment">%状态方程</span></span><br><span class="line">    <span class="comment">%第二步：随时间推移，获取实时数据</span></span><br><span class="line">    Z(k)=H*X(k)+V(k); <span class="comment">%观测方程</span></span><br><span class="line">    <span class="comment">%第三步：Kalman滤波</span></span><br><span class="line">    X_pre=F*Xkf(k<span class="number">-1</span>);  <span class="comment">%状态估计         </span></span><br><span class="line">    P_pre=F*P(k<span class="number">-1</span>)*F&#x27;+Q; <span class="comment">%协方差预测       </span></span><br><span class="line">    Kg=P_pre*inv(H*P_pre*H&#x27;+R); <span class="comment">%kalman增益</span></span><br><span class="line">    e=Z(k)-H*X_pre;      <span class="comment">%新息      </span></span><br><span class="line">    Xkf(k)=X_pre+Kg*e;   <span class="comment">%状态更新 </span></span><br><span class="line">    P(k)=(I-Kg*H)*P_pre; <span class="comment">%协方差更新</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%计算误差</span></span><br><span class="line">Err_Messure=<span class="built_in">zeros</span>(<span class="number">1</span>,N);<span class="comment">%量测值与真实值的误差</span></span><br><span class="line">Err_Kalman=<span class="built_in">zeros</span>(<span class="number">1</span>,N);<span class="comment">%估计与真实值的偏差</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:N</span><br><span class="line">    Err_Messure(k)=<span class="built_in">abs</span>(Z(k)-X(k));</span><br><span class="line">    Err_Kalman(k)=<span class="built_in">abs</span>(Xkf(k)-X(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">t=<span class="number">1</span>:N;</span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Kalman Filter Simulation&#x27;</span>,<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line"><span class="comment">%一次画出理论值、真实值、测量值、估计值</span></span><br><span class="line"><span class="built_in">plot</span>(t,Xexpect,<span class="string">&#x27;-b&#x27;</span>,t,X,<span class="string">&#x27;-r&#x27;</span>,t,Z,<span class="string">&#x27;-k&#x27;</span>,t,Xkf,<span class="string">&#x27;-g&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;expected&#x27;</span>,<span class="string">&#x27;real&#x27;</span>,<span class="string">&#x27;measure&#x27;</span>,<span class="string">&#x27;kalman extimate&#x27;</span>);         </span><br><span class="line">xlabel(<span class="string">&#x27;sample time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;temperature&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Kalman Filter Simulation&#x27;</span>);</span><br><span class="line"><span class="comment">%误差分析</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Error Analysis&#x27;</span>,<span class="string">&#x27;NumberTitle&#x27;</span>,<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,Err_Messure,<span class="string">&#x27;-b&#x27;</span>,t,Err_Kalman,<span class="string">&#x27;-k&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;messure error&#x27;</span>,<span class="string">&#x27;kalman error&#x27;</span>);         </span><br><span class="line">xlabel(<span class="string">&#x27;sample time&#x27;</span>);</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="kalman滤波算法特点"><a href="#kalman滤波算法特点" class="headerlink" title="kalman滤波算法特点"></a>kalman滤波算法特点</h2><p>　　（1）由于kalman滤波算法是将被估计信号看作在白噪声作用下一个随机线性系统的输出，并且它的输入/输出是由状态方程和输出方程在时间域上给出的，因此这种滤波方法不仅适用于平稳随机过程的滤波，而且特别适用于非平稳或平稳马尔科夫序列或高斯-马尔科夫序列的滤波，因此应用范围非常广泛。</p><p>　　（2）kalman滤波算法是一种时间域滤波方法，采用状态空间描述系统。系统的过程噪声和量测噪声不是需要滤除的对象，他们的统计特性正是估计过程中要用到的信息，而被估计量和观测量在不同时刻的一、二阶矩是不需要知道的。</p><p>　　（3）由于kalman滤波的基本方程是时间域内的递推形式，其计算过程是一个不断“预测-修正”的过程，在求解时不需要存储大量数据，同时一旦观测到新的数据，便可以算得新的滤波值，因此这种滤波方法非常适用于实时处理、计算机实现。</p><p>　　（4）由于滤波器的增益矩阵与观测无关，因此它可预先离线算出，从而可以减少实时计算量。求滤波器增益矩阵时，要求一个矩阵的逆，它的阶数只是取决于观测方程的维数，而该维数通常很小，因此求逆运算是比较方便的。另外，在求解滤波器增益的过程中，随时可以算得滤波器的精度指标P，其对角线上的元素就是滤波误差向量各个分量的方差。</p><hr><hr><h1 id="EKF"><a href="#EKF" class="headerlink" title="EKF"></a>EKF</h1><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>　　kalman滤波能够在线性高斯模型的条件下，对目标的状态做出最优的估计，可以有一个较好的跟踪效果。但是，在实际应用中往往会有很多不同程度的非线性，其中非线性函数比较典型的几个分别是平方、对数、指数、三角函数等，有些非线性系统可以近似看成线性系统，但为了精确估计系统的状态，大多数系统不能仅用线性微分来描述。例如飞机的飞行、导弹的制导等，其中的非线性因素不能忽略，必须建立适用于非线性系统的滤波算法。</p><p>　　对于非线性系统的滤波问题，最常用的方法是利用现行换技巧将其转化为一个近似的线性滤波问题，其中最广泛的方法是扩展kalman滤波方法（Extended kalman Filter , EKF）。扩展kalman滤波建立在线性kalman滤波的基础上，它的核心思想就是，对与一般的非线性系统，首先围绕滤波值将非线性函数f(<em>)和h(</em>)展开成泰勒级数，然后省略二阶及以上的项，得到一个近似的线性化模型，然后再用kalman滤波完成对目标的滤波估计等处理。</p><p>　　EKF的优点在于不用预先计算过程噪声W(k)和量测噪声V(k)均为零的时候的解，但它只能在滤波误差以及一步预测误差比较小的时候才能用。</p><h2 id="EKF算法步骤"><a href="#EKF算法步骤" class="headerlink" title="EKF算法步骤"></a>EKF算法步骤</h2><hr><hr><h1 id="UKF"><a href="#UKF" class="headerlink" title="UKF"></a>UKF</h1><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p><img src="https://youpai.hanvon.top/blog/article/Navigation/XKF/UKF/UKF%20vs.%20EKF%20illustration.png" alt="UKF_illustration.png"></p><p>无迹卡尔曼滤波（UKF）</p><p>　　第二部分讨论的扩展kalman滤波算法是对非线性的系统方程或者观测方程进行泰勒展开并保留其中一阶近似项，这样不可避免地引入了线性化误差。如果线性化假设不成立，采用这种算法则会导致滤波器性能下降以至于造成发散。如果线性化假设不成立，采用这种算法则会导致滤波器性能下降以至于造成发散。另外，在一般情况下计算系统状态方程和观测方程的jacobian矩阵是不易实现的，增加了算法的计算复杂度。</p><p>　　无迹卡尔曼滤波（Unscented Kalman Filter，UKF）摒弃了对非线性函数进行线性化的传统做法，采用kalman线性滤波框架，对用于预测方程，使用无迹变换（Unscented Transform,UT）来处理均值和协方差的非线性传递问题。UKF算法是对非线性函数的概率密度分布进行了近似，用一系列确定样本来逼近状态的后验概率密度，而不是对非线性函数进行近似，不需要对雅可比矩阵进行求导。同时，UKF没有把高阶项忽略，因此对于非线性分布的统计量有较高的计算精度，有效地克服了EKF的估计精度低、稳定性差的问题。</p><p>卡尔曼滤波需要线性模型，需要通过泰勒展开来完成局部线性化便可以实现 EKF，但是是否存在线性化的更好的方法，在文中，我们将引入无迹变换，随后探讨无迹卡尔曼滤波器。</p><ul><li>泰勒展开是通过泰勒展开对非线性函数进行线性化</li><li>无迹变换是计算一系列点（关键点，Sigma Point），然后通过非线性函数进行变换，通过变换结果和对应的权重来计算高斯分布</li></ul><p>接下来我们需要考虑两个问题：</p><ul><li>如何选择Sigma 点</li><li>如何设置对应的权重</li></ul><p>需要满足以下条件，但是满足以下条件的解很多。</p><script type="math/tex; mode=display">\begin{aligned}&\sum^iw^{[i]}=1 \\&\mu=\sum_{i}w^{[i]}\mathcal{X}^{[i]} \\&\Sigma=\sum_{i}w^{[i]}(\mathcal{X}^{[i]}-\mu)(\mathcal{X}^{[i]}-\mu)^{T}\end{aligned}</script><p>可以根据经验，我们按照以下规则选择 Sigma 点  </p><script type="math/tex; mode=display">\begin{aligned}&\chi[0] =\mu  \\&\chi[i] =\mu+\left(\sqrt{(n+\lambda)\Sigma}\right)_i\quad for i= 1,\ldots n \\&\chi[i] =\mu-\left(\sqrt{(n+\lambda)\Sigma}\right)_{i-n}\quad for i= n+1,\ldots2n \end{aligned}</script><h3 id="矩阵平方根"><a href="#矩阵平方根" class="headerlink" title="矩阵平方根"></a>矩阵平方根</h3><p>为了求解上述Sigma 点，我们需要对矩阵进行平方根的求解，我们定义矩阵 $S$ ，满足 $Σ=S^TS$ ，按照对角化原则</p><script type="math/tex; mode=display">\begin{aligned}\sum& =VDV^{-1} \\&=V\begin{pmatrix}d11&\cdots&0\\\\0&\ddots&0\\\\0&\ddots&dnn\end{pmatrix}V^{-1} \\&=V\begin{pmatrix}\sqrt{d11}&\cdots&0\\\\0&\ddots&0\\\\0&\ddots&\sqrt{dnn}\end{pmatrix}\begin{pmatrix}\sqrt{d11}&\cdots&0\\\\0&\ddots&0\\\\0&\ddots&\sqrt{dnn}\end{pmatrix}V^{-1} \\&  \end{aligned}</script><script type="math/tex; mode=display">S=V\underbrace{\left(\begin{array}{ccc}{\sqrt{d11}}&{\cdots}&{0}\\{0}&{\ddots}&{0}\\{0}&{\ddots}&{\sqrt{dnn}}\end{array}\right)}_{D^{1/2}}V^{-1}</script><h3 id="Cholesky分解"><a href="#Cholesky分解" class="headerlink" title="Cholesky分解"></a>Cholesky分解</h3><p>定义下三角矩阵 $L $满足 $Σ=LL^T$ ，该方法能够提供稳定的数值解，经常在UKF应用中使用， $L$ 和 $Σ$ 拥有相同的特征值。Sigma 点可以但不必须位于协方差的主轴上。 </p><h3 id="Sigma点权重"><a href="#Sigma点权重" class="headerlink" title="Sigma点权重"></a>Sigma点权重</h3><p> $w_{m}^{[i]}$ 用于计算均值， $w_{c}^{[i]}$ 用于计算协方差</p><script type="math/tex; mode=display">\begin{aligned}&w_{m}^{[0]}=\frac\lambda{n+\lambda}\\&w_{c}^{[0]}=w_m^{[0]}+(1-\alpha^2+\beta)\\&w_{m}^{[i]}=w_c^{[i]}=\frac\lambda{2(n+\lambda)} for i=1,\ldots,2n\end{aligned}</script><p>接下来，对计算出来的Sigma 点的映射值，做高斯估计</p><script type="math/tex; mode=display">\begin{aligned}&\mu^{\prime}=\sum_iw_m^{[i]}\mathcal{X}^{[i]}\\&\Sigma^{\prime}=\sum_{i=0}^{2n}w_c^{[i]}(\mathcal{X}^{[i]}-\mu^{\prime})(\mathcal{X}^{[i]}-\mu^{\prime})^T\end{aligned}</script><h2 id="UKF-Algorithm-Prediction"><a href="#UKF-Algorithm-Prediction" class="headerlink" title="UKF Algorithm - Prediction"></a>UKF Algorithm - Prediction</h2><ol><li>$\text{Unscented Kalman filter} (\mu_{t-1},\Sigma_{t-1},u_t,z_t){:}$</li><li>$\mathcal{X}_{t-1}=(\mu_{t-1}\quad\mu_{t-1}+\sqrt{(n+\lambda)\Sigma_{t-1}}\quad\mu_{t-1}-\sqrt{(n+\lambda)\Sigma_{t-1}})$</li><li>$\bar{\mathcal{X}}_{t}^{*}=g (u_{t},\mathcal{X}_{t-1})$</li><li>$\bar{\mu}_{t}=\sum_{i=0}^{2n}w_{m}^{[i]}\bar{\mathcal X}_{t}^{*[i]}$ </li><li>$\bar{\Sigma}_{t}=\sum_{i=0}^{2n}w_{c}^{[i]}(\bar{\mathcal{X}}_{t}^{\ast[i]}-\bar{\mu}_{t})(\bar{\mathcal{X}}_{t}^{\ast[i]}-\bar{\mu}_{t})^{T}+R_{t}$</li><li>$\bar{\mathcal{X}}_{t}=(\bar{\mu}_{t}\quad\bar{\mu}_{t}+\sqrt{(n+\lambda)\bar{\Sigma}_{t}}\quad\bar{\mu}_{t}-\sqrt{(n+\lambda)\bar{\Sigma}_{t}})$</li><li>$\bar{\mathcal Z}_{t}=h (\bar{\mathcal X}_{t})$</li><li>$\hat{z}_{t}=\sum_{i=0}^{2n}w_{m}^{[i]}\bar{\mathcal Z}_{t}^{[i]}$</li><li>$S_{t}=\sum_{i=0}^{2n}w_{c}^{[i]}(\bar{\mathcal{Z}}_{t}^{[i]}-\hat{z}_{t})(\bar{\mathcal{Z}}_{t}^{[i]}-\hat{z}_{t})^{T}+Q_{t}$</li><li>$\bar{\Sigma}_{t}^{x, z}=\sum_{i=0}^{2n}w_{c}^{[i]}(\bar{\mathcal X}_{t}^{[i]}-\bar{\mu}_{t})(\bar{\mathcal Z}_{t}^{[i]}-\hat{z}_{t})^{T}$</li><li>$K_{t}=\bar{\Sigma}_{t}^{x, z} S_{t}^{-1}$</li><li>$\mu_{t}=\bar{\mu}_{t}+K_{t}(z_{t}-\hat{z}_{t})$</li><li>$\Sigma_{t}=\bar{\Sigma}_{t}-K_{t} S_{t} K_{t}^{T}$</li><li>$\text{return} ~ \mu_{t},\Sigma_{t}$</li></ol><script type="math/tex; mode=display">\begin{aligned}\Sigma_{t}& =\left(I-K_{t}H_{t}\right)\bar{\Sigma}_{t} \\&=\bar{\Sigma}_t-K_tH_t\bar{\Sigma}_t \\&=\bar{\Sigma}_t-K_t\left(\bar{\Sigma}^{x,z}\right)^T \\&=\bar{\Sigma}_t-K_t\left(\bar{\Sigma}^{x,z}S_t^{-1}S_t\right)^T \\&=\bar{\Sigma}_t-K_t(K_tS_t)^T \\&=\bar{\Sigma}_t-K_tS_t^TK_t^T \\&=\bar{\Sigma}_t-K_tS_tK_t^T\end{aligned}</script><ul><li>无迹变换是线性化的另一种方式</li><li>无迹变换的拟合效果比泰勒分布更好</li><li>无迹变换使用的是Sigma点传播</li><li>无迹变换存在自由参数</li><li>无迹卡尔曼滤波在预测和更新步使用无迹变换</li></ul><h2 id="UKF-vs-EKF"><a href="#UKF-vs-EKF" class="headerlink" title="UKF vs. EKF"></a>UKF vs. EKF</h2><ul><li>如果是线性模型，则两者结果相同</li><li>如果是非线性模型，则UKF结果比EKF好</li><li>两者差异很小</li><li>UKF不需要计算雅可比</li><li>复杂度在同一级别</li><li>UKF比EKF稍慢</li><li>依然受限于高斯分布</li></ul><hr><p>参考：</p><p><a href="https://ethw.org/First-Hand:The_Unscented_Transform">一手资料：无迹变换</a></p><p><a href="https://zhuanlan.zhihu.com/p/399370551">https://zhuanlan.zhihu.com/p/399370551</a></p><p><a href="https://zhuanlan.zhihu.com/p/482392082">无迹卡尔曼滤波UKF的理解与应用（附Matlab实例）</a></p><p>TEST:</p><p>$\lim_{h \rightarrow 0 } \frac{f(x+h)-f(x)}{h}$</p><hr><hr><h1 id="IMM"><a href="#IMM" class="headerlink" title="IMM"></a>IMM</h1><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><p>　　在kalman滤波算法中用到了状态转移方程和量测方程，被估计量随着时间的变化，呈现的是一个动态估计。在目标跟踪中，不需要知道目标的运动模型就能实时的修正目标的状态变量（速度、距离等），具有良好的适应性。但是当目标实施机动变化（突然加、减速或急转弯等），仅仅采用基本的kalman滤波算法往往得不到理想的结果。这时就需要采用自适应算法。交互多模型（IMM）就应用而生。</p><p>　　目标交互多模型kalman滤波算法在机动目标跟踪领域得到广泛应用。IMM算法使用两个或者多个模型来描述工作过程中可能出现的状态，最后通过有效的加权融合进行系统状态估计，很好的克服了单个模型估计误差较大的问题。</p><hr><hr><p><a href="https://www.cnblogs.com/randwalker/p/17950354">PSINS工具箱卡尔曼滤波器</a></p><p>(卡尔曼滤波算法综述（KF、EKF、UKF和IMM）)[<a href="https://www.cnblogs.com/sbb-first-blog/p/17178998.html">https://www.cnblogs.com/sbb-first-blog/p/17178998.html</a>]</p><p><a href="https://www.cnblogs.com/milton/p/18038841">https://www.cnblogs.com/milton/p/18038841</a></p><p>四、优秀解释<br>无人驾驶技术入门（十八）| 手把手教你写扩展卡尔曼滤波器：<a href="https://zhuanlan.zhihu.com/p/63641680">https://zhuanlan.zhihu.com/p/63641680</a></p><p>动手算一算温度</p><p><a href="https://zhuanlan.zhihu.com/p/93011093">https://zhuanlan.zhihu.com/p/93011093</a></p><p>卡尔曼滤波示例</p><p><a href="https://zhuanlan.zhihu.com/p/29191795">https://zhuanlan.zhihu.com/p/29191795</a></p><p>卡尔曼滤波：从入门到精通</p><p><a href="https://zhuanlan.zhihu.com/p/36745755">https://zhuanlan.zhihu.com/p/36745755</a></p><p>卡尔曼滤波中关键参数的调整</p><p><a href="https://zhuanlan.zhihu.com/p/37750839">https://zhuanlan.zhihu.com/p/37750839</a></p><p>一文理清卡尔曼滤波，从传感器数据融合开始谈起</p><p><a href="https://zhuanlan.zhihu.com/p/158737818">https://zhuanlan.zhihu.com/p/158737818</a></p><p>自动驾驶基础技术(七)-无迹卡尔曼滤波Unscented Kalman Filter</p><p><a href="https://zhuanlan.zhihu.com/p/89835447">https://zhuanlan.zhihu.com/p/89835447</a></p><p>扩展卡尔曼滤波参数估计实例解析</p><p><a href="https://zhuanlan.zhihu.com/p/206664475">https://zhuanlan.zhihu.com/p/206664475</a></p><p>自动驾驶中无迹卡尔曼滤波器的应用（Unscented-Kalman-Filter）</p><p><a href="https://blog.csdn.net/weixin_42737442/article/details/105281671">https://blog.csdn.net/weixin_42737442/article/details/105281671</a></p><p>卡尔曼滤波及UKF原理与应用</p><p><a href="https://blog.csdn.net/light169/article/details/107183461/">https://blog.csdn.net/light169/article/details/107183461/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> XKF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读论文</title>
      <link href="/post/a7838e86.html"/>
      <url>/post/a7838e86.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>you are supercalifragilisticexpialidocious!</p></blockquote><h1 id="因子图-协同导航"><a href="#因子图-协同导航" class="headerlink" title="因子图 || 协同导航"></a>因子图 || 协同导航</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url: https://ar5iv.labs.arxiv.org/html/2107.01602?_immersive_translate_auto_translate=1</span><br><span class="line">title: &quot;Graphical State Space Model&quot;</span><br><span class="line">description: &quot;In this paper, a new framework, named as graphical state space model, is proposedfor the real time optimal estimation of one kind of nonlinear state space model.By discretizing this kind of system model as anequatio…&quot;</span><br><span class="line">host: ar5iv.labs.arxiv.org</span><br><span class="line">image: https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png</span><br></pre></td></tr></table></figure><p><a href="https://github.com/shaolinbit/GraphicalStateSpaceModel">开源地址</a></p><p>This is an test of HTML in Markdown:</p>  <p><a href="https://ieeexplore.ieee.org/abstract/document/8879513">链接</a></p><hr><p>基于因子图和最大熵的多AUV协同定位<br><a href="https://ieeexplore.ieee.org/abstract/document/8879513">Cooperative Positioning for Multi-AUVs Based on Factor Graph and Maximum Correntropy</a></p><hr><p>基于改进因子图和和积理论的多AUV先进协同定位算法<br><a href="https://ieeexplore.ieee.org/abstract/document/8721136">An Advanced Cooperative Positioning Algorithm Based on Improved Factor Graph and Sum-Product Theory for Multiple AUVs</a></p><hr><p>基于因子图的AUV协同导航算法<br><a href="https://ieeexplore.ieee.org/document/8832848">AUV cooperative navigation algorithm based on factor graph</a></p><hr><p>使用拓扑因子图进行船舶和水下航行器协同定位<br><a href="https://ieeexplore.ieee.org/document/8604649">Vessel and Underwater Vehicles Cooperative Localization using Topology Factor Graphs</a></p><hr><p>基于异步相对观测的多自主水下航行器协同定位<br><a href="https://ieeexplore.ieee.org/document/9447619">Multiple Autonomous Underwater Vehicles Cooperative Localization Based on Asynchronous Relative Observation</a></p><hr><p>使用多个自主水下航行器的协作定位和未知现状估计<br><a href="https://ieeexplore.ieee.org/document/8989996">Cooperative Localization and Unknown Currents Estimation Using Multiple Autonomous Underwater Vehicles</a></p><hr><p><a href="https://ieeexplore.ieee.org/document/910572/citations?tabFilter=papers#citations">Factor graphs and the sum-product algorithm</a></p><hr><p>基于模型的信号处理的因子图方法<br><a href="https://ieeexplore.ieee.org/document/4282128/citations#citations">The Factor Graph Approach to Model-Based Signal Processing</a></p><h1 id="数据融合-多传感器融合"><a href="#数据融合-多传感器融合" class="headerlink" title="数据融合 || 多传感器融合"></a>数据融合 || 多传感器融合</h1><hr><p>通过因子图和变分贝叶斯推理实现稳健的多传感器融合<br><a href="https://link.springer.com/chapter/10.1007/978-981-99-0479-2_2#Sec2">Robust Multi-sensor Fusion via Factor Graph and Variational Bayesian Inference</a></p><hr><h1 id="SLAM相关"><a href="#SLAM相关" class="headerlink" title="SLAM相关"></a>SLAM相关</h1><h2 id="未整理↓"><a href="#未整理↓" class="headerlink" title="未整理↓"></a>未整理↓</h2><p><a href="https://arxiv.org/abs/1502.00956">ORB-SLAM: a Versatile and Accurate Monocular SLAM System</a></p><p><a href="https://ar5iv.labs.arxiv.org/html/1502.00956?_immersive_translate_auto_translate=1">ORB-SLAM：多功能且精确的单目SLAM系统</a></p><hr><h5 id="ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras"><a href="#ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras" class="headerlink" title="ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras"></a><a href="https://arxiv.org/abs/1610.06475">ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras</a></h5><h5 id="ORB-SLAM2：用于单目、立体和-RGB-D-相机的开源-SLAM-系统"><a href="#ORB-SLAM2：用于单目、立体和-RGB-D-相机的开源-SLAM-系统" class="headerlink" title="ORB-SLAM2：用于单目、立体和 RGB-D 相机的开源 SLAM 系统"></a><a href="https://ar5iv.labs.arxiv.org/html/1610.06475?_immersive_translate_auto_translate=1">ORB-SLAM2：用于单目、立体和 RGB-D 相机的开源 SLAM 系统</a></h5><hr><h5 id="ORB-SLAM3-An-Accurate-Open-Source-Library-for-Visual-Visual-Inertial-and-Multi-Map-SLAM"><a href="#ORB-SLAM3-An-Accurate-Open-Source-Library-for-Visual-Visual-Inertial-and-Multi-Map-SLAM" class="headerlink" title="ORB-SLAM3: An Accurate Open-Source Library for Visual, Visual-Inertial and Multi-Map SLAM"></a><a href="https://arxiv.org/abs/2007.11898">ORB-SLAM3: An Accurate Open-Source Library for Visual, Visual-Inertial and Multi-Map SLAM</a></h5><h5 id="ORB-SLAM3：用于视觉、视觉惯性和多地图-SLAM-的精确开源库"><a href="#ORB-SLAM3：用于视觉、视觉惯性和多地图-SLAM-的精确开源库" class="headerlink" title="ORB-SLAM3：用于视觉、视觉惯性和多地图 SLAM 的精确开源库"></a><a href="https://ar5iv.labs.arxiv.org/html/2007.11898?_immersive_translate_auto_translate=1">ORB-SLAM3：用于视觉、视觉惯性和多地图 SLAM 的精确开源库</a></h5><hr><h5 id="A-Survey-on-Deep-Learning-for-Localization-and-Mapping-Towards-the-Age-of-Spatial-Machine-Intelligence"><a href="#A-Survey-on-Deep-Learning-for-Localization-and-Mapping-Towards-the-Age-of-Spatial-Machine-Intelligence" class="headerlink" title="A Survey on Deep Learning for Localization and Mapping: Towards the Age of Spatial Machine Intelligence"></a><a href="https://arxiv.org/abs/2006.12567">A Survey on Deep Learning for Localization and Mapping: Towards the Age of Spatial Machine Intelligence</a></h5><h5 id="用于定位和绘图的深度学习综述：迈向空间机器智能时代"><a href="#用于定位和绘图的深度学习综述：迈向空间机器智能时代" class="headerlink" title="用于定位和绘图的深度学习综述：迈向空间机器智能时代"></a><a href="https://ar5iv.labs.arxiv.org/html/2006.12567?_immersive_translate_auto_translate=1">用于定位和绘图的深度学习综述：迈向空间机器智能时代</a></h5><p><a href="https://mp.weixin.qq.com/s/wcCW1TGUMQgDr4AwQ24w4A">https://mp.weixin.qq.com/s/wcCW1TGUMQgDr4AwQ24w4A</a></p><hr><p><a href="https://arxiv.org/abs/1909.05214v4">A Survey of Simultaneous Localization and Mapping with an Envision in 6G Wireless Networks</a></p><p><a href="https://ar5iv.labs.arxiv.org/html/1909.05214v4?_immersive_translate_auto_translate=1">6G无线网络中的同时定位与地图构建研究综述</a></p><hr><p><a href="https://zhuanlan.zhihu.com/p/368946786">SLAM经典文献之：A Survey of Simultaneous Localization and Mapping （综述）</a></p><p><a href="https://blog.csdn.net/aaaaPIKACHU/article/details/122944513">https://blog.csdn.net/aaaaPIKACHU/article/details/122944513</a></p><hr><hr><p>中文</p><p><a href="https://zhuanlan.zhihu.com/p/368946786">SLAM经典文献之：A Survey of Simultaneous Localization and Mapping （综述）</a></p><hr><p><a href="https://cloud.tencent.com/developer/article/2209129">VSLAM（1）视觉SLAM的发展现状-腾讯云开发者社区-腾讯云</a></p><hr><p><a href="https://cloud.tencent.com/developer/article/2200159">两万字 | 视觉SLAM研究综述与未来趋势讨论</a></p><hr><p>arxiv |  中科院开源”Jointloc：一种基于联合相对和绝对位姿估计的星载无人机实时视觉定位框架“ </p><p><a href="https://arxiv.org/abs/2405.07429">JointLoc: A Real-time Visual Localization Framework for Planetary UAVs Based on Joint Relative and Absolute Pose Estimation</a></p><p><a href="https://arxiv.org/html/2405.07429v1?_immersive_translate_auto_translate=1">JointLoc：基于联合相对和绝对姿态估计的行星无人机实时视觉定位框架</a></p><hr><p><a href="https://wx.zsxq.com/dweb2/index/topic_detail/421444228145428">SLAM相关资源，这里总结几个常用的GitHub地址</a></p><p><a href="https://github.com/Vincentqyw/ORB-SLAM2-CHINESE">中文注释版ORB-SLAM2</a></p><p><a href="https://github.com/kanster/awesome-slam">很全面的SLAM教程，项目等</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>惯导解算学习</title>
      <link href="/post/e2a60691.html"/>
      <url>/post/e2a60691.html</url>
      
        <content type="html"><![CDATA[<p>References:</p><hr><ul><li><a href="https://www.zhihu.com/column/c_1150063812093825024">例说姿态解算与导航</a></li><li><a href="https://zhuanlan.zhihu.com/p/101391544">例说姿态解算与导航11(速度及位置更新)</a></li><li><a href="https://blog.csdn.net/hltt3838/article/details/110394856">九、 惯性导航解算</a></li><li><a href="https://zhuanlan.zhihu.com/p/552893040">多传感器融合定位——惯性导航解算及误差分析</a></li><li><a href="https://blog.csdn.net/ljh199942/article/details/123634589">捷联惯导算法（一）程序简单实现</a></li></ul><ul><li><a href="https://blog.csdn.net/RoboChengzi/article/details/97616482">IMU原理及姿态融合算法详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/441287506">[SINS]捷联惯导更新算法 含C代码</a></li><li><a href="http://epsilonjohn.club/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/">滤波器融合_1_惯导解算原理——捷联惯导更新算法及误差分析</a></li></ul><script>    <a href="https://Lete114.github.io/CardLink/" target="_blank"></a>  // CardLink 默认会对页面上所有a[cardlink]生成卡片链接  cardLink()</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://github.com/ethanjinhuang/inertial-navigation</span><br><span class="line">title: &quot;GitHub - ethanjinhuang/inertial-navigation&quot;</span><br><span class="line">description: &quot;Contribute to ethanjinhuang/inertial-navigation development by creating an account on GitHub.&quot;</span><br><span class="line">host: github.com</span><br><span class="line">favicon: https://github.githubassets.com/favicons/favicon.svg</span><br><span class="line">image: https://opengraph.githubassets.com/df4ce0841dfe1c3a43a97acd1f626effd97514f61d7691a3fe9a62220a648423/ethanjinhuang/inertial-navigation</span><br></pre></td></tr></table></figure><p>===</p><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/wuwuku123/article/details/120180457">捷联惯导坐标系相对转动与圆锥运动精简汇总</a></p><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/wuwuku123/article/details/120193772">地球形状与重力场简述总结</a></p><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/wuwuku123/article/details/120196473">捷联惯导更新算法及误差分析汇总</a></p><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/wuwuku123/article/details/120205430">最优估计与卡尔曼滤波基本原理</a></p><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/wuwuku123/article/details/120218781">非线性卡尔曼滤波及可观测性、观测度</a></p><p><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/wuwuku123/article/details/120241357">初始对准及组合导航技术</a></p><p>===</p><p><strong>一、捷联惯导算法与组合导航原理讲义</strong></p><p>1、<a href="https://blog.csdn.net/wuwuku123/article/details/104915955">惯导运算中的常值&amp;国际单位制&amp;惯导中常用单位</a></p><p>2、<a href="https://blog.csdn.net/wuwuku123/article/details/105097949">捷联惯导基础知识解析之一（姿态表示方法基础知识）</a></p><p>3、<a href="https://blog.csdn.net/wuwuku123/article/details/105244541">捷联惯导基础知识解析之二（捷联惯导更新算法和误差方程）</a></p><p>4、<a href="https://blog.csdn.net/wuwuku123/article/details/105265041">捷联惯导基础知识解析之三（噪声和kalman滤波）</a></p><p>5、<a href="https://blog.csdn.net/wuwuku123/article/details/105269413">捷联惯导基础知识解析之四（粗/精对准和GPS/IMU和GPS/里程计组合导航）</a></p><p>6、<a href="https://blog.csdn.net/wuwuku123/article/details/105286360">捷联惯导基础知识解析之五（低成本姿态航向参考系统）</a></p><p>7、<a href="https://blog.csdn.net/wuwuku123/article/details/105296048">捷联惯导基础知识解析之六（捷联惯导与组合导航仿真）</a></p><p>8、<a href="https://blog.csdn.net/wuwuku123/article/details/105292686">捷联惯导基础知识解析之七（欧拉角、方向余弦矩阵、和四元数之间关系）</a></p><p>9、<a href="https://blog.csdn.net/wuwuku123/article/details/105410941">捷联惯导基础知识之八（易混淆术语、知识点）</a></p><hr><p><strong>二、惯导数据分析</strong></p><p><strong>1、</strong><a href="https://blog.csdn.net/wuwuku123/article/details/104973773">Allan方差：标准allan方差求取和重叠(Overlaping)方差求取 &amp; 如何计算各个参数值！</a></p><hr><p><strong>三、基础知识</strong></p><p>1、<a href="https://blog.csdn.net/wuwuku123/article/details/104719071">地球形状与重力场模型</a></p><p>2、<a href="https://blog.csdn.net/wuwuku123/article/details/105174756">捷联惯导知识点之非直角坐标系到直角坐标系</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VsCode搭建OpenGL环境</title>
      <link href="/post/570ffaad.html"/>
      <url>/post/570ffaad.html</url>
      
        <content type="html"><![CDATA[<font size='6'><b>vscode配置OpenGL开发环境</b></font><blockquote><p>起因也是VS太笨重，我可怜的轻薄本很吃力，遂想使用VSC来实现OpenGL开发。</p><p>本文是参考一位大佬yocover而编写的，记录目的：防忘、方便下次配置、方便他人配置。</p></blockquote><p><a href="https://www.bilibili.com/video/BV1BX4y1g7R6/">大佬B站</a>和<a href="https://github.com/yocover/start-learning-opengl/tree/main">大佬GitHub</a>在这里。</p><h2 id="如何编译C-C-文件？"><a href="#如何编译C-C-文件？" class="headerlink" title="如何编译C/C++文件？"></a>如何编译C/C++文件？</h2><p>windows下 需安装 MinGW, install gcc、g++、gdb 和 mingw32-make 并 进入到 <code>MinGW\bin</code> 文件夹下 把 mingw32-make.exe 修改成 make.exe</p><blockquote><p><font color='red'>注意：</font><a href="https://www.techspot.com/downloads/downloadnow/7487/?evp=d99b1850ffcdeaa1b213895933996f39&amp;file=10356">MinGW</a> 不要下载 <em>MinGW-w64</em>因为后面可能会出现问题 MinGW，即 Minimalist GNU For Windows。它是一些头文件和端口库的集合，该集合允许人们在没有第三方动态链接库的情况下使用 GCC 产生 Win32 程序。</p></blockquote><p>这里需要注意gcc版本需要9.2，如果是6.0可能会出一些问题，当然你可以使用我这个下载链接：<a href="https://wild-civil.lanzoum.com/iHRAp1f6oyfg">https://wild-civil.lanzoum.com/iHRAp1f6oyfg</a> 密码:27as。<font color='green' size='4'>不想自己动手下载MinGW的, 可以往下翻看步骤④</font></p><h3 id="①安装MinGW"><a href="#①安装MinGW" class="headerlink" title="①安装MinGW"></a>①安装MinGW</h3><p>全程<code>Next</code>即可(当然想修改安装路径自行修改即可)</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118104022598.png" alt="select_1" style="zoom: 67%;" /></p><h3 id="②-选择相应的包进行下载"><a href="#②-选择相应的包进行下载" class="headerlink" title="② 选择相应的包进行下载"></a>② 选择相应的包进行下载</h3><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118103750262.png" alt="select_2" style="zoom: 50%;" /></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118103916384.png" alt="all_package" style="zoom:50%;" /></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118104211181.png" alt="apply" style="zoom: 67%;" /></p><h3 id="③-搞一个make"><a href="#③-搞一个make" class="headerlink" title="③ 搞一个make"></a>③ 搞一个make</h3><p>在<code>MinGW/bin</code>文件夹下，进行如下操作，方便直接使用<code>make</code>命令</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118112009720.png" alt="rename" style="zoom: 67%;" /></p><h3 id="④-添加环境变量！"><a href="#④-添加环境变量！" class="headerlink" title="④ 添加环境变量！"></a>④ 添加环境变量！</h3><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118112207512.png" alt="copy_address" style="zoom: 67%;" /></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118112534554.png" alt="path" style="zoom: 67%;" /></p><h3 id="↓LOOK-AT-HERE-↓"><a href="#↓LOOK-AT-HERE-↓" class="headerlink" title="↓LOOK AT HERE ↓"></a>↓LOOK AT HERE ↓</h3><p>如果你觉得自己下载MinGW太麻烦，我这里也有→<a href="https://wild-civil.lanzoum.com/iJ8dL1f6ws7a">现成的</a>←😋只需要进行<font color='red'>步骤④↑</font>可(解压然后复制bin目录进行环境配)。</p><p>当然我们可以在cmd中测试一下：</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118121233833.png" alt="cmd" style="zoom: 50%;" /></p><h2 id="配置VsCode"><a href="#配置VsCode" class="headerlink" title="配置VsCode"></a>配置VsCode</h2><h4 id="①下载VsCode"><a href="#①下载VsCode" class="headerlink" title="①下载VsCode"></a>①下载VsCode</h4><p>如果你还没有VS Code？！那可太糟糕了，快去下载一个吧，网上教程很多喔。</p><h4 id="②下载插件"><a href="#②下载插件" class="headerlink" title="②下载插件"></a>②下载插件</h4><p>VsCode需要安装插件<code>C/C++</code> 和 <code>C/C++ Project Generator</code>如下图所示。</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118090208491.png" alt="VsCode_plug_in" style="zoom:50%;" /></p><h4 id="③创建C-工程"><a href="#③创建C-工程" class="headerlink" title="③创建C++工程"></a>③创建C++工程</h4><p>安装完毕之后，新建一个文件夹，进入文件夹，并在空白处右键，通过VsCode打开</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118120147627.png" alt="open_by_vsc" style="zoom:50%;" /></p><p>进入VsCode后按<code>Ctrl+Shift+P</code>，输入<code>Create C++</code>，并单击如下图框住的选项，选择将项目构建在当前文件夹，即可实现C++项目的构建</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118120308011.png" alt="create_CPP_Project" style="zoom:50%;" /></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118120706321.png" alt="Project_str" style="zoom: 67%;" /></p><h4 id="④make-run"><a href="#④make-run" class="headerlink" title="④make run"></a>④make run</h4><p>紧接着按<font color='orange'>Ctrl+Shift+`</font>，在终端中输入<font color='orange'>make run</font>即可像下图一样！<font color='Bittersweet'>(注意注意，各种快捷键操作的前提是键盘是英文输入模式)</font></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118121006665.png" alt="Good"></p><p>Nice！非常漂亮，注意！接下来，重头戏开始</p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>glfw 下载 <a href="https://www.glfw.org/download.html"><code>Windows pre-compiled binaries</code></a></p><blockquote><p>选择<strong>Windows pre-compiled binaries</strong>，因为我们使用的 MinGW 所以选择 <a href="https://github.com/glfw/glfw/releases/download/3.3.8/glfw-3.3.8.bin.WIN32.zip">32-bit Windows binaries</a> 对于 Ubuntu，通过 <code>sudo apt install libglfw3-dev libglfw3</code> 安装 glfw</p></blockquote><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118204335493.png" alt="image-20231118204335493" style="zoom:67%;" /></p><p>服务器在国外可能不稳定，下载不下来莫慌，<a href="https://wild-civil.lanzoum.com/id4wq1f9ca5i">点这里</a>，我提供的是3.3.8版本。</p><blockquote><p>将<code>glfw-3.3.8.bin.WIN32\glfw-3.3.8.bin.WIN32\include\</code>下的<code>GLFW</code>文件，复制到vscode创建的C++工程下的include文件夹下。</p></blockquote><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118210154636.png" alt="image-20231118210154636" style="zoom: 52%;" /></p><blockquote><p>将<code>glfw-3.3.8.bin.WIN32\glfw-3.3.8.bin.WIN32\lib-mingw</code>路径下的<code>libglfw3.a</code>与<code>libglfw3dll.a</code>两个文件，复制到VsCode创建的C++工程下的lib文件夹下。</p></blockquote><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118210038468.png" alt="image-20231118210038468" style="zoom:80%;" /></p><blockquote><p>将<code>glfw-3.3.8.bin.WIN32\glfw-3.3.8.bin.WIN32\lib-mingw</code>路径下的<code>glfw3.dll</code>文件，复制到VsCode创建的C++工程下的output文件夹下。</p></blockquote><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118210851005.png" alt="image-20231118210851005" style="zoom: 70%;" /></p><font color='Bittersweet'>小功告成</font><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><ul><li>glad <a href="https://glad.dav1d.de/">在线服务</a> 生成静态库</li></ul><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118211724626.png" alt="image-20231118211724626" style="zoom:80%;" /></p><p>Then</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118212016228.png" alt="image-20231118212016228" style="zoom:70%;" /></p><p>老样子，下载不下来或懒得自己下载的<a href="https://wild-civil.lanzoum.com/itMT41f9gqfi">点这里</a>，下载下来后自行解压并进入解压后的文件夹内</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118212618165.png" alt="image-20231118212618165" style="zoom:67%;" /></p><p>分别输入如下两行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc ./src/glad.c -c -I ./include/ // 生成 .o文件</span><br><span class="line">ar -rc libglad.a glad.o           // 生成我们所需要的 .a文件</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118212937893.png" alt="image-20231118212937893" style="zoom:60%;" /></p><blockquote><p>将生成的 <code>libglad.a</code> 复制到 lib 文件下</p></blockquote><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118213215007.png" alt="image-20231118213215007" style="zoom:67%;" /></p><blockquote><p>将<code>glad\include</code>路径下的两个文件夹，include文件夹下。</p></blockquote><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118213440309.png" alt="image-20231118213440309" style="zoom:67%;" /></p><font color='Bittersweet'>中功告成</font><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>打开<code>Makefile</code>文件</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118215446823.png" alt="image-20231118215446823"></p><p>懒得找的也可以直接参看我的Makefile文件↓</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &#x27;make&#x27;        build executable file &#x27;main&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;make clean&#x27;  removes all .o and executable files</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the Cpp compiler to use</span></span><br><span class="line">CXX = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># define any compile-time flags</span></span><br><span class="line">CXXFLAGS:= -std=c++17 -Wall -Wextra -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># define library paths in addition to /usr/lib</span></span><br><span class="line"><span class="comment">#   if I wanted to include libraries not in /usr/lib I&#x27;d specify</span></span><br><span class="line"><span class="comment">#   their path using -Lpath, something like:</span></span><br><span class="line">LFLAGS =</span><br><span class="line"></span><br><span class="line"><span class="comment"># define output directory</span></span><br><span class="line">OUTPUT:= output</span><br><span class="line"></span><br><span class="line"><span class="comment"># define source directory</span></span><br><span class="line">SRC:= src</span><br><span class="line"></span><br><span class="line"><span class="comment"># define include directory</span></span><br><span class="line">INCLUDE:= <span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define lib directory</span></span><br><span class="line">LIB:= lib</span><br><span class="line">Libraries := -lglad -lglfw3dll </span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OS)</span>,Windows_NT)</span><br><span class="line">MAIN:= main.exe</span><br><span class="line">SOURCEDIRS:= <span class="variable">$(SRC)</span></span><br><span class="line">INCLUDEDIRS:= <span class="variable">$(INCLUDE)</span></span><br><span class="line">LIBDIRS:= <span class="variable">$(LIB)</span></span><br><span class="line">FIXPATH = <span class="variable">$(<span class="built_in">subst</span> /,\,$1)</span></span><br><span class="line">RM:= del /q /f</span><br><span class="line">MD:= mkdir</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">MAIN:= main</span><br><span class="line">SOURCEDIRS:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC)</span> -type d)</span></span><br><span class="line">INCLUDEDIRS:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(INCLUDE)</span> -type d)</span></span><br><span class="line">LIBDIRS:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(LIB)</span> -type d)</span></span><br><span class="line">FIXPATH = $1</span><br><span class="line">RM = rm -f</span><br><span class="line">MD:= mkdir -p</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define any directories containing header files other than /usr/include</span></span><br><span class="line">INCLUDES:= <span class="variable">$(<span class="built_in">patsubst</span> %,-I%, $(INCLUDEDIRS:%/=%)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the C libs</span></span><br><span class="line">LIBS:= <span class="variable">$(<span class="built_in">patsubst</span> %,-L%, $(LIBDIRS:%/=%)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the C source files</span></span><br><span class="line">SOURCES:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.cpp, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the C object files</span></span><br><span class="line">OBJECTS:= $(SOURCES:.cpp=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the dependency output files</span></span><br><span class="line">DEPS:= $(OBJECTS:.o=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The following part of the makefile is generic; it can be used to</span></span><br><span class="line"><span class="comment"># build any executable just by changing the definitions above and by</span></span><br><span class="line"><span class="comment"># deleting dependencies appended to the file from &#x27;make depend&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">OUTPUTMAIN:= <span class="variable">$(<span class="built_in">call</span> FIXPATH,<span class="variable">$(OUTPUT)</span>/<span class="variable">$(MAIN)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OUTPUT)</span> <span class="variable">$(MAIN)</span></span></span><br><span class="line">@echo Executing &#x27;all&#x27; complete!</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span>:</span><br><span class="line"><span class="variable">$(MD)</span> <span class="variable">$(OUTPUT)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(MAIN)</span>: <span class="variable">$(OBJECTS)</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(INCLUDES)</span> -o <span class="variable">$(OUTPUTMAIN)</span> <span class="variable">$(OBJECTS)</span> <span class="variable">$(LFLAGS)</span> <span class="variable">$(LIBS)</span> <span class="variable">$(Libraries)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># include all .d files</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this is a suffix replacement rule for building .o&#x27;s and .d&#x27;s from .c&#x27;s</span></span><br><span class="line"><span class="comment"># it uses automatic variables $&lt;: the name of the prerequisite of</span></span><br><span class="line"><span class="comment"># the rule(a .c file) and $@: the name of the target of the rule (a .o file)</span></span><br><span class="line"><span class="comment"># -MMD generates dependency output files same name as the .o file</span></span><br><span class="line"><span class="comment"># (see the gnu make manual section about automatic variables)</span></span><br><span class="line"><span class="section">.cpp.o:</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(INCLUDES)</span> -c -MMD <span class="variable">$&lt;</span>  -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(OUTPUTMAIN)</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(<span class="built_in">call</span> FIXPATH,<span class="variable">$(OBJECTS)</span>)</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(<span class="built_in">call</span> FIXPATH,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line">@echo Cleanup complete!</span><br><span class="line"></span><br><span class="line"><span class="section">run: all</span></span><br><span class="line">./<span class="variable">$(OUTPUTMAIN)</span></span><br><span class="line">@echo Executing &#x27;run: all&#x27; complete!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>紧接着我们将下面的代码复制到<code>main.cpp</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>敲<font color='orange'>Ctrl+Shift+`</font>，在终端中输入<font color='orange'>make run</font>即可弹出窗口啦！按ESC即可退出运行。</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118215958332.png" alt="image-20231118215958332"></p><p>加油！坚持！再进行最后的操作你就胜利了！</p><h3 id="找不到头文件？"><a href="#找不到头文件？" class="headerlink" title="找不到头文件？"></a>找不到头文件？</h3><p>对了这里还有小技巧，如果头文件红了，可以在<code>.vscode/c_cpp_properties.json</code>中进行添加路径，如果没有该json文件，可以敲<font color='orange'>Ctrl+Shift+`</font>然后输入下图的内容即可调处c_cpp_properties.json</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118222309630.png" alt="image-20231118222309630" style="zoom:68%;" /></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231118222746437.png" alt="image-20231118222746437" style="zoom: 50%;" /></p><h3 id="想要多个main-cpp共存？"><a href="#想要多个main-cpp共存？" class="headerlink" title="想要多个main.cpp共存？"></a>想要多个main.cpp共存？</h3><p>如果你向我一样正在学习OpenGL，但又不想一个劲的生成副本main.cpp然后注释main.cpp等，你可以这样做：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &#x27;make run dir=file_name&#x27;        build executable file &#x27;main&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;make clean dir=file_name&#x27;    removes selected .o and executable files</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the Cpp compiler to use</span></span><br><span class="line">CXX = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># define any compile-time flags</span></span><br><span class="line">CXXFLAGS:= -std=c++17 -Wall -Wextra -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># define library paths in addition to /usr/lib</span></span><br><span class="line"><span class="comment">#   if I wanted to include libraries not in /usr/lib I&#x27;d specify</span></span><br><span class="line"><span class="comment">#   their path using -Lpath, something like:</span></span><br><span class="line">LFLAGS = </span><br><span class="line"></span><br><span class="line"><span class="comment"># define output directory</span></span><br><span class="line">OUTPUT:= output</span><br><span class="line"></span><br><span class="line"><span class="comment"># define source directory 运行时修改此处路径</span></span><br><span class="line">SRC:= src/<span class="variable">$(dir)</span> <span class="comment">#// 传递 var 变量定义执行文件目录</span></span><br><span class="line">CLEAN_SRC:= src/<span class="variable">$(dir)</span>/*.o <span class="comment">#// 删除所有.o文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define include directory</span></span><br><span class="line">INCLUDE:= <span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define lib directory</span></span><br><span class="line">LIB:= lib</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OS)</span>,Windows_NT)</span><br><span class="line">LIBRARIES:= -lglad -lglfw3dll</span><br><span class="line">MAIN:= main.exe</span><br><span class="line">SOURCEDIRS:= <span class="variable">$(SRC)</span></span><br><span class="line">INCLUDEDIRS:= <span class="variable">$(INCLUDE)</span></span><br><span class="line">LIBDIRS:= <span class="variable">$(LIB)</span></span><br><span class="line">FIXPATH = <span class="variable">$(<span class="built_in">subst</span> /,\,$1)</span> <span class="comment">#这里细节错误</span></span><br><span class="line">RM:= del /q /f</span><br><span class="line">MD:= mkdir</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LIBRARIES:= -lglad -lglfw -ldl -lpthread</span><br><span class="line">MAIN:= main</span><br><span class="line">SOURCEDIRS:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC)</span> -type d)</span></span><br><span class="line">INCLUDEDIRS:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(INCLUDE)</span> -type d)</span></span><br><span class="line">LIBDIRS:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(LIB)</span> -type d)</span></span><br><span class="line">FIXPATH = $1</span><br><span class="line">RM = rm -f</span><br><span class="line">MD:= mkdir -p</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define any directories containing header files other than /usr/include</span></span><br><span class="line">INCLUDES:= <span class="variable">$(<span class="built_in">patsubst</span> %,-I%, $(INCLUDEDIRS:%/=%)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the C libs</span></span><br><span class="line">LIBS:= <span class="variable">$(<span class="built_in">patsubst</span> %,-L%, $(LIBDIRS:%/=%)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the C source files</span></span><br><span class="line">SOURCES:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.cpp, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the C object files </span></span><br><span class="line">OBJECTS:= $(SOURCES:.cpp=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the dependency output files</span></span><br><span class="line">DEPS:= $(OBJECTS:.o=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The following part of the makefile is generic; it can be used to </span></span><br><span class="line"><span class="comment"># build any executable just by changing the definitions above and by</span></span><br><span class="line"><span class="comment"># deleting dependencies appended to the file from &#x27;make depend&#x27;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">OUTPUTMAIN:= <span class="variable">$(<span class="built_in">call</span> FIXPATH,<span class="variable">$(OUTPUT)</span>/<span class="variable">$(MAIN)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OUTPUT)</span> <span class="variable">$(MAIN)</span></span></span><br><span class="line">@echo Executing &#x27;all&#x27; complete!</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTPUT)</span>:</span><br><span class="line"><span class="variable">$(MD)</span> <span class="variable">$(OUTPUT)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(MAIN)</span>: <span class="variable">$(OBJECTS)</span> </span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(INCLUDES)</span> -o <span class="variable">$(OUTPUTMAIN)</span> <span class="variable">$(OBJECTS)</span> <span class="variable">$(LFLAGS)</span> <span class="variable">$(LIBS)</span> <span class="variable">$(LIBRARIES)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># include all .d files</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this is a suffix replacement rule for building .o&#x27;s from .c&#x27;s</span></span><br><span class="line"><span class="comment"># it uses automatic variables $&lt;: the name of the prerequisite of</span></span><br><span class="line"><span class="comment"># the rule(a .c file) and $@: the name of the target of the rule (a .o file) </span></span><br><span class="line"><span class="comment"># -MMD generates dependency output files same name as the .o file</span></span><br><span class="line"><span class="comment"># (see the gnu make manual section about automatic variables)</span></span><br><span class="line"><span class="section">.cpp.o:</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(INCLUDES)</span> -c -MMD <span class="variable">$&lt;</span>  -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(OUTPUTMAIN)</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(<span class="built_in">call</span> FIXPATH,<span class="variable">$(OBJECTS)</span>)</span></span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$(<span class="built_in">call</span> FIXPATH,<span class="variable">$(DEPS)</span>)</span></span><br><span class="line">@echo Cleanup complete!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处./src/$(dir) 传递main函数 argv 的参数</span></span><br><span class="line"><span class="section">run: all</span></span><br><span class="line">./<span class="variable">$(OUTPUTMAIN)</span> src/<span class="variable">$(dir)</span>/</span><br><span class="line">@echo Executing &#x27;run: all&#x27; complete!</span><br></pre></td></tr></table></figure><p>然后你在命令行执行<code>make run dir=file_name</code>就可以编译你选定的那个文件夹下的main.cpp <font color='green'>(注：这里file_name为01)</font></p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231119224335919.png" alt="image-20231119224335919"></p><p>在命令行执行<code>make clean dir=file_name</code>就可以清除main.exe、main.d和main.o</p><p><img src="https://youpai.hanvon.top//blog/article/Learing/OpenGL/VsCode_config/image-20231119223926130.png" alt="image-20231119223926130"></p><h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><p>各位看官请看Up原视频</p><iframe src="//player.bilibili.com/player.html?aid=715020710&bvid=BV1BX4y1g7R6&cid=322875840&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="400" height="300">  </iframe><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果还要导入其他的库可以按照下面的步骤：</p><ul><li><p>glm 复制到 include 目录下</p></li><li><p>imgui 复制到 include 目下,Makefile 中添加以下命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the C source files</span></span><br><span class="line">SOURCES:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.cpp, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line">SOURCES+= <span class="keyword">include</span>/imgui/imgui_impl_glfw.cpp <span class="keyword">include</span>/imgui/imgui_impl_opengl3.cpp</span><br><span class="line">SOURCES+= <span class="keyword">include</span>/imgui/imgui.cpp <span class="keyword">include</span>/imgui/imgui_demo.cpp <span class="keyword">include</span>/imgui/imgui_draw.cpp <span class="keyword">include</span>/imgui/imgui_widgets.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>assimp 下载已编译好的文件 <a href="https://www.mediafire.com/file/jjiv41rv8euy3dt/Assimp3-1-1_MinGW4-8-1_Win32.zip/file">Assimp3-1-1_MinGW4-8-1_Win32.zip</a></p><blockquote><p>对于 Ubuntu，通过 <code>sudo apt install libassimp-dev</code> 安装 assimp</p></blockquote><p><a href="https://github.com/yocover/start-learning-opengl/blob/main/Makefile">参考 Makefile 文件</a>如下</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磨刀不误砍柴工</title>
      <link href="/post/f73586b.html"/>
      <url>/post/f73586b.html</url>
      
        <content type="html"><![CDATA[<p>2023-10-29 早上上班 磨了磨刀：</p><h1 id="word批量转pdf"><a href="#word批量转pdf" class="headerlink" title="word批量转pdf"></a>word批量转pdf</h1><h2 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h2><h4 id="1-在桌面随意新建一个doc文档，然后打开后同时按alt和F11，双击下图方框。"><a href="#1-在桌面随意新建一个doc文档，然后打开后同时按alt和F11，双击下图方框。" class="headerlink" title="1.在桌面随意新建一个doc文档，然后打开后同时按alt和F11，双击下图方框。"></a>1.在桌面随意新建一个doc文档，然后打开后同时按alt和F11，双击下图方框。</h4><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033846.png" alt="Double ThisDocument"></p><h4 id="2-将代码复制"><a href="#2-将代码复制" class="headerlink" title="2.将代码复制"></a>2.将代码复制</h4><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033052.png" alt="copy&amp;paste"><br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Sub BatchConvertToPDF()</span><br><span class="line">    Dim destFolderPath As String</span><br><span class="line">    destFolderPath = GetFolderPath</span><br><span class="line">    If destFolderPath &lt;&gt; Empty Then</span><br><span class="line">        Dim path As Variant</span><br><span class="line">        For Each path In GetFilePaths()</span><br><span class="line">            Dim indexOfSlash, indexOfDot As Integer</span><br><span class="line">            indexOfSlash = InStrRev(path, &quot;\&quot;)</span><br><span class="line">            indexOfDot = InStrRev(path, &quot;.&quot;)</span><br><span class="line">             </span><br><span class="line">            Dim destFilePath As String</span><br><span class="line">            destFilePath = destFolderPath + Mid(path, indexOfSlash, indexOfDot - indexOfSlash) + &quot;.pdf&quot;</span><br><span class="line">             </span><br><span class="line">            ConvertToPDF path, destFilePath</span><br><span class="line">        Next path</span><br><span class="line">    End If</span><br><span class="line">End Sub</span><br><span class="line"> </span><br><span class="line">Function GetFilePaths()</span><br><span class="line">    Dim folderPath As String</span><br><span class="line">    With Application.FileDialog(msoFileDialogFilePicker)</span><br><span class="line">        .Filters.Add &quot;word文件&quot;, &quot;*.doc; *.docx; *.docm&quot;</span><br><span class="line">        .Title = &quot;请择要转换的word文件&quot;</span><br><span class="line">        If .Show = -1 Then</span><br><span class="line">            Set GetFilePaths = .SelectedItems</span><br><span class="line">        End If</span><br><span class="line">    End With</span><br><span class="line">End Function</span><br><span class="line"> </span><br><span class="line">Function GetFolderPath()</span><br><span class="line">    Dim folderPath As String</span><br><span class="line">    With Application.FileDialog(msoFileDialogFolderPicker)</span><br><span class="line">        .AllowMultiSelect = False</span><br><span class="line">        .Title = &quot;请选择要存放的目录&quot;</span><br><span class="line">        If .Show = -1 Then</span><br><span class="line">            GetFolderPath = .SelectedItems(1)</span><br><span class="line">        End If</span><br><span class="line">    End With</span><br><span class="line">End Function</span><br><span class="line"> </span><br><span class="line">Sub ConvertToPDF(srcPath As Variant, destPath As String)</span><br><span class="line">    Documents.Open FileName:=srcPath, ConfirmConversions:=False, _</span><br><span class="line">        ReadOnly:=False, AddToRecentFiles:=False, PasswordDocument:=&quot;&quot;, _</span><br><span class="line">        PasswordTemplate:=&quot;&quot;, Revert:=False, WritePasswordDocument:=&quot;&quot;, _</span><br><span class="line">        WritePasswordTemplate:=&quot;&quot;, Format:=wdOpenFormatAuto, XMLTransform:=&quot;&quot;</span><br><span class="line">    ActiveDocument.ExportAsFixedFormat OutputFileName:= _</span><br><span class="line">        destPath, ExportFormat:= _</span><br><span class="line">        wdExportFormatPDF, OpenAfterExport:=False, OptimizeFor:= _</span><br><span class="line">        wdExportOptimizeForOnScreen, Range:=wdExportAllDocument, From:=1, To:=1, _</span><br><span class="line">        Item:=wdExportDocumentContent, IncludeDocProps:=True, KeepIRM:=True, _</span><br><span class="line">        CreateBookmarks:=wdExportCreateNoBookmarks, DocStructureTags:=True, _</span><br><span class="line">        BitmapMissingFonts:=True, UseISO19005_1:=False</span><br><span class="line">    ActiveDocument.Close</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p><h4 id="3-按F5运行代码，选择pdf要保存的位置，需要转换的word（word文件可多选），等待转换成功。"><a href="#3-按F5运行代码，选择pdf要保存的位置，需要转换的word（word文件可多选），等待转换成功。" class="headerlink" title="3.按F5运行代码，选择pdf要保存的位置，需要转换的word（word文件可多选），等待转换成功。"></a>3.按F5运行代码，选择pdf要保存的位置，需要转换的word（word文件可多选），等待转换成功。</h4><h2 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h2><p>（有福昕的前提下）</p><h4 id="非常简单-也很好用啊"><a href="#非常简单-也很好用啊" class="headerlink" title="非常简单 也很好用啊"></a>非常简单 也很好用啊</h4><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033987.png" alt="fuxin"><br>福昕高级PDF编辑器 <a href="https://www.aliyundrive.com/s/Ye8gpyiSSiC">https://www.aliyundrive.com/s/Ye8gpyiSSiC</a> 提取码: iz27 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p><h1 id="批量复制文件名称"><a href="#批量复制文件名称" class="headerlink" title="批量复制文件名称"></a>批量复制文件名称</h1><h4 id="非常简单：选中要复制的文件，按住Shift再右键，复制文件地址"><a href="#非常简单：选中要复制的文件，按住Shift再右键，复制文件地址" class="headerlink" title="非常简单：选中要复制的文件，按住Shift再右键，复制文件地址"></a>非常简单：选中要复制的文件，按住Shift再右键，复制文件地址</h4><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033572.png" alt="copy_adrres"></p><h4 id="可以先复制到记事本，然后-Ctrl-H-替换多余的部分为空"><a href="#可以先复制到记事本，然后-Ctrl-H-替换多余的部分为空" class="headerlink" title="可以先复制到记事本，然后 Ctrl+H 替换多余的部分为空"></a>可以先复制到记事本，然后 Ctrl+H 替换多余的部分为空</h4><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033924.png" alt="replace"></p><h1 id="文件批量重命名"><a href="#文件批量重命名" class="headerlink" title="文件批量重命名"></a>文件批量重命名</h1><h4 id="不必多说，上链接"><a href="#不必多说，上链接" class="headerlink" title="不必多说，上链接"></a>不必多说，上链接</h4><p>ReNamer Pro 7.3.exe <a href="https://www.aliyundrive.com/s/17KLzJbQMAm">https://www.aliyundrive.com/s/17KLzJbQMAm</a> 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。</p><p>阿里云超过200文件数目则无法分享（我没开会员），因此大家拿到手后双击exe文件可以选择安装便携版<br><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033157.png" alt="portable_v"></p><p>然后选中文即可<br><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301033412.png" alt="simple_chinese"></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5/202310301035291.png" alt="on_your_way"><br>非常简单，非常方便</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Matlab</title>
      <link href="/post/f73596b.html"/>
      <url>/post/f73596b.html</url>
      
        <content type="html"><![CDATA[<p>Matlab/Simulink快捷键<br>Simulink快捷键<br>模型调整<br>Alt + Enter：为选定模块设置主要参数<br>Ctrl + Shift + I：打开或隐藏 Property Inspector<br>Shift + 拖动句柄：调整模块大小，保持相同的高宽比<br>Ctrl + 拖动句柄：从中心调整模块大小<br>Ctrl + R：顺时针旋转模块<br>Ctrl + Shift + R：逆时针旋转模块<br>Ctrl + I：翻转模块<br>Ctrl + F：查找模块<br>Ctrl + M：封装模块<br>Ctrl + U：在模块封装下查找<br>Ctrl + Shift + Y：注释模块<br>Ctrl + Shift + X：注释掉或取消注释模块<br>Ctrl + K：刷新Mode模块<br>Ctrl + L：对于链接模块，转到父模块的库<br>Ctrl + H：打开 Model Explorer</p><p>仿真键盘快捷键<br>Ctrl + E：打开 Configuration Parameters对话框<br>Ctrl + D：更新图<br>Ctrl + T：开始仿真<br>Ctrl + Shift + T：停止仿真<br>Ctrl + B：构建模型（用于代码生成）</p><p>调试和断点键盘快捷方式<br>F10：步骤<br>F11：步入<br>Shift + F11：步出<br>F5：运行<br>F12：设置/清除断点<br>Ctrl + J：查看simple time<br>视图放大：r<br>视图缩小：v<br>————————————————<br>版权声明：本文为CSDN博主「小曾&amp;同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/acknole/article/details/112344263">https://blog.csdn.net/acknole/article/details/112344263</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git实战</title>
      <link href="/post/ff99adbe.html"/>
      <url>/post/ff99adbe.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://youpai.hanvon.top/blog/article/Learing/git/git_logo.png" align="right" /></p><h1 id="Git实战小笔记"><a href="#Git实战小笔记" class="headerlink" title="Git实战小笔记"></a><strong>Git实战小笔记</strong></h1><p>什么是Git? 答：Git是一个 分布式的版本控制 软件。</p><p>为什么要做版本控制？答：要保留之前所有的版本,以便回滚和修改。</p><p>为啥要学Git?答：不学Git，无法参与满足大公司代码开发功能（版本管理、提交代码）。</p><blockquote><p>本文不讲解任何不同代码控制软件的不同，也不讲解可视化版本控制的使用。 为什么？答：大家都用这玩意，你别折腾上古工具(SVN)这些东西。</p></blockquote><h1 id="讲故事学Git"><a href="#讲故事学Git" class="headerlink" title="讲故事学Git"></a>讲故事学Git</h1><h2 id="第一阶段-单枪匹马开始干"><a href="#第一阶段-单枪匹马开始干" class="headerlink" title="第一阶段: 单枪匹马开始干"></a>第一阶段: 单枪匹马开始干</h2><p>想要让git对一个目录进行版本控制需要以下步骤:</p><ul><li>进入要管理的文件央</li><li>执行初始化命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>管理目录下的文件状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">注:新增的文件和修改过后的文件都是红色</span><br></pre></td></tr></table></figure><p>管理指定文件(红变绿)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add [filename.filetype] //添加到缓存区</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p> git status color:</p><p> red 🔴:not add</p><p> green 🟢:had added</p><ul><li>个人信息配置:用户名、邮箱 【一次即可】</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;[your email address]&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;[your nickname]&quot;</span> </span><br></pre></td></tr></table></figure><ul><li>生成版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;描述信息&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>查看版本记录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="第二阶段-拓展新功能"><a href="#第二阶段-拓展新功能" class="headerlink" title="　第二阶段: 拓展新功能"></a>　第二阶段: 拓展新功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit -m <span class="string">&#x27;短视频&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="第三阶段-“约饭事件”"><a href="#第三阶段-“约饭事件”" class="headerlink" title="第三阶段: “约饭事件”"></a>第三阶段: “约饭事件”</h2><ul><li>回滚(reset)至之前版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git reset --hard [commit <span class="built_in">id</span>] //回滚版本</span><br></pre></td></tr></table></figure><ul><li>回滚之之后版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard [commit <span class="built_in">id</span>] //回滚参考日志版本（无任何当前工作缓存）</span><br></pre></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git reflog</span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/Learing/git/sum.png" style="max-width:70%; height:auto" /></p><h2 id="第四阶段-商城-amp-紧急修复bug"><a href="#第四阶段-商城-amp-紧急修复bug" class="headerlink" title="第四阶段:商城&amp;紧急修复bug"></a>第四阶段:商城&amp;紧急修复bug</h2><h4 id="2-5-1分支"><a href="#2-5-1分支" class="headerlink" title="2.5.1分支"></a>2.5.1分支</h4><p>分支可以给使用者提供多个环境的可以,意味着你可以把你的工作从开发主线上分离开来,以免影响开 发主线。</p><h4 id="2-5-2-紧急修复bug方案"><a href="#2-5-2-紧急修复bug方案" class="headerlink" title="2.5.2 紧急修复bug方案"></a>2.5.2 紧急修复bug方案</h4><p><img src="https://youpai.hanvon.top/blog/article/Learing/git/emergencyrepair.png" style="max-width:70%; height:auto" /></p><p>2.5.3 命令总结</p><ul><li>查看分支 (展示分支)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure><ul><li>创建分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch name]</span><br></pre></td></tr></table></figure><ul><li>切换分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch name]</span><br><span class="line">git checkout -b [branch name] //切换并且创建分支</span><br></pre></td></tr></table></figure><ul><li>分支改名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m [old branch name] [new branch name] //分支改名</span><br></pre></td></tr></table></figure><ul><li>分支合并(可能产生冲突)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch name] //合并到哪，切换哪的分支。</span><br><span class="line">🔴注意:先切换分支再合并</span><br></pre></td></tr></table></figure><ul><li>删除分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch name] //删除分支</span><br></pre></td></tr></table></figure><h4 id="2-5-4-工作流"><a href="#2-5-4-工作流" class="headerlink" title="2.5.4 工作流"></a>2.5.4 工作流</h4><p><img src="https://youpai.hanvon.top/blog/article/Learing/git/branch.png" style="zoom:50%;" /></p><h2 id="第五阶段-进军三里屯"><a href="#第五阶段-进军三里屯" class="headerlink" title="第五阶段:进军三里屯"></a>第五阶段:进军三里屯</h2><p>有钱之后就要造呀,一个人在三里屯买了一层楼做办公室。</p><p><img src="https://youpai.hanvon.top/blog/article/Learing/git/hulian.png" style="max-width:60%; height:auto" /></p><h4 id="2-6-1-第一天上班前在家上传代码"><a href="#2-6-1-第一天上班前在家上传代码" class="headerlink" title="2.6.1 第一天上班前在家上传代码"></a>2.6.1 第一天上班前在家上传代码</h4><p>首先,需要注册github账号,并创建远程仓库,然后再执行如下命令,将代码上传到github。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 给远程仓库起别名</span><br><span class="line">git remote add origin 远程仓库地址</span><br><span class="line">2. 向远程推送代码</span><br><span class="line">git push -u origin 分支</span><br></pre></td></tr></table></figure><h4 id="2-6-2-初次在公司新电脑下载代码"><a href="#2-6-2-初次在公司新电脑下载代码" class="headerlink" title="2.6.2 初次在公司新电脑下载代码"></a>2.6.2 初次在公司新电脑下载代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 克隆远程仓库代码</span><br><span class="line">git <span class="built_in">clone</span> 远程仓库地址  (内部已实现git remote add origin 远程仓库地址)</span><br><span class="line">2. 切换分支</span><br><span class="line">git checkout 分支</span><br></pre></td></tr></table></figure><p>在公司下载完代码后,继续开发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 切换到dev分支进行开发</span><br><span class="line">git checkout dev</span><br><span class="line">2. 把master分支合并到dev [仅一次] </span><br><span class="line">git merge master</span><br><span class="line">3. 修改代码</span><br><span class="line">4. 提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h4 id="2-6-3-下班回到家继续写代码"><a href="#2-6-3-下班回到家继续写代码" class="headerlink" title="2.6.3 下班回到家继续写代码"></a>2.6.3 下班回到家继续写代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 切换到dev分支进行开发</span><br><span class="line">git checkout dev</span><br><span class="line">2. 拉代码</span><br><span class="line">git pull origin dev</span><br><span class="line">3. 继续开发</span><br><span class="line"></span><br><span class="line">4. 提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h4 id="2-6-4-到公司继续开发"><a href="#2-6-4-到公司继续开发" class="headerlink" title="2.6.4 到公司继续开发"></a>2.6.4 到公司继续开发</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 切换到dev分支进行开发</span><br><span class="line">git checkout dev</span><br><span class="line">2. 拉最新代码(不必再<span class="built_in">clone</span>,只需要通过pull获取最新代码即可)</span><br><span class="line">git pull origin dev</span><br><span class="line">3. 继续开发</span><br><span class="line"></span><br><span class="line">4. 提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p>开发完毕,要上线了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 将dev分支合并到master,进行上线</span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line">git push origin master</span><br><span class="line">2. 把dev分支也推送到远程</span><br><span class="line">git checkout dev</span><br><span class="line">git merge master</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h4 id="2-6-5-在公司约妹子忘记提交代码"><a href="#2-6-5-在公司约妹子忘记提交代码" class="headerlink" title="2.6.5 在公司约妹子忘记提交代码"></a>2.6.5 在公司约妹子忘记提交代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 拉代码</span><br><span class="line">git pull origin dev</span><br><span class="line">2. 继续开发</span><br><span class="line"></span><br><span class="line">3. 提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"></span><br><span class="line">注:忘记push了</span><br></pre></td></tr></table></figure><h4 id="2-6-6-回家继续写代码"><a href="#2-6-6-回家继续写代码" class="headerlink" title="2.6.6 回家继续写代码"></a>2.6.6 回家继续写代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 拉代码,发现在公司写的代码忘记提交 ... </span><br><span class="line">git pull origin dev</span><br><span class="line"></span><br><span class="line">2. 继续开发其他功能</span><br><span class="line"></span><br><span class="line">3. 把dev分支也推送到远程</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h4 id="2-6-7-到公司继续写代码"><a href="#2-6-7-到公司继续写代码" class="headerlink" title="2.6.7 到公司继续写代码"></a>2.6.7 到公司继续写代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 拉代码,把晚上在家写的代码拉到本地(有合并、可能产生冲突)</span><br><span class="line">git pull origin dev</span><br><span class="line"></span><br><span class="line">2. 如果有冲突,手动解决冲突</span><br><span class="line"></span><br><span class="line">3. 继续开发其他功能</span><br><span class="line"></span><br><span class="line">4. 把dev分支也推送到远程</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;xx&#x27;</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h4 id="2-6-8-其他"><a href="#2-6-8-其他" class="headerlink" title="2.6.8 其他"></a>2.6.8 其他</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin dev</span><br><span class="line">等价于</span><br><span class="line">git fetch origin dev</span><br><span class="line">git merge origin/dev</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/Learing/git/elsegitsum.png" style="max-width:80%; height:auto" /></p><h4 id="2-6-9-rebase的作用"><a href="#2-6-9-rebase的作用" class="headerlink" title="2.6.9 rebase的作用?"></a>2.6.9 rebase的作用?</h4><p>rebase可以保持提交记录简洁,不分叉。</p><h4 id="2-6-10-快速解决冲突"><a href="#2-6-10-快速解决冲突" class="headerlink" title="2.6.10 快速解决冲突"></a>2.6.10 快速解决冲突</h4><p>​    ①安装beyond compare<br>​    ②在git中配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> merge.tool bc3</span><br><span class="line">git config --<span class="built_in">local</span> mergetool.path <span class="string">&#x27;/usr/local/bin/bcomp&#x27;</span></span><br><span class="line">git config --<span class="built_in">local</span> mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>​    ③应用beyond compare 解决冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure><h3 id="2-7-小总结"><a href="#2-7-小总结" class="headerlink" title="2.7 小总结"></a>2.7 小总结</h3><ul><li>添加远程连接(别名)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 地址</span><br></pre></td></tr></table></figure><ul><li>推送代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><ul><li>下载代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 地址</span><br></pre></td></tr></table></figure><ul><li>拉取代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin dev</span><br><span class="line">等价于</span><br><span class="line">git fetch origin dev</span><br><span class="line">git merge origin/dev</span><br></pre></td></tr></table></figure><ul><li>保持代码提交整洁(变基)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase 分支</span><br></pre></td></tr></table></figure><ul><li>记录图形展示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=format:<span class="string">&quot;%h %s&quot;</span></span><br></pre></td></tr></table></figure><h2 id="第六阶段-多人协同开发工作流"><a href="#第六阶段-多人协同开发工作流" class="headerlink" title="第六阶段:多人协同开发工作流"></a>第六阶段:多人协同开发工作流</h2><h4 id="2-8-1-创建项目-amp-邀请成员"><a href="#2-8-1-创建项目-amp-邀请成员" class="headerlink" title="2.8.1 创建项目&amp;邀请成员"></a>2.8.1 创建项目&amp;邀请成员</h4><p>协同开发时,需要所有成员都可以对同一个项目进行操作,需要邀请成员并赋予权限,否则无法开发。 github支持两种创建项目的方式(供多人协同开发)。</p><p>​    1.合作者,将用户添加到仓库合作者中之后,该用户就可以向当前仓库提交代码。<br>​    2.组织,将成员邀请进入组织,组织下可以创建多个仓库,组织成员可以向组织下仓库提交代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">扩展: Tag标签管理</span><br><span class="line">为了能清晰的管理版本,在公司不会直接使用 commit来做版本,会基于Tag来实现: v1.0 、v1.2 、v2.0 版本。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 -m <span class="string">&#x27;版本介绍&#x27;</span> 创建本地创建Tag信息</span><br><span class="line">git tag -d v1.0删除Tag</span><br><span class="line">git push origin  --tags将本地tag信息推送到远程仓库</span><br><span class="line">git pull origin  --tags更新本地tag版本信息</span><br><span class="line"></span><br><span class="line">git checkout v.10切换tag</span><br><span class="line">git <span class="built_in">clone</span> -b v0.1 地址   指定tag下载代码</span><br></pre></td></tr></table></figure><h4 id="2-8-2-小弟开发"><a href="#2-8-2-小弟开发" class="headerlink" title="2.8.2 小弟开发"></a>2.8.2 小弟开发</h4><ul><li>小弟注册Github 或 Gitlab账号</li><li>邀请小弟进入组织(默认对组织中的项目具有读权限)</li><li>邀请小弟成为某项目的合作者</li><li>小弟在自己电脑上下载代码并开发</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oldboy-org/dbhot.git</span><br><span class="line"><span class="built_in">cd</span> dbhot</span><br><span class="line">git checkout dev</span><br><span class="line">git checkout -b dzz</span><br><span class="line">写代码 ...</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;斗地主功能开发完成&#x27;</span></span><br><span class="line">git push origin ddz</span><br></pre></td></tr></table></figure><h4 id="2-8-3-code-review"><a href="#2-8-3-code-review" class="headerlink" title="2.8.3 code review"></a>2.8.3 code review</h4><p>​    1.配置,代码review之后才能合并到dev分支。<br>​    2.小弟提交 code review申请<br>​    3.组长做 code review</p><h4 id="2-8-4-提测上线-预发布"><a href="#2-8-4-提测上线-预发布" class="headerlink" title="2.8.4 提测上线(预发布)"></a>2.8.4 提测上线(预发布)</h4><p>由专门团队或团队leader执行以下步骤:</p><p>​    1.基于dev分值创建release分值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git checkout -b release</span><br></pre></td></tr></table></figure><p>​    2.测试等<br>​    3.合并到master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用pull request</span><br><span class="line">或</span><br><span class="line">本地将release合并到master分支</span><br></pre></td></tr></table></figure><p>​    4.在master分支打tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v2 -m <span class="string">&#x27;第二版  斗地主功能&#x27;</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>​    5.运维人员就可以去下载代码做上线了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v2 地址</span><br></pre></td></tr></table></figure><h2 id="第七阶段-给开源软件贡献代码"><a href="#第七阶段-给开源软件贡献代码" class="headerlink" title="第七阶段:给开源软件贡献代码"></a>第七阶段:给开源软件贡献代码</h2><p>​    1.fork源代码 将别人源代码拷贝到我自己的远程仓库。<br>​    2.在自己仓库进行修改代码<br>​    3.给源代码的作者提交 修复bug的申请 (pull request)</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1 配置"></a>3.1 配置</h4><ul><li>项目配置文件:项目/.git/conig</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config -- user.name <span class="string">&#x27;冯一航&#x27;</span></span><br><span class="line">git config -- <span class="built_in">local</span> user.email <span class="string">&#x27;fengyihang@xx.com&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>全局配置文件: ~/.gitconig</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;fengyihang&#x27;</span></span><br><span class="line">git config --global user.name <span class="string">&#x27;fengyihang@xx.com&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>系统配置文件: /etc/.gitconig</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --system user.name <span class="string">&#x27;fengyihang&#x27;</span></span><br><span class="line">git config --system user.name <span class="string">&#x27;fengyihang@xx.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意:需要有root权限</span></span><br></pre></td></tr></table></figure><p>应用场景:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gitconfig--<span class="built_in">local</span> user.name <span class="string">&#x27;冯一航&#x27;</span></span><br><span class="line">gitconfig--<span class="built_in">local</span> user.email <span class="string">&#x27;fengyihang@xx.com&#x27;</span></span><br><span class="line">gitconfig--<span class="built_in">local</span> merge.tool bc3</span><br><span class="line">gitconfig--<span class="built_in">local</span> mergetool.path <span class="string">&#x27;/usr/local/bin/bcomp&#x27;</span></span><br><span class="line">gitconfig--<span class="built_in">local</span> mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>git remote add origin 地址  ,默认添加在本地配置文件中(—local)</p><h4 id="3-2-免密码登录"><a href="#3-2-免密码登录" class="headerlink" title="3.2 免密码登录"></a>3.2 免密码登录</h4><ul><li>URL中体现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原来的地址:  https://github.com/Fengyihang/dbhot.git</span><br><span class="line">修改的地址:  https://用户名:密码@github.com/Fengyihang/dbhot.git  </span><br><span class="line">git remote add origin https://用户名:密码@github.com/Fengyihang/dbhot.git git push origin master</span><br></pre></td></tr></table></figure><ul><li>SSH实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 生成公钥和私钥(默认放在  ~/.ssh目录下,  id_rsa.pub公钥、  id_rsa私钥) ssh-keygen</span><br><span class="line">2. 拷贝公钥的内容,并设置到github中。</span><br><span class="line">3. 在git本地中配置ssh地址</span><br><span class="line">git remote add origin git@github.com:Fengyihang/dbhot.git</span><br><span class="line"></span><br><span class="line">4. 以后使用</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>git自动管理凭证</li></ul><h4 id="3-3-git忽略文件"><a href="#3-3-git忽略文件" class="headerlink" title="3.3 git忽略文件"></a>3.3 git忽略文件</h4><p>让Git不再管理当前目录下的某些文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*.h</span><br><span class="line">!a.h</span><br><span class="line">files/</span><br><span class="line">*.py[c|a|d]</span><br></pre></td></tr></table></figure><p>更多参考: <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p><h4 id="3-4-github任务管理相关"><a href="#3-4-github任务管理相关" class="headerlink" title="3.4 github任务管理相关"></a>3.4 github任务管理相关</h4><ul><li>issues ,文档以及任务管理。</li><li>wiki ,项目文档。</li></ul><p>结语<br>好好学习天天向上, 希望git实战课程对你能够有所帮助,更多资源关注:</p><p>Notion：<a href="https://www.notion.so/Git-e623a6fa739a46eebd6c6646955c41c8">https://www.notion.so/Git-e623a6fa739a46eebd6c6646955c41c8</a></p><p>PDF：<a href="https://www.notion.so/Git-e623a6fa739a46eebd6c6646955c41c8#d173f23264714f6f9db110660db0fade">https://www.notion.so/Git-e623a6fa739a46eebd6c6646955c41c8#d173f23264714f6f9db110660db0fade</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粗学IIC</title>
      <link href="/post/11f9a402.html"/>
      <url>/post/11f9a402.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、IIC简介"><a href="#一、IIC简介" class="headerlink" title="一、IIC简介"></a>一、IIC简介</h1><p><strong>I2C（Inter-Integrated Circuit，集成线路总线） 总线</strong>是由飞利浦(Philips)公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。</p><p>I2C 总线支持任何IC 生产过程(NMOS CMOS、 双极性)。两线――串行数据（SDA） 和串行时钟 （SCL） 线在连接到总线的器件间传递信息。 每个器件都有一个唯一的地址识别（无论是微控制器——MCU、 LCD 驱动器、 存储器或键盘接口） ， 而且都可以作为一个发送器或接收器（由器件的功能决定) 。<br>在 <code>CPU 与被控 IC 之间</code>、 <code>IC 与 IC 之间进行双向传送</code>， 高速 IIC 总线一般<u>可达 400kbps 以上</u>。<br>I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：==开始信号、结束信号和应答信号==。</p><h1 id="二、I2C总线物理拓补结构（主从模式）"><a href="#二、I2C总线物理拓补结构（主从模式）" class="headerlink" title="二、I2C总线物理拓补结构（主从模式）"></a>二、I2C总线物理拓补结构（主从模式）</h1><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/IIC%E6%80%BB%E7%BA%BF%E7%89%A9%E7%90%86%E6%8B%93%E6%89%91.jpg" alt="IIC总线物理拓扑"></p><p>一般情况下，数据线SDA和时钟线SCL都是处于上拉电阻状态。因为：在总线空闲状态时，这两根线一般被上面所接的上拉电阻拉高，保持着高电平。<font color=red>(上拉电阻一般在4.7k~10k之间，默认拉高)</font></p><p>数据的传输速率在标准模式下可达100kbit/s，在快速模式下可达400kbit/s，在高速模式（Hs模式）下可达3.4Mbit/s，各种被控器件均并联在总线上，通过器件地址（每个器件的地址在器件手册有些）识别。</p><p>一般我们使用的I2C总线速度小于400Kbit/s。</p><p>由于I2C器件一般采用开漏结构与总线连接，所以SCL和SDA线均接上拉电阻</p><h1 id="三、I2C时序"><a href="#三、I2C时序" class="headerlink" title="三、I2C时序"></a>三、I2C时序</h1><p>IIC总线在传输数据的过程的信号中，<strong><u>起始信号</u>是必需的</strong>，<strong>结束信号和应答信号，都可以不要</strong>。同时我们还要介绍其<code>空闲状态、数据的有效性、数据传输</code>。</p><p>IIC总线的时序图：</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/iic%E6%97%B6%E5%BA%8F.jpg" alt="iic时序"></p><p>简化了的时序图</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/start_stop.jpg" alt="start_stop"></p><h2 id="空闲状态"><a href="#空闲状态" class="headerlink" title="空闲状态"></a>空闲状态</h2><p><strong>当IIC总线的数据线SDA和时钟线SCL两条信号线同时处于高电平时，规定为总线的空闲状态。</strong>此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。 </p><h2 id="起始信号与停止信号"><a href="#起始信号与停止信号" class="headerlink" title="起始信号与停止信号"></a>起始信号与停止信号</h2><ul><li><p><strong>起始信号：</strong>当时钟线SCL为高电平时，数据线SDA由高到低低电的跳变；(启动信号是一种电平跳变时序信号，而不是一个电平信号)</p></li><li><p><strong>停止信号：</strong>当时钟线SCL为高电平时，数据线SDA由低到高低电的跳变；(停止信号也是一种电平跳变时序信号，而不是一个电平信号)</p></li></ul><h2 id="应答信号"><a href="#应答信号" class="headerlink" title="应答信号"></a>应答信号</h2><p>发送器每发送一个字节（8个bit），就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。 </p><ul><li><p>应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；</p></li><li><p>应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。 </p></li></ul><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/ACK.jpg" alt="ACK"></p><p>对于反馈有效应答位ACK的要求是：接收器在第9个时钟脉冲之前的低电平期间将数据线SDA拉低，并且确保在该时钟的高电平期间为稳定的低电平。 <strong>如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放数据线SDA，以便主控接收器发送一个停止信号P。</strong></p><h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><p><strong>IIC总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定；只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。</strong> </p><p>即：<strong>数据在时钟线SCL的上升沿到来之前就需准备好。并在在下降沿到来之前必须稳定。</strong></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/stable.jpg" alt="stable"></p><h3 id="数据的传达"><a href="#数据的传达" class="headerlink" title="数据的传达"></a>数据的传达</h3><p>在IIC总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。数据位的传输是边沿触发。</p><h3 id="延时时间"><a href="#延时时间" class="headerlink" title="延时时间"></a>延时时间</h3><p>可以查手册，也可以直接浏览下方图：</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/delay_time.jpg" alt="delay_time"></p><h2 id="IIC总线的数据传送"><a href="#IIC总线的数据传送" class="headerlink" title="IIC总线的数据传送"></a>IIC总线的数据传送</h2><p><strong>IIC总线上的每一个设备都可以作为主设备或者从设备，而且每一个设备都会对应一个唯一的地址（地址通过物理接地或者拉高），主从设备之间就通过这个地址来确定与哪个器件进行通信</strong>，在通常的应用中，我们把CPU带I2C总线接口的模块作为主设备，把挂接在总线上的其他设备都作为从设备。</p><p>也就是说，<strong>主设备在传输有效数据之前要先指定从设备的地址，地址指定的过程和上面数据传输的过程一样，只不过大多数从设备的地址是7位的，然后协议规定再给地址添加一个最低位用来表示接下来数据传输的方向，0表示主设备向从设备写数据，1表示主设备向从设备读数据。</strong></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/shixutu.jpg" alt="shixutu"></p><ul><li><strong>主设备往从设备中写数据。数据传输格式如下：</strong></li></ul><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/w_data.jpg" alt="w_data"></p><p>淡蓝色部分表示数据由主机向从机传送，粉红色部分则表示数据由从机向主机传送。</p><p><strong>写用0来表示（高电平），读用1来表示（低电平）。</strong></p><ul><li><strong>主设备从从设备中读数据。数据传输格式如下：</strong></li></ul><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/r_data.jpg" alt="r_data"></p><p><strong>在从机产生响应时，主机从发送变成接收，从机从接收变成发送。之后，数据由从机发送，主机接收，每个应答由主机产生，时钟信号仍由主机产生。若主机要终止本次传输，则发送一个非应答信号，接着主机产生停止条件。</strong></p><ul><li>主设备往从设备中写数据，然后重启起始条件，紧接着从从设备中读取数据；或者是主设备从从设备中读数据，然后重启起始条件，紧接着主设备往从设备中写数据。数据传输格式如下：</li></ul><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/rw_data.jpg" alt="rw_data"></p><p>在多主的通信系统中，总线上有多个节点，它们都有自己的寻址地址，可以作为从节点被别的节点访问，同时它们都可以作为主节点向其它的节点发送控制字节和传送数据。但是如果有两个或两个以上的节点都向总线上发送启动信号并开始传送数据，这样就形成了冲突。要解决这种冲突，就要进行仲裁的判决，这就是I2C总线上的仲裁。</p><p><strong>I2C总线上的仲裁分两部分：SCL线的同步和SDA线的仲裁。</strong></p><p>这部分就暂时不介绍了，想要了解：可以参考链接<a href="https://blog.csdn.net/bluewhaletech/article/details/37876111">浅谈I2C总线</a>或<a href="http://www.cnblogs.com/aaronLinux/p/6218660.html">I2C总线协议图解</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iic </tag>
            
            <tag> 时序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学物联网之ESP8266NodeMCU（五）</title>
      <link href="/post/e2f4da2.html"/>
      <url>/post/e2f4da2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、ESP8266闪存文件系统基本操作"><a href="#一、ESP8266闪存文件系统基本操作" class="headerlink" title="一、ESP8266闪存文件系统基本操作"></a>一、<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-operation/">ESP8266闪存文件系统基本操作</a></h1><p>当我们上传程序给ESP8266时，我们的程序具体存放在什么地方呢？</p><p>每一个ESP8266都配有一个闪存，这个闪存很像是一个小硬盘，我们上传的文件就被存放在这个闪存里。这个闪存的全称是Serial Peripheral Interface Flash File System（SPIFFS）。</p><p>除了可以存放上传的程序以外，我们还可以将网页文件或者系统配置文件存放在ESP8266的闪存中。在这节课里，我们将学习如何利用程序对闪存文件系统（SPIFFS）进行文件读取和修改。</p><h2 id="1、通过程序向闪存文件系统写入信息"><a href="#1、通过程序向闪存文件系统写入信息" class="headerlink" title="1、通过程序向闪存文件系统写入信息"></a>1、通过程序向闪存文件系统写入信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project           : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-write</span></span><br><span class="line"><span class="comment">团队/Team                 : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何向NodeMCU的SPIFFS中建立名为</span></span><br><span class="line"><span class="comment">                            notes.txt的文件，程序还将向该文件写入信息。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;w&quot;); </span></span><br><span class="line"><span class="comment">以上函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;w&quot; 代表写入文件信息。（如需了解如何读取信息，请参阅示例程序esp8266-flash-read）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span>  <span class="comment">//★★★</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>; <span class="comment">//被读取的文件位置和名称★★★</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS format start&quot;</span>);</span><br><span class="line">  SPIFFS.format();    <span class="comment">// 格式化SPIFFS★★★</span></span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS format finish&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动SPIFFS★★★</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;w&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息★★★</span></span><br><span class="line">  dataFile.println(<span class="string">&quot;Hello IOT World.&quot;</span>);       <span class="comment">// 向dataFile写入字符串信息★★★</span></span><br><span class="line">  dataFile.close();                           <span class="comment">// 完成文件写入后关闭文件★★★</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Finished Writing data to SPIFFS&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用SPIFFS存储文件以前，我们必须使用<code>#include &quot;FS.h&quot;</code>,如以上程序第18行所示。</p><p>程序第20行，我们建立了一个字符串变量。该变量用于存储文件位置和文件名。其中<code>/</code>代表根目录。<code>/taichi-maker/</code>代表根目录下的<code>taichi-maker</code>目录。<code>notes.txt</code>代表着文件名称。</p><p>程序第27行<code>SPIFFS.format();</code>是对闪存文件系统进行格式化。这很想是我们对u盘进行格式化的操作。您无需每次使用闪存文件系统都对它进行格式化操作。这里仅仅是为了演示如何使用<code>SPIFFS.format();</code>。</p><p>程序第30行，<code>SPIFFS.begin()</code>用于启动闪存文件系统。在每次使用闪存文件系统以前都需要执行这一操作。如果闪存文件系统成功启动，该函数的返回值为布尔型，如果成功启动闪存文件形同，则返回真。否则将返回假。</p><p>程序第36行，<code>File dataFile = SPIFFS.open(file_name, &quot;w&quot;);</code>这条语句中，open函数可用于对SPIFFS进行操作。该函数共有两个参数。第一个参数<code>file_name</code>是被操作的文件名称，本示例中该文件为/taichi-maker/notes.txt<br>第二个参数<code>&quot;w&quot;</code>代表此操作为向SPIFFS写入文件信息。请注意：如果文件系统没有/taichi-maker/notes.txt文件，此操作将会在文件系统中建立该文件。如果文件系统有该文件，则程序将会重新建立该文件，即原有文件信息将会被覆盖。</p><p>程序第37行<code>dataFile.println(&quot;Hello IOT World.&quot;);</code>用于向dataFile文件写入信息。信息内容为“Hello IOT World.”。</p><p>程序第38行<code>dataFile.close();</code>用于关闭dataFile文件。结束文件操作后，应执行此操作。</p><h2 id="2、通过程序从闪存文件系统读取信息"><a href="#2、通过程序从闪存文件系统读取信息" class="headerlink" title="2、通过程序从闪存文件系统读取信息"></a>2、通过程序从闪存文件系统读取信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project           : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-read</span></span><br><span class="line"><span class="comment">团队/Team                 : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何从NodeMCU的内置SPIFFS中存储的文件notes.txt读取数据。</span></span><br><span class="line"><span class="comment">                           notes.txt 文件内容将会通过串口监视器显示出来供用户确认。</span></span><br><span class="line"><span class="comment">                           注意在使用本程序以前需要先将notes.txt 文件上传到NodeMCU开发板的SPIFFS中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;r&quot;); </span></span><br><span class="line"><span class="comment">以上SPIFFS函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;r&quot; 代表读取文件信息。（如需了解如何写入信息，请参阅示例程序esp8266-flash-write）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//确认闪存中是否有file_name文件★★★</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.exists(file_name))&#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; FOUND.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.print(<span class="string">&quot; NOT FOUND.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//建立File对象用于从SPIFFS中读取文件★★★</span></span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;r&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//读取文件内容并且通过串口监视器输出文件信息★★★</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;dataFile.size(); i++)&#123;</span><br><span class="line">    Serial.print((<span class="type">char</span>)dataFile.read());       </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//完成文件读取后关闭文件</span></span><br><span class="line">  dataFile.close();                           </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序第36行，<code>SPIFFS.exists(file_name)</code>用于检查闪存文件系统中有file_name文件（注：file_name变量具体信息在本程序第23行）。该函数返回值为布尔型。如果文件存在则返回真，否则将返回假。</p><p>以上程序第45行，<code>File dataFile = SPIFFS.open(file_name, &quot;r&quot;);</code>这条语句中，open函数可用于对SPIFFS进行操作。该函数共有两个参数。第一个参数<code>file_name</code>是被操作的文件名称，本示例中该文件为/taichi-maker/notes.txt<br>第二个参数<code>&quot;r&quot;</code>代表此操作为读取文件信息。</p><p>以上程序第48行的for循环语句中，循环条件使用了函数<code>dataFile.size()</code>。该函数将会返回dataFile的大小。循环语句体中，<code>dataFile.read()</code>将会读取dataFile文件内容。每调用一次该含税都会返回dataFile文件中一个字符。再次调用，将会返回下一个字符。以此类推，直到dataFile结尾。通过for循环语句，程序将会依次读取dataFile文件内容，并且将文件内容逐字符输出于串口监视器中。</p><h2 id="3、通过程序向闪存文件系统文件添加信息"><a href="#3、通过程序向闪存文件系统文件添加信息" class="headerlink" title="3、通过程序向闪存文件系统文件添加信息"></a>3、通过程序向闪存文件系统文件添加信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project           : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-append</span></span><br><span class="line"><span class="comment">团队/Team                 : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何向NodeMCU的内置SPIFFS中存储的文件</span></span><br><span class="line"><span class="comment">                            notes.txt添加数据。                      </span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;a&quot;); </span></span><br><span class="line"><span class="comment">以上SPIFFS函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;a&quot; 代表添加文件信息。（如需了解如何读取信息，请参阅示例程序esp8266-flash-read）</span></span><br><span class="line"><span class="comment">此示例程序所演示的是向SPIFFS中的文件里添加信息。这一操作写入信息有所区别。</span></span><br><span class="line"><span class="comment">添加信息是不会删除文件内原有信息，而是在原有信息后面添加新的信息。</span></span><br><span class="line"><span class="comment">但写入操作（示例 esp8266-flash-write.ino）是将文件内容完全清除，重新写入新信息。    </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//确认闪存中是否有file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.exists(file_name))&#123;</span><br><span class="line">    </span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; FOUND.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    File dataFile = SPIFFS.open(file_name, <span class="string">&quot;a&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息★★★</span></span><br><span class="line">    dataFile.println(<span class="string">&quot;This is Appended Info.&quot;</span>); <span class="comment">// 向dataFile添加字符串信息★★★</span></span><br><span class="line">    dataFile.close();                           <span class="comment">// 完成文件操作后关闭文件★★★   </span></span><br><span class="line">    Serial.println(<span class="string">&quot;Finished Appending data to SPIFFS&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.print(<span class="string">&quot; NOT FOUND.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上程序的第40行里，<code>File dataFile = SPIFFS.open(file_name, &quot;a&quot;);</code>这条语句中，open函数可用于对SPIFFS进行操作。该函数共有两个参数。第一个参数<code>file_name</code>是被操作的文件名称,第二个参数<code>&quot;a&quot;</code>代表向该文件添加信息。请留意，此处的添加信息是不会删除文件内原有信息，而是在原有信息后面添加新的信息。这与但写入操作是有所区别的。写入操作是将文件内容完全清除，重新写入新信息。<br>,<br>程序的第41行，<code>dataFile.println(&quot;This is Appended Info.&quot;)</code>，此语句作用将会向dataFile文件尾部添加双引号中的信息内容，也就是在文件尾部添加“This is Appended Info.”。</p><h2 id="4、通过程序读取目录内容"><a href="#4、通过程序读取目录内容" class="headerlink" title="4、通过程序读取目录内容"></a>4、通过程序读取目录内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project           : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-folder-read</span></span><br><span class="line"><span class="comment">团队/Team                 : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何从NodeMCU的内置SPIFFS中文件夹里读取文件信息</span></span><br><span class="line"><span class="comment">                           文件夹内容将会通过串口监视器显示出来。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.openDir(folder_name);</span></span><br><span class="line"><span class="comment">以上函数打开指定目录并返回一个目录对象实例。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/myFile.txt&quot;</span>; <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line">String folder_name = <span class="string">&quot;/taichi-maker&quot;</span>;         <span class="comment">//被读取的文件夹★★★</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;w&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即myFile.txt）写入信息</span></span><br><span class="line">  dataFile.println(<span class="string">&quot;Hello Taichi-Maker.&quot;</span>);    <span class="comment">// 向dataFile写入字符串信息</span></span><br><span class="line">  dataFile.close();                           <span class="comment">// 完成文件写入后关闭文件</span></span><br><span class="line">  Serial.println(F(<span class="string">&quot;Finished Writing data to SPIFFS&quot;</span>));</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 显示目录中文件内容以及文件大小</span></span><br><span class="line">  Dir dir = SPIFFS.openDir(folder_name);  <span class="comment">// 建立“目录”对象★★★</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (dir.next()) &#123;  <span class="comment">// dir.next()用于检查目录中是否还有“下一个文件”★★★</span></span><br><span class="line">    Serial.println(dir.fileName()); <span class="comment">// 输出文件名★★★</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序第23行建立了一个字符串变量。该变量用于存储文件夹名。其中<code>/</code>代表根目录。<code>/taichi-maker/</code>代表根目录下的<code>taichi-maker</code>目录。</p><p>本程序第41行<code>SPIFFS.openDir(folder_name)</code>中的openDir函数函将返回一个“目录”对象并且赋值给dir。此”目录”对象正是folder_name所存储的<code>/taichi-maker/</code>目录。后续程序对dir的所有操作都是针对<code>/taichi-maker/</code>所执行的。</p><p>本程序第43行while循环语句的循环条件是<code>dir.next()</code>的返回值。<code>dir.next()</code>函数用于检查dir文件夹内的文件。我们可以想象dir文件夹里有一个指针，每一次调用next函数都会让指针向下挪动一格。每一次挪动一格，如果下一个位置有文件，则返回真。否则将会返回假。因此，<code>while (dir.next())</code>循环语句中的内容会依次显示dir文件夹中的每一个文件的文件名。</p><h2 id="5、从闪存文件系统中删除文件"><a href="#5、从闪存文件系统中删除文件" class="headerlink" title="5、从闪存文件系统中删除文件"></a>5、从闪存文件系统中删除文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project           : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-remove</span></span><br><span class="line"><span class="comment">团队/Team                 : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何删除SPIFFS中存储的文件       </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//从闪存中删除file_name文件★★★</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.remove(file_name))&#123;</span><br><span class="line">    </span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; remove sucess&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; remove fail&quot;</span>);</span><br><span class="line">  &#125;                       </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序中第25行，通过使用<code>SPIFFS.remove(file_name)</code>将<code>file_name</code>所指代的文件进行了删除操作。另外，<code>SPIFFS.remove(file_name)</code>的返回值为布尔型。如果文件删除执行成功则返回真，否则返回假。</p><h2 id="6、显示闪存文件系统信息"><a href="#6、显示闪存文件系统信息" class="headerlink" title="6、显示闪存文件系统信息"></a>6、显示闪存文件系统信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project           : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-info</span></span><br><span class="line"><span class="comment">团队/Team                 : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何使用FSInfo对象来显示闪存文件系统状态</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">FSInfo fs_info;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line"> </span><br><span class="line">  SPIFFS.begin();       <span class="comment">//启动SPIFFS</span></span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 闪存文件系统信息</span></span><br><span class="line">  SPIFFS.info(fs_info);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 可用空间总和（单位：字节）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;totalBytes: &quot;</span>);     </span><br><span class="line">  Serial.print(fs_info.totalBytes); </span><br><span class="line">  Serial.println(<span class="string">&quot; Bytes&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 已用空间（单位：字节）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;usedBytes: &quot;</span>); </span><br><span class="line">  Serial.print(fs_info.usedBytes);</span><br><span class="line">  Serial.println(<span class="string">&quot; Bytes&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最大文件名字符限制（含路径和&#x27;\0&#x27;）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;maxPathLength: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.maxPathLength);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最多允许打开文件数量</span></span><br><span class="line">  Serial.print(<span class="string">&quot;maxOpenFiles: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.maxOpenFiles);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 存储块大小</span></span><br><span class="line">  Serial.print(<span class="string">&quot;blockSize: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.blockSize);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 存储页大小</span></span><br><span class="line">  Serial.print(<span class="string">&quot;pageSize: &quot;</span>);</span><br><span class="line">  Serial.println(fs_info.pageSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序第16行语句<code>FSInfo fs_info;</code>建立了FSInfo 对象，用于存储闪存状态信息。</p><p>以上程序第26行语句<code>SPIFFS.info(fs_info);</code>。通过info函数将闪存状态信息赋给fs_info。后续的程序中，通过一系列语句将闪存状态信息通过串口监视器输出。具体信息内容可参考程序注释部分。</p><p>以上是关于ESP8266闪存文件系统的常用功能介绍。关于ESP8266闪存文件系统的更多操作介绍，请参考Arduino ESP8266官方页面中的介绍部分。该页面可点击以下链接前往。</p><p><a href="https://arduino-esp8266.readthedocs.io/en/latest/filesystem.html">https://arduino-esp8266.readthedocs.io/en/latest/filesystem.html</a></p><h1 id="二、通过Arduino-IDE向闪存文件系统上传文件"><a href="#二、通过Arduino-IDE向闪存文件系统上传文件" class="headerlink" title="二、通过Arduino IDE向闪存文件系统上传文件"></a>二、<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/upload-files/">通过Arduino IDE向闪存文件系统上传文件</a></h1><h2 id="1、下载-Arduino-ESP8266闪存文件插件程序"><a href="#1、下载-Arduino-ESP8266闪存文件插件程序" class="headerlink" title="1、下载 Arduino-ESP8266闪存文件插件程序"></a>1、下载 Arduino-ESP8266闪存文件插件程序</h2><p>您有两种方法可以下载该插件程序。</p><p><strong>第一种</strong>方法是通过<a href="https://github.com/esp8266/arduino-esp8266fs-plugin/releases">点击此链接进入 Arduino-ESP8266官方GitHub页面下载</a>。详情请见以下截图：</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266fs-download.jpg" alt="esp8266fs下载页面"></p><p>由于GitHub网站服务器在国外，有些朋友登录该网站会有些困难。如果是这样的话，那么您也可以<a href="http://www.taichi-maker.com/homepage/download/#esp8266fs">点击此链接进入太极创客网站下载页面去下载该插件</a>。</p><h2 id="2、确定Arduino-IDE项目文件夹位置"><a href="#2、确定Arduino-IDE项目文件夹位置" class="headerlink" title="2、确定Arduino IDE项目文件夹位置"></a>2、确定Arduino IDE项目文件夹位置</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/Arduino-ide-preferences.jpg" alt="Arduino-ide-首选项菜单项"></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/Arduino-Project-Folder.jpg" alt="Arduino-IDE-项目文件夹位置"></p><h2 id="3、通过资源管理器打开Arduino-IDE项目文件夹并建立tools文件夹"><a href="#3、通过资源管理器打开Arduino-IDE项目文件夹并建立tools文件夹" class="headerlink" title="3、通过资源管理器打开Arduino IDE项目文件夹并建立tools文件夹"></a>3、通过资源管理器打开Arduino IDE项目文件夹并建立tools文件夹</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266fs-tools-folder.jpg" alt="在项目文件夹中建立名称为tools的文件夹"></p><h2 id="4、解压缩esp8266fs插件压缩包，并将解压缩后的文件内容粘贴到项目文件夹中"><a href="#4、解压缩esp8266fs插件压缩包，并将解压缩后的文件内容粘贴到项目文件夹中" class="headerlink" title="4、解压缩esp8266fs插件压缩包，并将解压缩后的文件内容粘贴到项目文件夹中"></a>4、解压缩esp8266fs插件压缩包，并将解压缩后的文件内容粘贴到项目文件夹中</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266fs-unzip.jpg" alt="esp8266fs解压缩"></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266fs-unzipped.jpg" alt="解压缩后可找到esp8266fs文件夹"></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266fs-paste.jpg" alt="将esp8266fs文件夹粘贴到tools文件夹里"></p><h2 id="5、重新启动Arduino-IDE"><a href="#5、重新启动Arduino-IDE" class="headerlink" title="5、重新启动Arduino IDE"></a>5、重新启动Arduino IDE</h2><h2 id="检查“工具”菜单确认插件安装"><a href="#检查“工具”菜单确认插件安装" class="headerlink" title="检查“工具”菜单确认插件安装"></a>检查“工具”菜单确认插件安装</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266-data-upload-menu.jpg" alt="ESP8266 data upload 菜单项"></p><h2 id="6、根据上传的文件总大小来设置闪存大小"><a href="#6、根据上传的文件总大小来设置闪存大小" class="headerlink" title="6、根据上传的文件总大小来设置闪存大小"></a>6、根据上传的文件总大小来设置闪存大小</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266-flash-size-settings.jpg" alt="设置esp8266闪存大小"></p><h2 id="7、将需要上传的文件保存在程序路径下的data文件夹中"><a href="#7、将需要上传的文件保存在程序路径下的data文件夹中" class="headerlink" title="7、将需要上传的文件保存在程序路径下的data文件夹中"></a>7、将需要上传的文件保存在程序路径下的data文件夹中</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266-flash-data-storage.jpg" alt="将需要上传到esp8266闪存文件系统的文件保存在data目录中"></p><h2 id="8、将需要上传的文件保存在程序路径下的data文件夹中"><a href="#8、将需要上传的文件保存在程序路径下的data文件夹中" class="headerlink" title="8、将需要上传的文件保存在程序路径下的data文件夹中"></a>8、将需要上传的文件保存在程序路径下的data文件夹中</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266-flash-data-upload.jpg" alt="通过ESP8266 Sketch Data Upload可以将data文件夹里的文件上传"></p><p>假如您不确定具体文件如何存储，请点击以下链接下载示例程序压缩包。<br><a href="http://www.taichi-maker.com/wp-content/uploads/2020/02/esp8266-data-upload.zip">文件上传示例程序</a></p><h1 id="三、使用闪存文件系统建立功能丰富的网络服务器"><a href="#三、使用闪存文件系统建立功能丰富的网络服务器" class="headerlink" title="三、使用闪存文件系统建立功能丰富的网络服务器"></a>三、<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/">使用闪存文件系统建立功能丰富的网络服务器</a></h1><p>掌握了如何向ESP8266开发板的闪存文件上传文件，我们就有了更多的空间来存储更加丰富的网页资源，从而让我们实现功能更加丰富的物联网项目。</p><p>本节教程里，我们将向您介绍一系列ESP8266开发板搭建的网页服务示例。通过这些示例，您可以通过物联网控制ESP8266开发板的引脚以及获取引脚状态。这些示例的功能相对单一，这是因为这些示例的目的是为您提供项目搭建的启发。在后续的教程中里，我们和为您提供一系列完整的物联网项目示例，供您学习参考。</p><ul><li><h2 id="在网页中加载闪存文件系统中的图片、CSS和JavaScript"><a href="#在网页中加载闪存文件系统中的图片、CSS和JavaScript" class="headerlink" title="在网页中加载闪存文件系统中的图片、CSS和JavaScript"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/load-imagecsss-javascript/">在网页中加载闪存文件系统中的图片、CSS和JavaScript</a></h2></li><li><h2 id="通过网页控制ESP8266开发板的引脚"><a href="#通过网页控制ESP8266开发板的引脚" class="headerlink" title="通过网页控制ESP8266开发板的引脚"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/esp8266-pin-control/">通过网页控制ESP8266开发板的引脚</a></h2></li><li><h2 id="通过网页文本框控制ESP8266开发板的PWM引脚"><a href="#通过网页文本框控制ESP8266开发板的PWM引脚" class="headerlink" title="通过网页文本框控制ESP8266开发板的PWM引脚"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/text-pwm-pin-control/">通过网页文本框控制ESP8266开发板的PWM引脚</a></h2></li><li><h2 id="Ajax-控制LED引脚并将A0引脚读数实时显示于网页中"><a href="#Ajax-控制LED引脚并将A0引脚读数实时显示于网页中" class="headerlink" title="(Ajax)控制LED引脚并将A0引脚读数实时显示于网页中"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/a0-pin-control/">(Ajax)控制LED引脚并将A0引脚读数实时显示于网页中</a></h2></li><li><h2 id="JavaScript-通过网页图形界面控制ESP8266的PWM引脚"><a href="#JavaScript-通过网页图形界面控制ESP8266的PWM引脚" class="headerlink" title="(JavaScript)通过网页图形界面控制ESP8266的PWM引脚"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/javascript-know-pwm-control/">(JavaScript)通过网页图形界面控制ESP8266的PWM引脚</a></h2></li><li><h2 id="JavaScript-使用指针表显示模拟输入引脚数值"><a href="#JavaScript-使用指针表显示模拟输入引脚数值" class="headerlink" title="(JavaScript)使用指针表显示模拟输入引脚数值"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/javascript-analog-input-gauge/">(JavaScript)使用指针表显示模拟输入引脚数值</a></h2></li><li><h2 id="通过网页将文件上传到ESP8266开发板闪存文件系统"><a href="#通过网页将文件上传到ESP8266开发板闪存文件系统" class="headerlink" title="通过网页将文件上传到ESP8266开发板闪存文件系统"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-web-server/file-upload-server/">通过网页将文件上传到ESP8266开发板闪存文件系统</a></h2></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学物联网之ESP8266NodeMCU（四）</title>
      <link href="/post/84438cc6.html"/>
      <url>/post/84438cc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="建立基本网络服务器"><a href="#建立基本网络服务器" class="headerlink" title="建立基本网络服务器"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/web-server/">建立基本网络服务器</a></h1><p>网络服务是一个很宽泛的概念，我们在这里即将给您介绍的是网络服务中的网页服务功能。所谓<strong>网页服务</strong>就是专门用于网页浏览的服务。这个操作我相信所有看到这篇教程的朋友们都使用过，因为您现在正阅读的这篇教程就是通过网页服务传输到您面前的。</p><p>为了能够应付来自全世界的朋友们大量访问，网站服务器是一台运算能力很强的计算机。假如这个网站只有您自己访问，那么ESP8266-NodeMCU就足够了。下面这个示例程序可以让ESP8266-NodeMCU实现最基本的网页服务功能。请先将这段示例程序复制并且上传NodeMCU。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_1_First_Web_Server</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span><br><span class="line"><span class="comment">                           访问8266所建立的基本网页（Hello from ESP8266）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立ESP8266WebServer对象，对象名称为esp8266_server</span></span><br><span class="line">                                    <span class="comment">// 括号中的数字是网路服务器响应http请求的端口号</span></span><br><span class="line">                                    <span class="comment">// 网络服务器标准http端口号为80，因此这里使用80为端口号</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);          <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//通过addAp函数存储  WiFi名称       WiFi密码</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker&quot;</span>, <span class="string">&quot;12345678&quot;</span>);  <span class="comment">// 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker2&quot;</span>, <span class="string">&quot;87654321&quot;</span>); <span class="comment">// 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker3&quot;</span>, <span class="string">&quot;13572468&quot;</span>); <span class="comment">// 这3个网络的密码分别是123456789，87654321，13572468。</span></span><br><span class="line">                                                <span class="comment">// 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span><br><span class="line">                                                <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//--------&quot;启动网络服务功能&quot;程序部分开始-------- //  此部分为程序为本示例程序重点1</span></span><br><span class="line">  esp8266_server.begin();                   <span class="comment">//  详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);       <span class="comment">//  第3章-第2节 ESP8266-NodeMCU网络服务器-1</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"><span class="comment">//--------&quot;启动网络服务功能&quot;程序部分结束--------</span></span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数语句为本示例程序重点3</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/</span>  </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下两个函数为本示例程序重点2</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/</span>                                                                            </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   <span class="comment">//处理网站根目录“/”的访问请求 </span></span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Hello from ESP8266&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。 </span></span><br><span class="line">&#125;<span class="comment">//这个网站只有一个网页。且网页只有一行文字“Hello from ESP8266”。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传给NodeMCU，启动NodeMCU并且确保它已经成功连接WiFi, 打开浏览器，在地址栏中输入NodeMCU的IP地址并按下回车。</p><p>假如将在浏览器中看到“Hello from ESP8266”(如下所示），那么恭喜您已经成功的让NodeMCU实现了网络服务功能，因为您所看到的这条文字信息正是来自于NodeMCU。换句话说，NodeMCU为您建立了一个超级迷你的小网站。</p><p>首先讲解示例程序的第1个重点内容：<strong>”启动网络服务功能“程序部分</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp8266_server.begin();             </span><br><span class="line">esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);      </span><br><span class="line">esp8266_server.onNotFound(handleNotFound); </span><br></pre></td></tr></table></figure><p>程序第一句<code>esp8266_server.begin()</code>使用了ESP8266WebServer库中的<code>begin</code>函数。这个函数的作用是让ESP8266-NodeMCU来启动网络服务功能。该函数无需任何参数。</p><p>接下来的的语句<code>esp8266_server.on(&quot;/&quot;, handleRoot)</code>相对复杂一些。这条语句调用了ESP8266WebServer库中的<code>on</code>函数，该函数的作用是<strong>指挥NodeMCU来如何处理浏览器的http请求</strong>。我们看到<code>on</code>函数一共有两个参数，第一个参数是字符串”/”，第二个参数是一个函数的名称handleRoot。这个handleRoot函数的具体内容，我后面会给您做详细讲解。现在请您留意<code>on</code>函数有两个参数，一个是字符串”/”，另一个是函数名handleRoot。</p><p>下面我来给您仔细解释一下参数”/”的作用。我们知道一个网站有很多页面。为了加以区分，这些页面都有各自的名称。对于刚刚您在浏览器看到的“Hello from ESP8266”这个页面是NodeMCU服务器中的网站首页。这个网站首页的名称正是”/”。目前的ESP8266-NodeMCU服务器中只有一页，因此我们还无法了解如果想要调用其他页面该如何操作。不过请别担心，这个操作我们会在下一个示例程序中为您讲解。</p><p>好了，现在请将您的思绪拉回到我们的NodeMCU程序中来。接下来我们来看<code>on</code>函数的第二个参数。这个参数是<code>handleRoot</code>函数的名字。<code>handlRoot</code>函数的主要作用是告诉NodeMCU该如何生成和发送网站首页给浏览器。不过关于这个<code>handleRoot</code>函数的具体内容，我会在接下来的教程中给您做详细讲解。现在我们需要把关注点集中在<code>on</code>函数上。</p><p>最后我们再来完整的看一下这条语句<code>esp8266_server.on(&quot;/&quot;, handleRoot)</code>。它的作用就是告诉NodeMCU，当有浏览器请求网站首页时，请执行handlRoot函数来生成网站首页内容然后发送给浏览器。</p><p>讲到这里不知道您会不会感到好奇。我们只是在浏览器地址栏输入了NodeMCU的IP地址，然后就按下了回车。浏览器怎么会知道我们需要的是网站的首页呢。这是浏览器约定俗成的一种操作方法。当我们在地址栏只输入IP地址而没有任何附加地址信息，浏览器就会知道我们是要获取一个网站的首页信息。</p><p>结束了<code>on</code>函数的讲解，我们来继续往下看。下面一条语句<code>esp8266_server.onNotFound(handleNotFound)</code>使用了<code>onNotFound</code>函数。它的作用是<strong>指挥NodeMCU在收到无法满足的http请求时应该如何处理</strong>。目前Hello from ESP8266网站只有一个页面。假如有人想要浏览网站的其它页面，NodeMCU是无法满足这一请求的。这时候我们可以让NodeMCU答复一个“错误提示”页面给提出请求的浏览器。<code>onNotFound</code>函数就是用来告诉NodeMCU如果出现无法满足的http请求时该如何进行处理。<code>onNotFound</code>函数有一个参数，这个参数的内容是函数<code>handleNotFound</code>的名字。  </p><p>假设现在我们通过浏览器向NodeMCU服务器请求一个名叫“LED”的页面。由于NodeMCU的程序里没有“LED”页面信息，因此需要给浏览器答复一个“错误提示”页面。<code>onNotFound</code>的作用就是告诉NodeMCU在遇到这种无法满足的http请求时，应该执行<code>handleNotFound</code>函数来生成并发送“错误提示”页面给浏览器。</p><p>为了验证这一功能，我们来做一个实验。请在浏览器中输入NodMCU的IP地址然后加一个“/LED”再回车。比如下图所示，我的NodeMCU的IP地址是192.168.0.109，那么当我在浏览器栏中输入<code>192.168.0.109/LED</code>然后回车，就会看到浏览器显示出文字404: Not found。</p><p>这里我们所看到的这行文字“404: Not found”正是因为NodeMCU没有名叫“LED”的页面，因此它会使用handleNotFound函数生成并发送给浏览器这个“错误提示”页面。既然讲到这里了，那么我们就来仔细看一看handleNotFound函数的具体内容。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                </span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleNotFound函数只有一条语句： <code>esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;)</code>。这条语句调用了ESP8266WebServer库中的<code>send</code>函数。该函数的作用是生成并且发送http响应信息。也就是说，电脑浏览器所收到的网页信息都是通过<code>send</code>函数生成并且发送的。那么具体这个网页信息是如何生成的呢？这就要仔细看看<code>send</code>函数的几个参数内容了。  </p><p>首先我们来看第一个参数404。这个数字对于很多朋友来说都不会感到陌生，在<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/application-layer/#http-response">互联网基础-应用层</a>的http响应部分对它做过介绍。404是一个服务器状态码。它的含义是“客户端的请求有错误”。也就是说，浏览器在收到了状态码404后就知道，它所请求的页面在服务器上是不存在的。请留意，这个服务器状态码是专门给浏览器用的。我们是看不到它的。为了让我们也看到页面不存在的出错信息，<code>send</code>函数的最后一个参数使用了一个字符串”404: Not found”。这个字符串的内容才是真正显示在浏览器中供我们阅读的内容。你可以任意的改变这个字符串的内容。  </p><p>到这里我们来小结一下。浏览器能够看懂的信息是send函数的第一个参数,它的类型是整数型，它的内容是数字404。而显示在浏览器中的出错信息是一个字符串型的参数。它是send函数的最后一个参数。在我们的示例程序里，它的内容是“404: Not found”。</p><p><code>send</code>函数还有一个字符串参数“text/plain”。它的作用是<strong>说明http响应体的信息类型</strong>。在这段示例中，我们用“text/plain”的原因是要告诉浏览器后面的”404: Not found”为一段纯文本信息。这里当然也可以使用其它类型的信息。不过这一知识我们后续教程中会给您介绍。</p><p>为了让您更好的理解刚刚给您解释的内容，我来对这句<code>esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;)</code>做一下总结。</p><p>send函数一共有3个参数。第一个参数404是服务器状态码。第二个参数“text/plain”是说明http响应体信息类型。第三个参数“404: Not found”则是响应体的具体信息了。</p><p>细心的读者可能已经发现了。我在上面这段总结文字中指明了响应体这一概念。http响应是分为两部分的。第一部分是响应头，在我们这个示例中，响应头的内容就是404 text/plain。而响应体的内容则是404: Not found。</p><p>结束了handleNotFound的讲解我们最后再来看看示例程序中另一个用于生成和发送首页信息的函数：<code>handleRoot</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;                         </span><br><span class="line">    esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Hello from ESP8266&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段示例程序与刚刚我们见到的handleNotFound函数非常相似。都是使用<code>send</code>函数生成并且发送http响应信息。</p><p><code>send</code>函数的第一个参数200，它同样是一个服务器状态码，含义是“成功接收请求，并已完成整个处理过程”。 第二个参数text/plain的作用我刚刚给您讲过，不再赘述了。最后一个参数”Hello from ESP8266″正是我们在浏览器中看到的首页文字内容。</p><p>最后我们来看一下这段示例程序的第3个重点内容，也就是loop函数中唯一的一条语句<code>esp8266_server.handleClient()</code>。这句程序调用了<code>handleClient</code>函数。它的主要作用之一是检查有没有设备通过网络向NodeMCU发送请求。<code>函数handleClient</code>每次被调用时，NodeMCU都会检查一下是否有人发送http请求。因此我们需要把它放在loop函数中，从而确保它能经常被调用。假如我们的loop函数里有类似delay一类的函数延迟程序运行，那么这时候就一定要注意了。如果<code>handleClient</code>函数长时间得不到调用，NodeMCU的网络服务会变得很不稳定。因此在使用NodeMCU执行网络服务功能的时候，一定要确保<code>handleClient</code>函数经常得以调用。我在这里反复强调这一点是因为这一点非常关键，请务必注意！</p><p>这一节的程序内容到这里就讲解完毕了，下一节教程我将为您讲解如何建立可以控制NodeMCU开发板的网页。</p><h1 id="通过网络服务实现NodeMCU开发板基本控制"><a href="#通过网络服务实现NodeMCU开发板基本控制" class="headerlink" title="通过网络服务实现NodeMCU开发板基本控制"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/pin-control/">通过网络服务实现NodeMCU开发板基本控制</a></h1><p>利用NodeMCU建立网络服务</p><p>用户通过浏览器可以访问NodeMCU所建立的网页</p><p>通过该网页，用户可实现对NodeMCU的控制。</p><p>以下是示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_2_Turning_on_and_off_an_LED</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span><br><span class="line"><span class="comment">                           访问8266所建立的基本网页并通过该页面点亮/熄灭NodeMCU的内置LED</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是 &#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT); <span class="comment">//设置内置LED引脚为输出模式以便控制LED</span></span><br><span class="line">  </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU再启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 通过串口监视器输出连接的WiFi名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// 通过串口监视器输出ESP8266-NodeMCU的IP</span></span><br><span class="line"> </span><br><span class="line">  esp8266_server.begin();                           <span class="comment">// 启动网站服务</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, HTTP_GET, handleRoot);     <span class="comment">// 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/LED&quot;</span>, HTTP_POST, handleLED);  <span class="comment">// 设置处理LED控制请求的函数&#x27;handleLED&#x27;</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        <span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();                     <span class="comment">// 检查http服务器访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line"><span class="comment">  该函数的作用是每当有客户端访问NodeMCU服务器根目录时，</span></span><br><span class="line"><span class="comment">  NodeMCU都会向访问设备发送 HTTP 状态 200 (Ok) 这是send函数的第一个参数。</span></span><br><span class="line"><span class="comment">  同时NodeMCU还会向浏览器发送HTML代码，以下示例中send函数中第三个参数，</span></span><br><span class="line"><span class="comment">  也就是双引号中的内容就是NodeMCU发送的HTML代码。该代码可在网页中产生LED控制按钮。 </span></span><br><span class="line"><span class="comment">  当用户按下按钮时，浏览器将会向NodeMCU的/LED页面发送HTTP请求，请求方式为POST。</span></span><br><span class="line"><span class="comment">  NodeMCU接收到此请求后将会执行handleLED函数内容*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;       </span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&lt;form action=\&quot;/LED\&quot; method=\&quot;POST\&quot;&gt;&lt;input type=\&quot;submit\&quot; value=\&quot;Toggle LED\&quot;&gt;&lt;/form&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理LED控制请求的函数&#x27;handleLED&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleLED</span><span class="params">()</span> &#123;                          </span><br><span class="line">  digitalWrite(LED_BUILTIN,!digitalRead(LED_BUILTIN));<span class="comment">// 改变LED的点亮或者熄灭状态</span></span><br><span class="line">  esp8266_server.sendHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/&quot;</span>);          <span class="comment">// 跳转回页面根目录</span></span><br><span class="line">  esp8266_server.send(<span class="number">303</span>);                           <span class="comment">// 发送Http相应代码303 跳转  </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>); <span class="comment">// 发送 HTTP 状态 404 (未找到页面) 并向浏览器发送文字 &quot;404: Not found&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过网络服务将开发板引脚状态显示在网页中"><a href="#通过网络服务将开发板引脚状态显示在网页中" class="headerlink" title="通过网络服务将开发板引脚状态显示在网页中"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/pin-state/">通过网络服务将开发板引脚状态显示在网页中</a></h1><p>为了便于学习，我们将使用D3引脚作为演示, 因为它已经与开发板上的FLASH按键开关连接好了。<em>我们可以通过NodeMCU开发板上的FLASH按键控制D3引脚的电平。</em></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/backgrounds/esp8266-nodemcu-Flash-Button-1.jpg" alt="NodeMCU开发板FLASH按键开关"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_3_Pin_State_Display</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。该页面将会自动刷新并且显示NodeMCU</span></span><br><span class="line"><span class="comment">                           的D3引脚状态。NodeMCU开发板上的FLASH按键可以控制D3引脚的电平。</span></span><br><span class="line"><span class="comment">                           没有按下该按键时D3引脚将会保持高电平状态。当按下该按键后，</span></span><br><span class="line"><span class="comment">                           D3引脚会变为低电平。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buttonPin D3            <span class="comment">// 按钮引脚D3</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> pinState;  <span class="comment">// 存储引脚状态用变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); <span class="comment">// 将按键引脚设置为输入上拉模式</span></span><br><span class="line"> </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU再启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line">  esp8266_server.begin();                   <span class="comment">// 启动网站服务                </span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);       <span class="comment">// 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);<span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;        </span></span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">  pinState = digitalRead(buttonPin); <span class="comment">// 获取引脚状态</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节“通过网络服务将开发板引脚状态显示在网页中”的说明讲解。*/</span>                                                                       </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   </span><br><span class="line">  String displayPinState;                   <span class="comment">// 存储按键状态的字符串变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pinState == HIGH)&#123;                     <span class="comment">// 当按键引脚D3为高电平</span></span><br><span class="line">    displayPinState = <span class="string">&quot;Button State: HIGH&quot;</span>; <span class="comment">// 字符串赋值高电平信息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                  <span class="comment">// 当按键引脚D3为低电平</span></span><br><span class="line">    displayPinState = <span class="string">&quot;Button State: LOW&quot;</span>;  <span class="comment">// 字符串赋值低电平信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, displayPinState); </span><br><span class="line">                                            <span class="comment">// 向浏览器发送按键状态信息  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上程序的loop函数中，<code>pinState = digitalRead(buttonPin);</code> 语句将不断检查NodeMCU开发板D3引脚状态，也就是检查该引脚所连接的按键是否被按下。该状态将会存储与布尔变量pinState中。</p><p>变量pinState将会用于本程序的重点1，也就是handleRoot() 函数里。在handleRoot函数里，我们利用逻辑判断语句来对displayPinState 进行赋值。<strong>如果按键没有被按下</strong>，pinState为HIGH，这时候程序将会执行<code>displayPinState = &quot;Button State: HIGH&quot;;</code>也就是为displayPinState的赋值为“Button State: HIGH”。这句话的意思是“按键引脚状态为高电平”。反之，当我们按下按键后，程序将会执行<code>displayPinState = &quot;Button State: LOW&quot;;</code>也就是为displayPinState的赋值为“Button State: LOW”。</p><p>在handleRoot函数的结尾处，<br><code>esp8266_server.send(200, &quot;text/plain&quot;, displayPinState);</code><br>这条语句将会把displayPinState所存储的信息发送给浏览器。于是我们在没有按下按键时，将会得到以下页面信息。</p><h1 id="暂时没放图"><a href="#暂时没放图" class="headerlink" title="暂时没放图"></a><strong>暂时没放图</strong></h1><p>以上示例中，我们需要刷新网页页面才能将按键的最新状态显示在网页中。为了实现页面的自动刷新，请您参考以下示例程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_4_Pin_State_Display_Auto_Refresh</span></span><br><span class="line"><span class="comment">团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。该网页将显示引脚D3状态。同时状态会</span></span><br><span class="line"><span class="comment">                           每隔5秒钟更新一次。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buttonPin D3            <span class="comment">// 按钮引脚D3</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> pinState;                      <span class="comment">// 存储引脚状态用变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);          <span class="comment">// 启动串口通讯</span></span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); <span class="comment">// 将按键引脚设置为输入上拉模式</span></span><br><span class="line"> </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU在启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">                                                               <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多</span></span><br><span class="line">                                                               <span class="comment">// 的WiFi信息在此处。</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line">  esp8266_server.begin();                  </span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);      </span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">  pinState = digitalRead(buttonPin); <span class="comment">// 获取引脚状态</span></span><br><span class="line">&#125;                                                                   </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节“通过网络服务将开发板引脚状态显示在网页中”的说明讲解。*/</span>    </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   <span class="comment">//处理网站目录“/”的访问请求 </span></span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, sendHTML(pinState));  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">建立用于发送给客户端浏览器的HTML代码。此代码将会每隔5秒刷新页面。</span></span><br><span class="line"><span class="comment">通过页面刷新，引脚的最新状态也会显示于页面中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">sendHTML</span><span class="params">(<span class="type">bool</span> buttonState)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  String htmlCode = <span class="string">&quot;&lt;!DOCTYPE html&gt; &lt;html&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;head&gt;&lt;meta http-equiv=&#x27;refresh&#x27; content=&#x27;5&#x27;/&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;title&gt;ESP8266 Butoon State&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;style&gt;html &#123; font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;&#125;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;body&#123;margin-top: 50px;&#125; h1 &#123;color: #444444;margin: 50px auto 30px;&#125; h3 &#123;color: #444444;margin-bottom: 50px;&#125;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/style&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;h1&gt;ESP8266 BUTTON STATE&lt;/h1&gt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(buttonState)</span><br><span class="line">    &#123;htmlCode +=<span class="string">&quot;&lt;p&gt;Button Status: HIGH&lt;/p&gt;\n&quot;</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;htmlCode +=<span class="string">&quot;&lt;p&gt;Button Status: LOW&lt;/p&gt;\n&quot;</span>;&#125;</span><br><span class="line">    </span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> htmlCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上示例程序中的<code>handleRoot</code>函数中，<code>esp8266_server.send(200, &quot;text/html&quot;, sendHTML(pinState))</code>语句的的3个参数 <code>sendHTML(pinState)</code>调用了<code>sendHTML</code>函数。该函数的作用是建立一个可以定时刷新的HTML网页代码。通过定时刷新网页，开发板的引脚状态将会不断地在页面中进行更新。</p><p>此HTML网页代码是由<code>sendHTML</code>函数产生的。该函数建立了一个字符串变量，该字符串变量所存储的信息正是网页HTML代码。值得注意的是，该HTML代码会不断地检查变量pinState状态，并且根据pinState的状态改变HTML代码的信息，从而实现在网页上显示引脚状态。</p><p>此HTML代码中真正实现定时刷新网页功能的语句是代码中的第79行语句。这条语句是告诉网页需要定时刷新，刷新频率5秒钟，即每5秒钟刷新一次页面。您可以通过改变此行语句中的数值5来调整页面刷新频率。</p><p>每一次页面刷新，浏览器都会向NodeMCU发送HTTP请求。NodeMCU在收到浏览器请求后，将会把最新的HTML代码信息返回给浏览器。浏览器收到最新的HTML代码后将会在页面中显示引脚的状态。<br>以下是没有按下按键时的页面显示信息。</p><h1 id="暂时没放图-1"><a href="#暂时没放图-1" class="headerlink" title="暂时没放图"></a><strong>暂时没放图</strong></h1>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学物联网之ESP8266NodeMCU（三）</title>
      <link href="/post/336e95a3.html"/>
      <url>/post/336e95a3.html</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装-ESP8266-NodeMCU开发板驱动"><a href="#安装-ESP8266-NodeMCU开发板驱动" class="headerlink" title="安装 ESP8266-NodeMCU开发板驱动"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/install-esp8266-nodemcu-driver/">安装 ESP8266-NodeMCU开发板驱动</a></h2><p>目前大部分电脑驱动都已自动安装完成，可先进行下一步，若遇连接问题，可自行百度安装驱动。</p><h2 id="为ESP8266-NodeMCU搭建Arduino-IDE开发环境"><a href="#为ESP8266-NodeMCU搭建Arduino-IDE开发环境" class="headerlink" title="为ESP8266-NodeMCU搭建Arduino IDE开发环境"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/nodemcu-arduino-ide/">为ESP8266-NodeMCU搭建Arduino IDE开发环境</a></h2><p><strong>下载 Arduino IDE </strong></p><p>打开Arduino IDE，<strong>“文件” -&gt; “首选项”, 在 “附加开发板管理网址”</strong> 中输入以下网址：</p><p>esp8266开发板管理器地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://arduino.esp8266.com/stable/package_esp8266com_index.json</span><br></pre></td></tr></table></figure><p>（选填，方便日后开发esp32）esp32开发版管理器地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://dl.espressif.com/dl/package_esp32_index.json</span><br></pre></td></tr></table></figure><p>紧接着点击<strong>”工具“ -&gt; ”开发板“ -&gt; “开发板管理器”</strong>, <strong>在搜索栏中输入“esp8266”</strong>，看到搜索结果显示<strong>“esp8266 by ESP8266 Community”, 选择最新版本安装即可（我这里是3.0.2）</strong></p><p>安装成功后，在<strong>”工具“ -&gt; ”开发板“ 中选择”NodeMCU 1.0 (ESP-12E Moudle)“ 即可</strong></p><p>紧接着设置<strong>NodeMCU开发板的端口，在 “工具” -&gt; “端口”</strong></p><font color=purple>（这里比较简单，如果有其它问题自行百度解决）</font><h1 id="NodeMCU开发板的接入点模式"><a href="#NodeMCU开发板的接入点模式" class="headerlink" title="NodeMCU开发板的接入点模式"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/ap/">NodeMCU开发板的接入点模式</a></h1><h2 id="接入点模式（Access-Point-也称-AP）"><a href="#接入点模式（Access-Point-也称-AP）" class="headerlink" title="接入点模式（Access Point, 也称 AP）"></a>接入点模式（Access Point, 也称 AP）</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/NodeMCU-Access-Point.png" alt="ESP8266-NodeMCU接入点(Access Point)工作模式"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU接入点模式 </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">此程序用于演示如何将NodeMCU以接入点模式工作。通过此程序，您可以使用</span></span><br><span class="line"><span class="comment">电脑或者手机连接NodeMCU所建立WiFi网络。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ssid = <span class="string">&quot;设定自己的wifi名&quot;</span>; <span class="comment">// 这里定义将要 建立 的WiFi名称</span></span><br><span class="line">                                   <span class="comment">// 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *password = <span class="string">&quot;设定自己的wifi密码&quot;</span>;  <span class="comment">// 这里定义将要建立的WiFi密码</span></span><br><span class="line">                                    <span class="comment">// 您可以将自己想要使用的WiFi密码放入引号内</span></span><br><span class="line">                                    <span class="comment">// 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);              <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  WiFi.softAP(ssid, password);     <span class="comment">// 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span></span><br><span class="line">                                   <span class="comment">// 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span></span><br><span class="line">                                   <span class="comment">// 这两个参数具体内容在setup函数之前的位置进行定义。</span></span><br><span class="line"> </span><br><span class="line">  Serial.print(<span class="string">&quot;Access Point: &quot;</span>);    <span class="comment">// 通过串口监视器输出信息</span></span><br><span class="line">  Serial.println(ssid);              <span class="comment">// 告知用户NodeMCU所建立的WiFi名</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address: &quot;</span>);      <span class="comment">// 以及NodeMCU的IP地址</span></span><br><span class="line">  Serial.println(WiFi.softAPIP());   <span class="comment">// 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将程序上传至开发板以后, NodeMCU在每次启动以后，都会自动启动接入点模式。接入点WiFi的详细信息会通过串口监视器输出给用户查看。</p><p>若想要验证一下电脑是否可以与NodeMCU进行网络通讯，那么同样可以在Windows操作系统的“命令提示符”中输入：<code>ping IP address</code></p><p>（注意：ping的IP地址是NodeMCU默认的接入点IP地址，这一信息在上面的 串口监视器截屏中可以看到。）</p><h1 id="NodeMCU开发板的无线终端模式"><a href="#NodeMCU开发板的无线终端模式" class="headerlink" title="NodeMCU开发板的无线终端模式"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/station/">NodeMCU开发板的无线终端模式</a></h1><h2 id="无线终端模式-Station"><a href="#无线终端模式-Station" class="headerlink" title="无线终端模式(Station)"></a>无线终端模式(Station)</h2><h3 id="1-连接WiFI"><a href="#1-连接WiFI" class="headerlink" title="1. 连接WiFI"></a><strong>1. 连接WiFI</strong></h3><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/NodeMCU-Station.png" alt="ESP8266-NodeMCU无线终端(Wireless Station)工作模式">)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU无线终端模式连接WiFi</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">本示例程序用于演示如何使用NodeMCU无线终端模式连接WiFi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid     = <span class="string">&quot;自家路由器的wifi名&quot;</span>;      <span class="comment">// 连接WiFi名</span></span><br><span class="line">                                            <span class="comment">// 请将您需要连接的WiFi名填入引号中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;自家路由器的wifi密码&quot;</span>;          <span class="comment">// 连接WiFi密码</span></span><br><span class="line">                                            <span class="comment">// 请将您需要连接的WiFi密码填入引号中</span></span><br><span class="line">                                            </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);         <span class="comment">// 启动串口通讯</span></span><br><span class="line">  </span><br><span class="line">  WiFi.begin(ssid, password);                  <span class="comment">// 启动网络连接</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to &quot;</span>);              <span class="comment">// 串口监视器输出网络连接信息</span></span><br><span class="line">  Serial.print(ssid); Serial.println(<span class="string">&quot; ...&quot;</span>);  <span class="comment">// 告知用户NodeMCU正在尝试WiFi连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                   <span class="comment">// 这一段程序语句用于检查WiFi是否连接成功</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;      <span class="comment">// WiFi.status()函数的返回值是由NodeMCU的WiFi连接状态所决定的。 </span></span><br><span class="line">    delay(<span class="number">1000</span>);                               <span class="comment">// 如果WiFi连接成功则返回值为WL_CONNECTED                       </span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);      <span class="comment">// 此处通过While循环让NodeMCU每隔一秒钟检查一次WiFi.status()函数返回值</span></span><br><span class="line">  &#125;                                            <span class="comment">// 同时NodeMCU将通过串口监视器输出连接时长读秒。</span></span><br><span class="line">                                               <span class="comment">// 这个读秒是通过变量i每隔一秒自加1来实现的。</span></span><br><span class="line">                                               </span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);                          <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connection established!&quot;</span>);   <span class="comment">// NodeMCU将通过串口监视器输出&quot;连接成功&quot;信息。</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:    &quot;</span>);             <span class="comment">// 同时还将输出NodeMCU的IP地址。这一功能是通过调用</span></span><br><span class="line">  Serial.println(WiFi.localIP());              <span class="comment">// WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-自动连接最强信号WiFi网络"><a href="#2-自动连接最强信号WiFi网络" class="headerlink" title="2. 自动连接最强信号WiFi网络"></a><strong>2. 自动连接最强信号WiFi网络</strong></h3><p>有时会在家，学校，公司等来回跑，这样的话没换一个地方就得重新更改代码，太麻烦，于是我们可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU无线终端模式连接WiFi-2</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序将会控制NodeMCU在当前的网络环境里搜索预先存储好的WiFi。</span></span><br><span class="line"><span class="comment">一旦找到预存的WiFi名称，NodeMCU将会使用预存的密码信息尝试连接该WiFi。</span></span><br><span class="line"><span class="comment">如果同时找到多个预存WiFi，NodeMCU将会尝试连接信号最强的WiFi。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>          <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">// 本程序使用ESP8266WiFiMulti库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);            <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过addAp函数存储  WiFi名称       WiFi密码</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker&quot;</span>, <span class="string">&quot;12345678&quot;</span>);  <span class="comment">// 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker2&quot;</span>, <span class="string">&quot;87654321&quot;</span>); <span class="comment">// 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker3&quot;</span>, <span class="string">&quot;13572468&quot;</span>); <span class="comment">// 这3个网络的密码分别是123456789，87654321，13572468。</span></span><br><span class="line">                                                <span class="comment">// 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span><br><span class="line">                                                <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span><br><span class="line">                                                </span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);         <span class="comment">// 通过串口监视器输出信息告知用户NodeMCU正在尝试连接WiFi</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(<span class="string">&#x27;.&#x27;</span>);                       <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                           <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                              <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学物联网之ESP8266NodeMCU（二）</title>
      <link href="/post/4e66da29.html"/>
      <url>/post/4e66da29.html</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP协议簇（TCP-IP-Stack）"><a href="#TCP-IP协议簇（TCP-IP-Stack）" class="headerlink" title="TCP/IP协议簇（TCP/IP Stack）"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/tcp-ip-stack/">TCP/IP协议簇（TCP/IP Stack）</a></h1><p>在网络系统中，为了保证通信设备之间能正确地进行通信，必须使用一种双方都能够理解的语言，这种语言被称为“协议”。</p><p>TCP/IP协议簇是Internet的基础，也是当今最流行的组网形式。TCP/IP是一组协议的代名词。</p><p>TCP/IP协议被划分为4层，分别是：</p><div class="table-container"><table><thead><tr><th>分层名称</th><th>包含协议</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP, FTP, mDNS, WebSocket, OSC …</td></tr><tr><td>传输层</td><td>TCP, UDP</td></tr><tr><td>网络层</td><td>IP</td></tr><tr><td>链路层（也称网络接口层）</td><td>Ethernet, Wi-Fi …</td></tr></tbody></table></div><h1 id="链路层（Link-Layer）"><a href="#链路层（Link-Layer）" class="headerlink" title="链路层（Link Layer）"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/link-layer/">链路层（Link Layer）</a></h1><p>链路层的主要作用是实现设备之间的物理链接。举例来说，我们日常使用的WiFi就是链路层的一种。</p><h2 id="ESP8266利用WiFi联网时有三种工作模式。"><a href="#ESP8266利用WiFi联网时有三种工作模式。" class="headerlink" title="ESP8266利用WiFi联网时有三种工作模式。"></a>ESP8266利用WiFi联网时有三种工作模式。</h2><p><strong>模式1 – 无线终端模式（Wireless Station）</strong></p><p>如下图所示，ESP8266可通过WiFi连接无线路由器。这与用您的手机通过WiFi连接无线路由器的模式相同。</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/NodeMCU-Station.png" alt="ESP8266-NodeMCU无线终端(Wireless Station)工作模式"></p><p><strong>模式2 – 接入点模式（Access Point, 也称 AP）</strong></p><p>ESP8266也可以建立WiFi网络供其它设备连接。当ESP8266以此模式运行时，我们可以使用手机搜索ESP8266所发出的WiFi网络并进行连接。</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/NodeMCU-Access-Point.png" alt="ESP8266-NodeMCU接入点(Access Point)工作模式"></p><p><strong>模式3 – 混合模式（Wireless Station + AP）</strong></p><p>混合模式即以上两种模式的混合。</p><h1 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/internet-layer/">网络层（Internet Layer）</a></h1><h5 id="网络层与IP协议"><a href="#网络层与IP协议" class="headerlink" title="网络层与IP协议"></a>网络层与IP协议</h5><p>尽管设备可以通过链路层联网，但是光有链路层还无法实现设备之间的数据通讯。因为网络设备没有明确的标识。网络设备无从知晓要向谁传输数据，也无法确定从何处获取数据。</p><p>网络层主要作用是通过IP协议为联网设备提供IP地址。</p><p>有了IP地址还不够，因为要确保网络中所有设备IP地址不重复，还需要DHCP (Dynamic Host Configuration Protocol) 服务器来实现这一功能。</p><p>当网络中所有设备都有了独立的IP地址后，设备之间就可以收发数据了。</p><h1 id="传输层（Transportation-Layer）"><a href="#传输层（Transportation-Layer）" class="headerlink" title="传输层（Transportation Layer）"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/transportation-layer/">传输层（Transportation Layer）</a></h1><p>网络设备通讯时，数据丢失和数据受损的情况经常出现。传输层的<br>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）协议可以用来解决这一问题。通常我们会选择这两种协议中的一种来保证数据传输的准确性。具体选择哪一种协议要看我们使用的是何种网络应用。因为不同的网络应用对于数据的传输要求是不同的。</p><p>TCP协议可以更好的保证数据传输的准确性，但是传输速度比UDP协议而言要慢一些。TCP协议的特点是可以保证所有数据都能被接收端接收，数据的传输顺序也不会被打乱，而且如有数据损坏则重发受损数据。基于以上功能特点，TCP通常用于电子邮件及文件上传等。</p><p>UDP协议并不能保证所有数据都被接收端所接受。一旦出现数据受损的情况，UDP协议将会抛弃受损的数据。这些数据一旦被抛弃将会永久性的消失，发送端不会因为数据受损而重新发送。因此UDP协议远不如TCP协议可靠。</p><p>但是既然是这样，为何还有人会选择UDP协议呢？这是因为UDP比TCP速度快。因此UDP协议通常用于网络游戏以及语音聊天或视频聊天应用。</p><h1 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/application-layer/">应用层（Application Layer）</a></h1><p>传输层可以实现设备间的数据传输。但发送端和接收端还需要一种协议来理解这些传输信息的含义。这就引出了即将给您介绍的应用层。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h4><p>应用层中有很多种协议，最常见是HTTP协议。它常被用来传输网页数据。我们这篇教程也将着重介绍HTTP协议。</p><p>HTTP协议由<strong>请求</strong>和<strong>响应</strong>构成。也就是说，HTTP的工作模式很像是一问一答。</p><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a><strong>HTTP请求</strong></h4><p>举例来说，当您在浏览器输入www.taichi-maker.com这一网址并按下回车，这时候浏览器会把这一操作转换成一个HTTP请求。</p><p>这个HTTP请求主要分为两大部分。一部分是请求头（Request Header）一部分是请求体（Request Body）。对于我们学习物联网知识来说，请求头是我们重点要关注的内容。而请求体的知识已经超越这篇教程的范围，抱歉我就不在这里详述了。</p><p>请看以下是简化后的请求头内容：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.taichi-maker.com</span><br></pre></td></tr></table></figure><p>在以上的HTTP请求中:</p><p>“GET” 是一个<strong>读取</strong>请求。也就是请求网站服务器把网页数据发送过来。</p><p>“/” 的作用就是要告诉网站服务器，我这个读取请求的内容是网站根目录下的内容。换句话说，就是请求服务器把网站首页的网页数据发过来。</p><p>“HTTP/1.1” 是指请求所采用的HTTP协议版本是1.1。</p><p>“Host: www.taichi-maker.com”表示请求的域名是 www.taichi-maker.com 也就是太极创客网站的域名。</p><p>以上是HTTP协议的 GET 请求中最关键的内容。在 HTTP 协议中，GET只是诸多请求方法中的一种。以下是HTTP协议中的其它请求方法：</p><p><strong>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</strong><br><strong>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</strong></p><p>关于请求方法，我们这里主要介绍的只有GET。其它的请求方法已经超越了我们这个教程的范围，就不在这里继续深入讲下去了。感兴趣的话，您可以通过互联网找到这方面的教程资源。</p><h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a><strong>HTTP响应</strong></h4><p>接下来我们再看一看浏览器发送以上HTTP请求后，接收到的服务器HTTP响应。HTTP响应内容也是分为两个部分，一部分是响应头（Response Header）一部分是响应体（Response Body）。其中响应体部分是可选项，也就是说有些HTTP响应只有响应头，而响应体是空的。</p><p>我们先来给大家介绍响应头部分。</p><p>由于响应头信息量比较大，我们还是选出主要内容给大家讲解。如下所示：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>“HTTP/1.1”这个信息我们刚刚在HTTP请求部分中介绍过。它的含义就是此HTTP响应所采用的协议版本是1.1。</p><p>“200”这个代码可能有些朋友会感觉陌生。但是如果我说起“404”这个数字可能大家会感到更熟悉吧？无论是200也好还是404也好，这些都是HTTP响应状态码。它的作用是以代码的形式表达服务器在接到请求后的状态。“200”代表服务器成功找到了请求的网页资源（这一点大家在后面的OK中也已经体现出来了）。 “404”代表服务器无法找到请求的网页资源。：</p><p>以下是常见的服务器状态码：</p><p>100~199：成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。</p><p>200~299：成功接收请求并已完成整个处理过程。常用200</p><p>300~399：完成请求，客户需进一步细化请求。</p><p>400~499：客户端的请求有错误，常用404和403(403的含义是权限不够，服务器拒绝访问。)</p><p>500~599：服务器端出现错误，常用500</p><p><strong>“Content-Type”</strong> 指示响应体的内容是什么类型。这里的响应体内容类型是<strong>“text/htm”</strong>，即网页HTML代码。通过这一行响应头信息，我们的浏览器将会知道，在这一个响应中的响应体部分都是HTML网页代码。于是浏览器将会做好准备，将网页代码翻译成我们人类容易读懂的格式并且呈现在浏览器中。<strong>charset=UTF-8</strong>是字符集。</p><p>我们再举一个例子，假设某一个响应头中“Content-Type” 类型是”image/jpeg”。这就意味着该响应体中的信息是一个jpeg格式的图片，那么浏览器也就会按照jpeg的解码方式将图片呈现在我们的面前。</p><p>在以上示例中，我们使用互联网浏览器来讲解HTTP的请求和响应。当我们使用NodeMCU来开发物联网项目时，发出HTTP请求的就不再是浏览器而是NodeMCU开发板了。而读取这些响应请求的也将是NodeMCU开发板。那么，究竟如何让NodeMCU发出HTTP请求，而NodeMCU又是如何解读HTTP响应呢？这些都依赖于我们为NodeMCU开发的控制程序。这些内容会在后续的教程里给大家详细介绍。</p><h4 id="DNS（Domain-Name-System-域名系统）"><a href="#DNS（Domain-Name-System-域名系统）" class="headerlink" title="DNS（Domain Name System/域名系统）"></a><strong>DNS（Domain Name System/域名系统）</strong></h4><p>在之前的教程中，我曾经给大家讲过网络中的所有设备都具有独立的IP地址。这一点对于网站服务器来说也不例外。当我们使用浏览器访问某一个网站时，实际上我们是通过浏览器向网站服务器发送HTTP请求。然而网站服务器的IP地址很难记忆，比如太极创客网站的域名由两个单词组成，taichi是太极，maker是创客。这很好记，但是要想记住太极创客服务器的IP就没那么容易了。因为那是4个毫无规律的数字。</p><p>为了解决IP地址不好记这一问题，DNS被派上了用场。</p><p>我们可以把DNS看作是一个巨型电话本。电话本中的联系人一栏就是网站的域名，而电话本中的电话号码一栏则是这些网站的IP地址。有了DNS我们就可以使用简单易记的域名来访问网站了。</p><p>还是用太极创客网站来举例吧，每当我们在浏览器中输入域名<a href="www.taichi-maker.com">www.taichi-maker.com</a>并按下回车后，这时浏览器首先会向DNS服务器发送请求，请求的内容大致如下：“亲爱的DNS服务器，我那个明明可以靠脸吃饭却偏偏要学物联网的主人想访问一个域名是<a href="www.taichi-maker.com">www.taichi-maker.com</a>的网站。麻烦您把这个域名的网站服务器IP地址告诉我好吗？” DNS服务器在接收到这一请求后，会做出以下应答：“亲爱的浏览器，您要的网站服务器ip地址是 12 . 34 . 56 . 78。” 浏览器在接收到这一IP地址后，就开始向这个IP地址所对应的网站服务器正式发出HTTP GET请求了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学物联网之ESP8266NodeMCU（一）</title>
      <link href="/post/a01e6d85.html"/>
      <url>/post/a01e6d85.html</url>
      
        <content type="html"><![CDATA[<h1 id="初识NodeMCU开发板"><a href="#初识NodeMCU开发板" class="headerlink" title="初识NodeMCU开发板"></a>初识NodeMCU开发板</h1><p>市面上销售的配有ESP8266芯片的开发板有很多种。比较流行的有SparkFun ESP8266 Thing、Adafruit Feather HUZZAH with ESP8266、NodeMCU等。这里选择跟太极创客团队学NodeMCU。</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/imagesnodemcu_pinLocation.jpg" alt="ESP8266-NodeMCU开发板"></p><h2 id="数字输入输出引脚（GPIO）"><a href="#数字输入输出引脚（GPIO）" class="headerlink" title="数字输入输出引脚（GPIO）"></a>数字输入输出引脚（GPIO）</h2><p>如下图所示，ESP8266芯片四周分布很多引脚。这些引脚大部分可用作输入输出使用。这些用作输入输出的引脚统称为GPIO。</p><p>当引脚以数字输出模式工作时，低电平是<font color=red size=4>0V</font>&gt; (灌电流)，高电平是<font color=red size=4>3.3V</font> (拉电流)。</p><font face="黑体" color=green size=4>请注意:ESP8266芯片与Arduino Uno/Mega/Nano等开发板的引脚电平电压有所区别。Arduino开发板的高电平是+5V，低电平是0V。</font><h3 id="GPIO编号与NodeMCU开发板引脚名的区别"><a href="#GPIO编号与NodeMCU开发板引脚名的区别" class="headerlink" title="GPIO编号与NodeMCU开发板引脚名的区别"></a>GPIO编号与NodeMCU开发板引脚名的区别</h3><p>请留意：在很多介绍ESP8266以及NodeMCU的资料里会出现两种引脚命名方法。一种是GPIO编号，一种是NodeMCU引脚名。请注意这两者是不同的，请千万不要混淆。</p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/imagesnodemcu-pin-number.jpg" alt="nodemcu-pin-number"></p><p>简而言之，只要您看到GPIO这几个字母，就说明是芯片引脚，而没有GPIO这几个字母，那肯定是指开发板引脚。</p><h3 id="ESP8266-GPIO编号与NodeMCU开发板引脚名的对应关系"><a href="#ESP8266-GPIO编号与NodeMCU开发板引脚名的对应关系" class="headerlink" title="ESP8266 GPIO编号与NodeMCU开发板引脚名的对应关系"></a>ESP8266 GPIO编号与NodeMCU开发板引脚名的对应关系</h3><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/imagesnodemcu-pin-GPIO_001.png" alt="nodemcu-pin-GPIO_001"></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/esp8266_devkit_horizontal-002.png" alt="esp8266_devkit_horizontal-002"></p><p>在以上图片中深蓝底白色字的标识就是GPIO引脚编号。如<img src="http://www.taichi-maker.com/wp-content/uploads/2019/02/GPIO4.png" alt="NodeMCU-GPIO4"> </p><p>而开发板上所印刷的D2,D3等等就是NodeMCU开发板引脚名称。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digitalWrite(<span class="number">4</span>, High);</span><br></pre></td></tr></table></figure><p>以上语句通过digitalWrite函数将引脚4设置为高电平。这里的数字4就是指GPIO4。也可以说这个语句是将NodeMCU开发板的D2引脚设置为高电平,即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digitalWrite(D2, High);    <span class="comment">//因为D2对应的是GPIO4。</span></span><br></pre></td></tr></table></figure><h2 id="可用引脚"><a href="#可用引脚" class="headerlink" title="可用引脚"></a>可用引脚</h2><p>ESP8266芯片有17个GPIO引脚（GPIO0～GPIO16）。这些引脚中的GPIO6～GPIO 11被用于连接开发板的闪存（Flash Memory）。如果在实验电路中使用GPIO6～GPIO11，NodeMCU开发板将无法正常工作。因此建议您<font color=red size=4>不要使用GPIO6～GPIO 11。</font></p><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/imagesesp8266_devkit_horizontal-flash-pins.png" alt="*ESP8266的GPIO6-GPIO11用于连接闪存，因此不建议使用这些引脚。*"></p><h3 id="电压电流限制"><a href="#电压电流限制" class="headerlink" title="电压电流限制"></a>电压电流限制</h3><p>NodeMCU开发板引脚的<font color=orange>输入输出电压限制是3.3 V</font>。如果向引脚施加3.6V以上的电压就有可能对芯片电路造成损坏。同时请注意，这些引脚的<font color=orange>最大输出电流是12mA。</font></p><p>由于NodeMCU开发板的引脚允许电压和电流都是低于Arduino开发板的引脚，将NodeMCU与Arduino引脚相互连接时一定要特别注意这两个开发板的引脚电压和电流的区别。操作不当极有可能可能会损坏NodeMCU开发板。</p><h3 id="特殊引脚情况说明"><a href="#特殊引脚情况说明" class="headerlink" title="特殊引脚情况说明"></a>特殊引脚情况说明</h3><p><strong>GPIO2引脚</strong> 在NodeMCU开发板启动时是不能连接低电平的。</p><p><strong>GPIO15引脚</strong>在开发板运行中一直保持低电平状态。因此请不要使用GPIO15引脚来读取开关状态或进行I²C通讯。</p><p><strong>GPIO0引脚</strong>在开发板运行中需要一直保持高电平状态。否则ESP8266将进入程序上传工作模式也就无法正常工作了。您无需对GPIO0引脚进行额外操作，因为NodeMCU的内置电路可以确保GPIO0引脚在工作时连接高电平而在上传程序时连接低电平。</p><h3 id="上拉电阻-下拉电阻"><a href="#上拉电阻-下拉电阻" class="headerlink" title="上拉电阻/下拉电阻"></a>上拉电阻/下拉电阻</h3><p><strong>GPIO 0-15引脚</strong>都配有内置上拉电阻。这一点与Arduino十分类似。<strong>GPIO16 引脚</strong>配有内置下拉电阻。</p><h3 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h3><p>ESP8266 只有一个模拟输入引脚（该引脚通过模拟-数字转换将引脚上的模拟电压数值转化为数字量）。<font color=red>此引脚可读取的模拟电压值为 0 – 1.0V。</font>请注意：ESP8266 芯片模拟输入引脚连接在1.0V以上电压可能损坏ESP8266芯片。</p><p>以上所描述的是针对ESP8266芯片的引脚。而对于NodeMCU开发板引脚，情况就不同了。</p><p>NodeMCU开发板配有降压电路。您可以用NodeMCU开发板的模拟输入引脚读取0-3.3V的模拟电压信号。</p><h3 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h3><h4 id="串行端口"><a href="#串行端口" class="headerlink" title="串行端口"></a><strong>串行端口</strong></h4><p>ESP8266有2个硬件串行端口（UART）。</p><p>串行端口0（UART0）使用GPIO1和GPIO3引脚。其中GPIO1引脚是TX0，GPIO3是RX0。</p><p>串行端口1（UART1）使用GPIO2和GPIO8引脚。其中GPIO2引脚是TX1，GPIO8是RX1。请注意，由于GPIO8被用于连接闪存芯片，串行端口1只能使用GPIO2来向外发送串行数据。</p><h4 id="I²C"><a href="#I²C" class="headerlink" title="I²C"></a><strong>I²C</strong></h4><p>ESP8266只有软件模拟的I²C端口，没有硬件I²C端口。也就是说我们可以使用任意的两个GPIO引脚通过软件模拟来实现I²C通讯。ESP8266的数据表（datasheet）中，GPIO2标注为SDA，GPIO14标注为SCL。</p><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a><strong>SPI</strong></h4><p>ESP8266的SPI端口情况如下：</p><p>GPIO14 — CLK<br>GPIO12 — MISO<br>GPIO13 — MOSI<br>GPIO 15 — CS(SS)</p><h3 id="ESP8266引脚功能一览"><a href="#ESP8266引脚功能一览" class="headerlink" title="ESP8266引脚功能一览"></a><strong>ESP8266引脚功能一览</strong></h3><div class="table-container"><table><thead><tr><th style="text-align:left">GPIO</th><th style="text-align:left">功能</th><th style="text-align:left">状态</th><th style="text-align:left">限制</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">引导模式选择</td><td style="text-align:left">3.3V</td><td style="text-align:left">无Hi-Z</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">TX0</td><td style="text-align:left">–</td><td style="text-align:left">串口通讯过程中不能使用</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">引导模式选择 TX1</td><td style="text-align:left">3.3V</td><td style="text-align:left">启动时不能接地 启动时发送调试信息</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">RX0</td><td style="text-align:left">–</td><td style="text-align:left">串口通讯过程中不能使用</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">SDA (I²C)</td><td style="text-align:left">–</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">SCL (I²C)</td><td style="text-align:left">–</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">6 – 11</td><td style="text-align:left">连接闪存</td><td style="text-align:left">x</td><td style="text-align:left">不可用</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">MISO (SPI)</td><td style="text-align:left">–</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">MOSI (SPI)</td><td style="text-align:left">–</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">SCK (SPI)</td><td style="text-align:left">–</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">SS (SPI)</td><td style="text-align:left">0V</td><td style="text-align:left">上拉电阻不可用</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">睡眠唤醒</td><td style="text-align:left">–</td><td style="text-align:left">无上拉电阻，仅有下拉电阻 连接 RST 引脚实现睡眠唤醒</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi编辑器基本命令</title>
      <link href="/post/59501.html"/>
      <url>/post/59501.html</url>
      
        <content type="html"><![CDATA[<h2 id="vi模式切换"><a href="#vi模式切换" class="headerlink" title="vi模式切换"></a>vi模式切换</h2><p><img src="https://raw.githubusercontent.com/wild-civil/typora_img/main/images/vi.jpg" alt="vi"></p><h2 id="vi保存和退出命令"><a href="#vi保存和退出命令" class="headerlink" title="vi保存和退出命令"></a>vi保存和退出命令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">:q</td><td style="text-align:center">(Quit)退出未修改的文件（若文件被修改且未保存，则该命令无效）</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制退出，且不保存修改过的部分</td></tr><tr><td style="text-align:center">:w</td><td style="text-align:center">(Write)保存文件，但不退出</td></tr><tr><td style="text-align:center">:x</td><td style="text-align:center">(Exit)保存文件并退出（:x &lt;=&gt; :wq）</td></tr><tr><td style="text-align:center">:w File</td><td style="text-align:center">另存为File给出的文件名，不退出</td></tr><tr><td style="text-align:center">:r File</td><td style="text-align:center">（Read)读入File指定的文件内容插入到光标处</td></tr></tbody></table></div><h2 id="vi命令、编辑模式切换"><a href="#vi命令、编辑模式切换" class="headerlink" title="vi命令、编辑模式切换"></a>vi命令、编辑模式切换</h2><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">i I<br />（Insert)</td><td style="text-align:center">i 命令将文本插入到光标所在位置前。<br />I 命令将文本插入当前行的行首。当输入 I 命令后，光标自动移到该行的行首。</td></tr><tr><td style="text-align:center">a A <br />(Append)</td><td style="text-align:center">a 命令将新文本追加到光标当前所在位置之后<br />A 命令将新文本追加到所在行的行尾。当输入 A 命令后，光标自动移到该行的行尾。</td></tr><tr><td style="text-align:center">o O<br />(Open)</td><td style="text-align:center">o 命令将在光标所在行的下面插入一个空行，并将光标置于该行的行首。<br />O 命令在光标所在行的上面插入一个空行，并将光标置于该行的行首。</td></tr><tr><td style="text-align:center">:！Command</td><td style="text-align:center">在vi中执行外部命令Command，按回车键可以返回vi继续工作<br />例如，在vi命令行模式下输入:! pwd可以查看当前所在目录又或者:! date 查看时间</td></tr></tbody></table></div><p>当 vi 处于文本编辑状态，屏幕最下行显示 “—INSERT—”说明信息</p><h2 id="vi拷贝-粘贴"><a href="#vi拷贝-粘贴" class="headerlink" title="vi拷贝 粘贴"></a>vi拷贝 粘贴</h2><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">[N] x<br />(Expurgate)</td><td style="text-align:center">删除从光标位置开始的连续N行字符(并复制到编辑缓冲区)</td></tr><tr><td style="text-align:center">[N] dd<br />(Delete)</td><td style="text-align:center">该命令删除光标所在的整行。在 dd 前可加上一个数字 N，表示删除当前行及其后 N-1 行的内容。</td></tr><tr><td style="text-align:center">[N] yy<br />(Yank)</td><td style="text-align:center">复制光标所在的整行。在 yy 前可加一个数字 N，表示复制当前行及其后 N-1 行的内容。</td></tr><tr><td style="text-align:center">p 或 P<br />(Put)</td><td style="text-align:center">从编辑缓冲区复制文本到当前光标处</td></tr><tr><td style="text-align:center">u<br />(Undo)</td><td style="text-align:center">该命令撤销上一次所做的操作。多次使用 u 命令会一步一步依次撤销之前做过的操作（在一次切换到文本输入模式中输入的所有文本算一次操作）。</td></tr></tbody></table></div><h2 id="vi光标命令"><a href="#vi光标命令" class="headerlink" title="vi光标命令"></a>vi光标命令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td style="text-align:center">方向键，向左移动光标一个字符的位置，相当于键 “←”</td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">方向键，向下移动光标到下一行的位置，相当于键 “↓”</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">方向键，向上移动光标到上一行的位置，相当于键 “↑”</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">方向键，向右移动光标一个字符的位置，相当于键 “→”</td></tr><tr><td style="text-align:center">:N</td><td style="text-align:center">移动光标到第N行 (N待定)</td></tr><tr><td style="text-align:center">1G</td><td style="text-align:center">移动光标到文件的第 1 行</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">移动光标到文件的最后 1 行</td></tr><tr><td style="text-align:center">:set number</td><td style="text-align:center">设置行号显示</td></tr><tr><td style="text-align:center">set</td><td style="text-align:center">取消行号显示</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android studio 七天Java零基础入门 记录</title>
      <link href="/post/34091.html"/>
      <url>/post/34091.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本入门"><a href="#基本入门" class="headerlink" title="基本入门"></a>基本入门</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Learning record </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github搭建个人博客</title>
      <link href="/post/95eb7d.html"/>
      <url>/post/95eb7d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-github搭建个人博客，并绑定域名"><a href="#Hexo-github搭建个人博客，并绑定域名" class="headerlink" title="Hexo+github搭建个人博客，并绑定域名"></a>Hexo+github搭建个人博客，并绑定域名</h1><blockquote><p>搭建&amp;美化：<a href="http://haiyong.site/post/cda958f2.html">http://haiyong.site/post/cda958f2.html</a> </p></blockquote><p>注：本文章内容大部分来源(包括视频)来自：<a href="www.wushishu.xyz">www.wushishu.xyz </a>备用<a href="wushishu.github.io">wushishu.github.io</a></p><h1 id="第一部分视频学习"><a href="#第一部分视频学习" class="headerlink" title="第一部分视频学习"></a>第一部分视频学习</h1><iframe src="https://player.bilibili.com/player.html?aid=638754315&amp;bvid=BV1NY4y1C7Ng&amp;cid=714430663&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="800" height="500" style="box-sizing: border-box; --tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; --tw-rotate: 0; --tw-skew-x: 0; --tw-skew-y: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-pan-x: ; --tw-pan-y: ; --tw-pinch-zoom: ; --tw-scroll-snap-strictness: proximity; --tw-ordinal: ; --tw-slashed-zero: ; --tw-numeric-figure: ; --tw-numeric-spacing: ; --tw-numeric-fraction: ; --tw-ring-inset: ; --tw-ring-offset-width: 0px; --tw-ring-offset-color: #fff; --tw-ring-color: rgb(59 130 246 / 0.5); --tw-ring-offset-shadow: 0 0 #0000; --tw-ring-shadow: 0 0 #0000; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; --tw-blur: ; --tw-brightness: ; --tw-contrast: ; --tw-grayscale: ; --tw-hue-rotate: ; --tw-invert: ; --tw-saturate: ; --tw-sepia: ; --tw-drop-shadow: ; --tw-backdrop-blur: ; --tw-backdrop-brightness: ; --tw-backdrop-contrast: ; --tw-backdrop-grayscale: ; --tw-backdrop-hue-rotate: ; --tw-backdrop-invert: ; --tw-backdrop-opacity: ; --tw-backdrop-saturate: ; --tw-backdrop-sepia: ; margin: 0px 0px 20px; color: rgb(76, 73, 72); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Helvetica Neue&quot;, Lato, Roboto, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>也可以直接跟着视频走</p><h2 id="安装并配置Node-js"><a href="#安装并配置Node-js" class="headerlink" title="安装并配置Node.js"></a>安装并配置Node.js</h2><p>Node.js下载:【它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。】</p><p>教程：<a href="https://blog.csdn.net/weixin_52799373/article/details/123840137（过程详细，还覆盖win11，评论下面还有师叔的足迹）">https://blog.csdn.net/weixin_52799373/article/details/123840137（过程详细，还覆盖win11，评论下面还有师叔的足迹）</a></p><h4 id="注意一"><a href="#注意一" class="headerlink" title="注意一"></a>注意一</h4><p>全局安装最常用的 express 模块 进行测试</p><p>命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure><p>报错图片：</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311330969.png" alt="img" style="zoom:50%;" /></p><p>解决方法：</p><p>【亲测有效】</p><p>需要删除 npmrc 文件。</p><p><strong>强调：</strong>不是nodejs安装目录npm模块下的那个npmrc文件</p><p>而是在 C:\Users\（你的用户名）\下的.npmrc文件</p><p><strong><em>聪明的你，一定想到了直接用evering搜索，省的还要调用文件管理器在一点一点的找</em></strong></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331077.png" alt="img" style="zoom:50%;" /></p><h4 id="注意二"><a href="#注意二" class="headerlink" title="注意二"></a>注意二</h4><p><strong>在文章第四歩测试上查看安装结果</strong></p><p>可能会出现下面照片结果，更改了目录为什么还是C盘目录下，这时候只需要以管理员身份运行命令即可。</p><p>在下面路径下找到cmd.exe并且管理员身份运行即可。</p><p>推测：出像这种现象的原因就是执行权限不够，推荐大家在桌面建立一个快捷方式（管理员命令的）cmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\cmd.exe</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331718.png" alt="img" style="zoom:50%;" /></p><p><strong>创建管理员权限的cmd桌面快捷方式</strong></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331004.png" alt="img" style="zoom:50%;" /></p><h2 id="安装并配置Git"><a href="#安装并配置Git" class="headerlink" title="安装并配置Git"></a>安装并配置Git</h2><p>git是一个并源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理</p><p>Windows系统Git安装教程：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p><h3 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h3><p>生成ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331566.png" alt="img" style="zoom:50%;" /></p><p><strong>找到秘钥位置并复制</strong></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331246.png" alt="img" style="zoom:500%;" /></p><p><strong>测试ssh是否绑定成功</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果问你（yes or no）,直接 yes 就可以得到下面这段话</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331532.png" alt="img" style="zoom:50%;" /></p><h2 id="本地访问博客"><a href="#本地访问博客" class="headerlink" title="本地访问博客"></a>本地访问博客</h2><p>1、创建一个名为 Blog 的文件，在里面启用 Git Bash Here</p><p><a href="https://static001.geekbang.org/infoq/b0/b06a27bee58606277ea46f413b34ed14.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331193.png" alt="img" style="zoom:50%;" /></a></p><p>2、初始化hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311331023.png" alt="img" style="zoom:50%;" /></p><p>3、生成本地的hexo页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332717.png" alt="img" style="zoom:50%;" /></p><p>4、访问</p><p>打开本地服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/5f/5fde531819308103720a5c098f342092.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332849.png" alt="img" style="zoom:50%;" /></a></p><blockquote><p>长按 Ctrl + c 关闭服务器</p></blockquote><p><a href="https://static001.geekbang.org/infoq/6f/6f77175cb6028832126b38d0b820be95.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332255.png" alt="img" style="zoom:50%;" /></a></p><h2 id="上传到Github"><a href="#上传到Github" class="headerlink" title="上传到Github"></a>上传到Github</h2><p>修改_config.yml文件</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332108.png" alt="img" style="zoom:50%;" /></p><p><strong>把图片上位置更换成</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你的github地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332828.png" alt="img" style="zoom:50%;" /></p><p>安装hexo-deployer-git 自动部署发布工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/a9/a94aa787c8627d7bc2d95fc3aabe211d.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332467.png" alt="img" style="zoom:50%;" /></a></p><h3 id="生成页面"><a href="#生成页面" class="headerlink" title="生成页面"></a><strong>生成页面</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/ec/ec4dc5e76906c62036e61f4d083ebaad.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332692.png" alt="img" style="zoom:50%;" /></a></p><h4 id="注意一-1"><a href="#注意一-1" class="headerlink" title="注意一"></a>注意一</h4><p>如果报错如下：（无报错，请忽略此条）</p><p>报错信息是提示hexo的yml配置文件 冒号后面少了空格解决方案：</p><p>到提示行将对应的空格补上即可</p><p><a href="https://static001.geekbang.org/infoq/f1/f139b76ed562b895ece7557ebb5bb791.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332399.png" alt="img" style="zoom:50%;" /></a></p><p>本地文件上传到Github上面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>中间会出现一个登录界面，可以用令牌登录。（令牌及时保存，就看不到了）</p><p>结束以后就上传 Github 就成功了！！！</p><p><a href="https://static001.geekbang.org/infoq/1b/1ba83adbf958f9ed0ad0129bd843f785.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332663.png" alt="img" style="zoom:50%;" /></a></p><h4 id="注意二-1"><a href="#注意二-1" class="headerlink" title="注意二"></a>注意二</h4><p>如果出现如图错误网络报错，再次尝试，多次尝试，直到更换WiFi~~~~</p><p><a href="https://static001.geekbang.org/infoq/5e/5e33beb4a80df251722f550b7ca0de88.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332772.png" alt="img" style="zoom:50%;" /></a></p><h2 id="访问GitHub博客"><a href="#访问GitHub博客" class="headerlink" title="访问GitHub博客"></a>访问GitHub博客</h2><p><a href="https://static001.geekbang.org/infoq/0a/0a397f64a129a210ccbebdff832de7af.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332428.png" alt="img" style="zoom:50%;" /></a></p><p>访问博客，开始的页面是初始化页面，没有做美化和增加内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wushishu.github.io/</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/aa/aa2f760148fbcbf6c3ce0b43cbe3433c.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332934.png" alt="img" style="zoom: 50%;" /></a></p><h1 id="第二部分-文档学习"><a href="#第二部分-文档学习" class="headerlink" title="第二部分 文档学习"></a>第二部分 文档学习</h1><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><p><strong><em>电脑要必须有Typora！电脑要必须有Typora！电脑要必须有Typora！</em></strong>（重要的事情说三遍）</p><p>文本教程：<a href="https://dhndzwxj.vercel.app/3276806131.html">https://dhndzwxj.vercel.app/3276806131.html</a></p><p>hexo标签教程：<a href="http://haiyong.site/post/cda958f2.html">http://haiyong.site/post/cda958f2.html</a>（参考文档看需求加不加）</p><p>我们打开自己的博客根目录，跟着我一个个了解里面的这些文件（夹）都是干什么的：</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332992.png" alt="img" style="zoom:50%;" /></p><ul><li><code>_config.yml</code>：俗称站点配置文件，很多与博客网站的格式、内容相关的设置都需要在里面改。</li><li><code>node_modules</code>:存储Hexo插件的文件，可以实现各种扩展功能。一般不需要管。</li><li><code>package.json</code>：别问我，我也不知道干嘛的。</li><li><code>scaffolds</code>：模板文件夹，里面的<code>post.md</code>文件可以设置每一篇博客的模板。具体用起来就知道能干嘛了。</li><li><code>source</code>：非常重要。所有的个人文件都在里面！</li><li><code>themes</code>：主题文件夹，可以从<a href="https://hexo.io/themes/">Hexo主题官网</a>或者网上大神的Github主页下载各种各样美观的主题，让自己的网站变得逼格高端的关键！</li></ul><p>接下来重点介绍<code>source</code>文件夹。新建的博客中，<code>source</code>文件夹下默认只有一个子文件夹——<code>_posts</code>。我们写的博客都放在这个子文件夹里面。我们还可以在<code>source</code>里面新建各种子文件夹满足自己的个性化需求，对初学者而言，我们先把精力放在主线任务上，然后再来搞这些细节。</p><p><a href="https://static001.geekbang.org/infoq/3f/3f7b8b410726691082019f2ab603976b.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311332045.png" alt="img" style="zoom:50%;" /></a></p><p>写好Hellworld内容后，在命令行一键三连：</p><blockquote><p>‘hexo cl’命令用于清除缓存文件（db.json）和已生成的静态文件（public）。</p><p>例如：在更换主题后，如果发现站点更改不生效，可以运行该命令。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后随便打开一个浏览器，在网址栏输入<code>localhost:4000/</code>，就能发现自己的网站更新了！不过这只是在本地进行了更新，要想部署到网上（Github上），输入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>然后在浏览器地址栏输入<code>https://yourname.github.io</code>，或者<code>yourname.github.io</code>就能在网上浏览自己的博客了！</p><p>以上，我们的博客网站1.0版本就搭建完成了，如果没有更多的需求，做到这里基本上就可以了。如果有更多的要求，还需要进一步的精耕细作！</p><h2 id="精耕细作"><a href="#精耕细作" class="headerlink" title="精耕细作"></a>精耕细作</h2><p><strong>海拥\Butterfly 主题美化：</strong><a href="http://haiyong.site/post/22e1d5da.html">http://haiyong.site/post/22e1d5da.html</a></p><p><strong>Butterfly参考文档（小白慎入，但是他也是你走向DIY必须迈出的一歩）</strong>:<a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</a></p><p>文章中要更改的文件（.yml .bug 等）可以要用viscode打开！！！</p><p><strong>Butterfly 主题安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>这里面如果报错，如下图所示（长路漫漫，bug满满）</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311333567.png" alt="img" style="zoom:50%;" /></p><p>只需要在命令行中执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>再次安装主题即可成功</p><p><a href="https://static001.geekbang.org/infoq/a1/a1ee42ae917eb1c19261ec72b82efde4.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311333116.png" alt="img" style="zoom:50%;" /></a></p><p><strong>应用主题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/b0/b08a6de31ecdfcc74ccb0037f23094b3.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311333759.png" alt="img" style="zoom:50%;" /></a></p><p><strong>安装插件</strong></p><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/cd/cded5198aec31fec9f8b53bb76676174.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311333574.png" alt="img" style="zoom:50%;" /></a></p><h3 id="Butterfly-主题"><a href="#Butterfly-主题" class="headerlink" title="Butterfly 主题"></a>Butterfly 主题</h3><p>生成文章唯一链接</p><p>Hexo的默认文章链接格式是年，月，日，标题这种格式来生成的。如果你的标题是中文的话，那你的URL链接就会包含中文，</p><p>复制后的URL路径就是把中文变成了一大堆字符串编码，如果你在其他地方用这边文章的url链接，偶然你又修改了改文章的标题，那这个URL链接就会失效。为了给每一篇文章来上一个属于自己的链接，写下此教程，利用 hexo-abbrlink 插件，A Hexo plugin to generate static post link based on post titles ,来解决这个问题。 参考github官方： hexo-abbrlink 按照此教程配置完之后如下：</p><p>1、安装插件，在博客根目录 [Blogroot] 下打开终端，运行以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p><a href="https://static001.geekbang.org/infoq/32/32ad907f045425afedb968d20dab4507.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311333642.png" alt="img" style="zoom:50%;" /></a></p><p>2、插件安装成功后，在根目录 Blogroot(你的博客目录)的配置文件 _config.yml 找到 permalink：</p><p><a href="https://static001.geekbang.org/infoq/7e/7e4272e54cb25564b1e708e85c8539d2.png"><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311334031.png" alt="img" style="zoom:50%;" /></a></p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>这次了解我上面只有一个HelloWord的时候，为什么不让右键新建，<strong>因为需要命令生成啊，铁汁！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br><span class="line"></span><br><span class="line">hexo new post &quot;新建博客文章名&quot;</span><br><span class="line"></span><br><span class="line">hexo cl &amp;&amp; hexo g  &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h2 id="hexo更换背景图片"><a href="#hexo更换背景图片" class="headerlink" title="hexo更换背景图片"></a>hexo更换背景图片</h2><p>背景图片参考网址：</p><ul><li><a href="https://wallhaven.cc/">https://wallhaven.cc/</a></li><li><a href="https://wall.alphacoders.com/">https://wall.alphacoders.com/</a></li><li><a href="https://bz.zzzmh.cn/index">https://bz.zzzmh.cn/index</a></li></ul><p><em>本方法解决的是多次同步到GitHub上背景图片未成功的情况</em></p><p>直接更改原文件</p><p>图片所在目录：<code>hexo/themes/landscape/source/css/images/</code></p><p>图片名称：<code>banner.jpg</code></p><h2 id="⭐主题美化"><a href="#⭐主题美化" class="headerlink" title="⭐主题美化"></a>⭐主题美化</h2><p>芜湖，想做到和我主页一样的动态标题(网页崩溃欺骗)和透明页面吗</p><p>Let’s get started!</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/image-20231101154515640.png" style="zoom:80%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/image-20231101155107655.png" alt="path" style="zoom:80%;" /></p><p>一定要放在博客根目录下的source下，没有就新建一个</p><p>然后在\themes\butterfly\中的_config.yml文件下查找injection，将自己新建的文件路径添加进去</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/transpancy.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/cheat.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://youpai.hanvon.top/blog/article/blog_building/image-20231101154311035.png" alt="image-20231101154311035" style="zoom:80%;" /></p><h3 id="动态标题"><a href="#动态标题" class="headerlink" title="动态标题"></a>动态标题</h3><p><code>cheat.js</code>的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态标题</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OriginTitile</span> = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span>) &#123;</span><br><span class="line">        <span class="comment">//离开当前页面时标签显示内容</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;网页崩溃啦w(ﾟДﾟ)w ！&#x27;</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//返回当前页面时标签显示内容</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;♪(^∇^*)我又好啦！&#x27;</span> + <span class="title class_">OriginTitile</span>;</span><br><span class="line">        <span class="comment">//两秒后变回正常标题</span></span><br><span class="line">        titleTime = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">title</span> = <span class="title class_">OriginTitile</span>;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="透明页面"><a href="#透明页面" class="headerlink" title="透明页面"></a>透明页面</h3><p><code>transpancy.css</code>的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文章页背景 */</span></span><br><span class="line"><span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span> &#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.7 可以自行修改*/</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 所有页面背景 */</span></span><br><span class="line"><span class="selector-id">#aside_content</span> <span class="selector-class">.card-widget</span>, <span class="selector-id">#recent-posts</span>&gt;<span class="selector-class">.recent-post-item</span>, <span class="selector-class">.layout_page</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first</span>-child<span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>), <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#page</span>, <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>, <span class="selector-class">.read-mode</span> <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>&#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.7 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*侧边卡片的透明度 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--card-bg</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 页脚透明 */</span></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.5 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意一件事：css要放在head；js要放在bottom。不能乱放！</code></p><p>参考：<a href="https://conzxy.github.io/2022/08/19/hexo/transparent_bg/">透明化</a>    <a href="https://code7rain.github.io/2022/11/19/Hexo%E4%B8%BB%E9%A2%98Butterfly%E9%85%8D%E7%BD%AE%E3%80%81%E8%B8%A9%E5%9D%91%E5%8F%8A%E9%AD%94%E6%94%B9/">透明化</a>    <a href="https://blog.csdn.net/qq_43740362/article/details/113790851?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-113790851-blog-128843200.235%5Ev38%5Epc_relevant_sort_base1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-113790851-blog-128843200.235%5Ev38%5Epc_relevant_sort_base1&amp;utm_relevant_index=5">渐变</a></p><h1 id="第三部分-绑定自己的域名"><a href="#第三部分-绑定自己的域名" class="headerlink" title="第三部分 绑定自己的域名"></a>第三部分 绑定自己的域名</h1><p>博客地址：<a href="https://www.likecs.com/show-30474.html">https://www.likecs.com/show-30474.html</a></p><p><strong>绑定之后你就有有一个自己专属的博客了。</strong></p><p>买一个域名，可以一块钱白嫖，但是续费贵的飞天！！！</p><p><strong><em>注意请谨慎绑定，想我就会出现提交一次 (hexo d) ,需要重新绑定域名</em></strong></p><h1 id="图床："><a href="#图床：" class="headerlink" title="图床："></a>图床：</h1><p>我试了两种：GitHub和七牛云</p><p>我想说，如果你有自己的域名。可以选择七牛云，相比GitHub来说快很多</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311350299.png" alt="image-20231031135024267" style="zoom: 67%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311352581.png" alt="image-20231031135228551" style="zoom: 67%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311353997.png" alt="image-20231031135328962" style="zoom: 67%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311354876.png" alt="image-20231031135414847" style="zoom:67%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311401584.png" alt="image-20231031140102545" style="zoom:67%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311404397.png" alt="image-20231031140446365" style="zoom:67%;" /></p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311409077.png" alt="image-20231031140957036" style="zoom:67%;" /></p><p>进行到这一步就成功喽</p><p>下一步，去PicGo设置：</p><p><img src="https://youpai.hanvon.top/blog/article/blog_building/202310311408731.png" alt="image-20231031140821695" style="zoom:67%;" /></p><p><a href="https://www.cnblogs.com/skuld-yi/p/14533794.html">https://www.cnblogs.com/skuld-yi/p/14533794.html</a></p><p>—-大部分转载至 武师叔</p><p>关注公众号武师叔————————–回复博客————————-即可获得博客PDF文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-github搭建个人博客"><a href="#Hexo-github搭建个人博客" class="headerlink" title="Hexo+github搭建个人博客"></a>Hexo+github搭建个人博客</h1><h2 id="一、搭建"><a href="#一、搭建" class="headerlink" title="一、搭建"></a>一、搭建</h2><h3 id="1、视频教程："><a href="#1、视频教程：" class="headerlink" title="1、视频教程："></a>1、视频教程：</h3><h3 id="2、简易文本教程："><a href="#2、简易文本教程：" class="headerlink" title="2、简易文本教程："></a>2、简易文本教程：</h3><ul><li><h4 id="安装并配置Node-js"><a href="#安装并配置Node-js" class="headerlink" title="安装并配置Node.js"></a>安装并配置Node.js</h4></li><li><h4 id="安装并配置Git"><a href="#安装并配置Git" class="headerlink" title="安装并配置Git"></a>安装并配置Git</h4></li><li><h4 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h4><p>a. 空白处右击，打开Git Bash，输入<code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code> (将邮箱改为自己的) 敲四次回车；</p><p>b. 在<code>C:\Users\admin\.ssh</code>(admin更改为你自己的用户名)，找到”<code>id_rsa.pub</code>”文件，打开，复制秘钥</p><p>c. 打开”Github” -&gt; “seetings” -&gt; “SSH and Gpg Keys” -&gt; 点击”New SSH key”, -&gt; Title随便，将密匙复制到key -&gt; Add SSH key</p><p>d. 在Git Bash中输入<code>ssh -T git@github.com</code> (无需更改) 测试ssh是否绑定成功, 输入 yes 回车</p></li><li><h4 id="本地访问博客"><a href="#本地访问博客" class="headerlink" title="本地访问博客"></a>本地访问博客</h4><p>1、创建一个名为 Blog 的文件，在里面启用 Git Bash Here</p><p>2、输入hexo init初始化hexo</p><p>3、输入hexo s生成本地的hexo页面</p><p>4、将网址输入浏览器即可访问博客，Ctrl + c停用</p></li><li><h4 id="上到Github"><a href="#上到Github" class="headerlink" title="上到Github"></a>上到Github</h4></li></ul><p>修改-config.yml文件，在文件最后添加：(注意冒号后需添加一个半角的空格)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 你的github地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>启用 Git Bash Here，输入<code>npm install hexo-deployer-git --save</code>安装hexo-deployer-git 自动部署发布工具</p><p>输入<code>hexo g</code>生成页面</p><p>输入<code>hexo d</code>本地文件部署到Github上面</p><p>在浏览器中输入<a href="https://wild-civil.github.io/访问GitHub博客">https://wild-civil.github.io/访问GitHub博客</a> (请将wild-civil改为自己的github用户名)</p><p>文本教程：<a href="https://dhndzwxj.vercel.app/3276806131.html">https://dhndzwxj.vercel.app/3276806131.html</a></p><p>hexo标签教程：<a href="http://haiyong.site/post/cda958f2.html">http://haiyong.site/post/cda958f2.html</a> (很棒的教程)</p><p>自定义 js、css等的添加：<a href="http://www.gocit.cn/posts/5.html">http://www.gocit.cn/posts/5.html</a></p><p><a href="https://www.wxnacy.com/2017/12/12/hexo-cust-js/">https://www.wxnacy.com/2017/12/12/hexo-cust-js/</a></p><h2 id="二、Quick-Start"><a href="#二、Quick-Start" class="headerlink" title="二、Quick Start"></a>二、Quick Start</h2><h4 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>也可输入<code>hexo n</code></p><p>More info: Writing</p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>也可输入<code>hexo s</code></p><p>More info: Server</p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>也可输入<code>hexo g</code></p><p>More info: Generating</p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>也可输入<code>hexo d</code></p><p>More info: Deployment</p><p>hexo更换背景图片 背景图片参考网址：</p><p><a href="https://wallhaven.cc/">https://wallhaven.cc/</a> <a href="https://wall.alphacoders.com/">https://wall.alphacoders.com/</a> <a href="https://bz.zzzmh.cn/index">https://bz.zzzmh.cn/index</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
